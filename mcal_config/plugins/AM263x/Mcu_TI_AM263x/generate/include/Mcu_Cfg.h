/* ======================================================================
 *   Copyright (C) 2022-2023 Texas Instruments Incorporated
 *
 *   All rights reserved. Property of Texas Instruments Incorporated.
 *   Restricted rights to use, duplicate or disclose this code are
 *   granted through contract.
 *
 *   The program may not be used without the written permission
 *   of Texas Instruments Incorporated or against the terms and conditions
 *   stipulated in the agreement under which this program has been
 *   supplied.
 * ==================================================================== */

/**
 *  \file     Mcu_Cfg.h
 *
 *  \brief    This file contains generated pre compile configuration file
 *            for MCU MCAL driver
 *
 */


 /*********************************************************************************************************************
    Project: [!"$project"!]


    This file is generated by EB Tresos
    Do not modify this file, otherwise the software may behave in unexpected way.

 *********************************************************************************************************************/
 /* Protection against multiple inclusion */
#ifndef MCU_CFG_H
#define MCU_CFG_H

/**
 * \addtogroup MCU Mcu
 * @{
 */

/*********************************************************************************************************************
 * Standard Header Files
 *********************************************************************************************************************/

/*********************************************************************************************************************
 * Other Header Files
 *********************************************************************************************************************/
[!IF "node:refexists(as:modconf('Mcu')[1]/McuGeneralConfiguration/McuOsCounterRef/*)"!][!//
#include "Os.h"
[!ENDIF!][!//
[!IF "not(node:empty(as:modconf('Mcu')[1]/McuModuleConfiguration/McuDemEventParameterRefs/*))"!][!//
#include "Dem.h"
[!ENDIF!][!//
#ifdef __cplusplus
extern "C" {
#endif

#ifndef DOXYGEN_SHOULD_SKIP_THIS

/**********************************************************************************************************************
 * Version Check
 *********************************************************************************************************************/
/** \brief MCU Config ID */
#define MCU_CFG_ID                      (0x1U)

/* Requirements: SWS_Mcu_00129 */
/**
 *  \name Mcu Driver Configuration SW Version Info
 *
 *  Defines for Mcu Driver configuration version
 *  @{
 */
/** \brief Mcu configuration Major Version */
#define MCU_CFG_MAJOR_VERSION           ([!"substring-before($moduleSoftwareVer,'.')"!]U)
/** \brief Mcu configuration Minor Version */
#define MCU_CFG_MINOR_VERSION           ([!"substring-before(substring-after($moduleSoftwareVer,'.'),'.')"!]U)
/** \brief Mcu configuration Patch Version */
#define MCU_CFG_PATCH_VERSION           ([!"substring-after(substring-after($moduleSoftwareVer,'.'),'.')"!]U)
/* @} */


/*********************************************************************************************************************
 * Exported enums
 *********************************************************************************************************************/
/**
* \brief  Type of McuModes supported
*/
enum
{
   MCU_MODE_NORMAL = 1 /*!< Mcu normal mode. Only supported mode */
};

/*********************************************************************************************************************
 * Exported Preprocessor #define Constants
 *********************************************************************************************************************/

/**
 *  \name Pre-Compile Switches for API Services
 *  @{
 */

/** \brief Enable/Disable Development Error Detection */
#define MCU_DEV_ERROR_DETECT       [!IF "as:modconf('Mcu')[1]/McuGeneralConfiguration/McuDevErrorDetect = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!]
/** \brief Enable/Disable Mcu_CheckRamState() API */
#define MCU_GET_RAM_STATE_API      [!IF "as:modconf('Mcu')[1]/McuGeneralConfiguration/McuGetRamStateApi = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!]
/** \brief Enable/Disable Mcu_InitClock() API */
#define MCU_INIT_CLOCK_API         [!IF "as:modconf('Mcu')[1]/McuGeneralConfiguration/McuInitClock = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!]
/** \brief Enable/Disable Mcu_PerformReset() API */
#define MCU_PERFORM_RESET_API      [!IF "as:modconf('Mcu')[1]/McuGeneralConfiguration/McuPerformResetApi = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!]
/** \brief Enable/Disable Mcu_GetVersionInfo() API */
#define MCU_GET_VERSION_INFO_API   [!IF "as:modconf('Mcu')[1]/McuGeneralConfiguration/McuVersionInfoApi = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!]
/** \brief Enable/Disable Mcu_InitRamSection() API */
#define MCU_INIT_RAM_API           [!IF "as:modconf('Mcu')[1]/McuGeneralConfiguration/McuInitRamApi = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!]
/** \brief Enable/Disable PLL support */
#define MCU_NO_PLL                 [!IF "as:modconf('Mcu')[1]/McuGeneralConfiguration/McuNoPll = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!]
/** \brief Enable/Disable Mcu_ClearResetReason() API */
#define MCU_REGISTER_READBACK_API [!IF "as:modconf('Mcu')[1]/McuGeneralConfiguration/McuRegisterReadbackApi = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!]
/** \brief Enable/Disable MCU Interrupt Crossbar */
#define MCU_INTRCROSSBAR_ENABLE      [!IF "as:modconf('Mcu')[1]/McuGeneralConfiguration/McuIntrCrossbarEnable   = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!]
/** \brief Enable/Disable MCU Input Crossbar */
#define MCU_INPUT_CROSSBAR_ENABLE      [!IF "as:modconf('Mcu')[1]/McuGeneralConfiguration/McuInputCrossbarEnable   = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!]
/** \brief Enable/Disable MCU PWM Enable */
#define MCU_PWM_ENABLE [!IF "(node:exists(as:modconf('Pwm')[1]/PwmGeneral)) or (node:exists(as:modconf('Cdd_Pwm')[1]/CddPwmGeneral))"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!]
/** \brief Enable/Disable MCU ADC Enable */
#define MCU_ADC_ENABLE [!IF "(node:exists(as:modconf('Adc')[1]/AdcGeneral))"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!]
/** \brief Enable/Disable MCU ETH Enable */
#define MCU_ETH_ENABLE [!IF "(node:exists(as:modconf('Eth')[1]/EthGeneral))"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!]
/* @} */

/**
* \name Reset Reason Config
* @{
*/
/*<MCU_CFG_RESETREASONUSERCONFIG_LIST>*/
[!LOOP "as:modconf('Mcu')[1]/McuPublishedInformation/McuResetReasonConf/*"!]
#define McuConf_McuResetReasonConf_[!"@name"!] ([!"McuResetReason"!]U)[!CR!]
[!ENDLOOP!]
/* @} */


/*
 * The following defines shall be used as input
 * parameter for: Mcu_SetMode(),
 *                Mcu_InitClock()
 *                Mcu_InitRamSection()
 */

/*<MCU_CFG_MODEUSERCONFIG_LIST>*/
[!LOOP "as:modconf('Mcu')[1]/McuModuleConfiguration/McuModeSettingConf/*"!]
[!VAR "Mode"="McuMode"!]
#define McuConf_McuModeSettingConf_[!"@name"!] [!IF "$Mode = '0'"!]MCU_MODE_NORMAL[!ENDIF!][!CR!]
[!ENDLOOP!]
/**
 *  \name Build variant for modules
 *  @{
 */
#define MCU_VARIANT_PRE_COMPILE       [!IF "as:modconf('Mcu')[1]/IMPLEMENTATION_CONFIG_VARIANT = 'VariantPreCompile'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!]

#define MCU_VARIANT_POST_BUILD        [!IF "as:modconf('Mcu')[1]/IMPLEMENTATION_CONFIG_VARIANT = 'VariantPostBuild'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!]

[!IF "as:modconf('Mcu')[1]/IMPLEMENTATION_CONFIG_VARIANT = 'VariantPreCompile'"!]
/**
* \brief Pre Compile config macro name.
*/
[!LOOP "as:modconf('Mcu')[1]/McuModuleConfiguration"!]
#define MCU_INIT_CONFIG_PC        Mcu_Config
[!ENDLOOP!]
[!ENDIF!]
/* @} */

/**
* \name Clock configuration
*@{
*/
/* SourceId : MCU_SourceId_040 */
/*<MCU_CFG_CLOCKUSERCONFIG_LIST>*/
[!LOOP "as:modconf('Mcu')[1]/McuModuleConfiguration/.[1]/McuClockSettingConfig/*"!]#define McuConf_McuClockSettingConfig_[!"@name"!] ([!"@index"!]U)[!CR!][!ENDLOOP!]
/* @} */
/*</MCU_CFG_CLOCKUSERCONFIG_LIST>*/

[!IF "as:modconf('Mcu')[1]/McuGeneralConfiguration/McuNoPll = 'false'"!][!//
/*
   PLL Clock Configuration for AM263x
*/
#define McuCoreDPLLClockout             2000000000U
#define McuCoreDPLLClockout_HSDIV0      400000000U
#define McuCoreDPLLClockout_HSDIV1      500000000U
#define McuCoreDPLLClockout_HSDIV2      400000000U


#define McuPerDPLLClockout              1920000000U
#define McuPerDPLLClockout_HSDIV0       160000000U
#define McuPerDPLLClockout_HSDIV1       192000000U

/*PLL configuration number*/
#define MCU_PLL_CONFIG           (1U)

[!ENDIF!][!//
/*
* RAM Section configuration
*/
/*<MCU_CFG_RAMSECTIONUSERCONFIG_LIST>*/
[!LOOP "as:modconf('Mcu')[1]/McuModuleConfiguration/.[1]/McuRamSectorSettingConf/*"!]#define [!"@name"!] ([!"@index"!]U)[!CR!][!ENDLOOP!]
/*</MCU_CFG_RAMSECTIONUSERCONFIG_LIST>*/


/** \brief Counter ID for counter used to count wait ticks */
#define MCU_OS_COUNTER_ID               ((CounterType)[!IF "node:refexists(as:modconf('Mcu')[1]/McuGeneralConfiguration/McuOsCounterRef)"!][!"node:name(node:ref(as:modconf('Mcu')[1]/McuGeneralConfiguration/McuOsCounterRef))"!][!ELSE!][!"as:modconf('Mcu')[1]/McuGeneralConfiguration/McuDefaultOSCounterId"!]U[!ENDIF!])

/**
*  \name MCU timeout.
*   Each tick is 31.25us (for 32K Counter). Wait for 5s which comes to
*   below value
* @{
*/
#define MCU_TIMEOUT_DURATION            ([!"as:modconf('Mcu')[1]/McuGeneralConfiguration/McuTimeoutDuration"!]U)

/** \brief MCU PLL timeout.*/
#define MCU_PLL_TIMEOUT_DURATION            ([!"as:modconf('Mcu')[1]/McuGeneralConfiguration/McuPllTimeoutDuration"!]U)
/* @} */
/*
*Design: MCAL-14296, MCAL-14294, MCAL-14291
*/
/**
 *  \name MCU DEM Error Codes
 * @{
 */
[!NOCODE!][!//
[!IF "node:exists(as:modconf('Mcu')[1]/McuModuleConfiguration/McuDemEventParameterRefs)"!][!//
[!IF "not(node:refexists(as:modconf('Mcu')[1]/McuModuleConfiguration/McuDemEventParameterRefs/MCU_E_MODE_FAILURE)) and not(node:refexists(as:modconf('Mcu')[1]/McuModuleConfiguration/McuDemEventParameterRefs/MCU_E_CLOCK_FAILURE)) and not(node:refexists(as:modconf('Mcu')[1]/McuModuleConfiguration/McuDemEventParameterRefs/MCU_E_HARDWARE_ERROR))"!]
[!WARNING "DEM enabled but no DEM error configured"!]
[!ENDIF!]
[!ENDIF!][!//
[!ENDNOCODE!][!//

[!IF "node:exists(as:modconf('Mcu')[1]/McuModuleConfiguration/McuDemEventParameterRefs/MCU_E_MODE_FAILURE)"!][!//
/* MCU DEM Event Configuration*/
#ifndef MCU_E_MODE_FAILURE
/** \brief MCU Mode failed - Additional DEM event supported by the Texas Instruments*/
#define MCU_E_MODE_FAILURE ([!IF "node:refexists(as:modconf('Mcu')[1]/McuModuleConfiguration/McuDemEventParameterRefs/MCU_E_MODE_FAILURE)"!]DemConf_DemEventParameter_[!"node:name(node:ref(as:modconf('Mcu')[1]/McuModuleConfiguration/.[1]/McuDemEventParameterRefs/MCU_E_MODE_FAILURE))"!][!ELSE!][!ERROR "DEM error id is not configured"!][!ENDIF!])
#endif
[!ENDIF!][!//

[!IF "node:exists(as:modconf('Mcu')[1]/McuModuleConfiguration/McuDemEventParameterRefs/MCU_E_CLOCK_FAILURE)"!][!//
/* Design: MCAL-15239, MCAL-15240 */
/* MCU DEM Event Configuration*/
#ifndef MCU_E_CLOCK_FAILURE
/** \brief MCU Clock failed - AUTOSAR ECUC Driver SWS Item - ECUC_Mcu_00188*/
#define MCU_E_CLOCK_FAILURE ([!IF "node:refexists(as:modconf('Mcu')[1]/McuModuleConfiguration/McuDemEventParameterRefs/MCU_E_CLOCK_FAILURE)"!]DemConf_DemEventParameter_[!"node:name(node:ref(as:modconf('Mcu')[1]/McuModuleConfiguration/.[1]/McuDemEventParameterRefs/MCU_E_CLOCK_FAILURE))"!][!ELSE!][!ERROR "DEM error id is not configured"!][!ENDIF!])
#endif
[!ENDIF!][!//

[!IF "node:exists(as:modconf('Mcu')[1]/McuModuleConfiguration/McuDemEventParameterRefs/MCU_E_HARDWARE_ERROR)"!][!//
#ifndef MCU_E_HARDWARE_ERROR
/** \brief Hardware failed */
#define MCU_E_HARDWARE_ERROR          ([!IF "node:refexists(as:modconf('Mcu')[1]/McuModuleConfiguration/McuDemEventParameterRefs/MCU_E_HARDWARE_ERROR)"!]DemConf_DemEventParameter_[!"node:name(node:ref(as:modconf('Mcu')[1]/McuModuleConfiguration/.[1]/McuDemEventParameterRefs/MCU_E_HARDWARE_ERROR))"!][!ELSE!][!ERROR "DEM error id is not configured"!][!ENDIF!])
#endif
[!ENDIF!][!//
/* @} */
/* MCU Clock Config Size */
[!VAR "ClkCnfg" = "0"!][!//
[!LOOP "as:modconf('Mcu')[1]/McuModuleConfiguration/McuClockSettingConfig/*"!][!//
[!VAR "ClkCnfg" = "$ClkCnfg+1"!][!//
[!ENDLOOP!][!//
#define MCU_CLOCK_CONFIG ([!"num:i($ClkCnfg)"!]U)

/* MCU CDD PWM Channel */
[!VAR "CddPwmChnls" = "0"!][!//
[!IF "(node:exists(as:modconf('Cdd_Pwm')[1]/CddPwmGeneral))"!][!//
[!IF "(num:i(count(as:modconf('Mcu')[1]/McuModuleConfiguration/McuCddPwmConfiguration/*)) > 0)"!][!//
[!LOOP "as:modconf('Mcu')[1]/McuModuleConfiguration/McuCddPwmConfiguration/*"!][!//
[!VAR "CddPwmChnls" = "$CddPwmChnls+1"!][!//
[!ENDLOOP!][!//
[!ENDIF!][!//
[!ENDIF!][!//
#define MCU_NUM_OF_CDD_PWM_CHANNELS ([!"num:i($CddPwmChnls)"!]U)

/* MCU CDD PWM Channel */
[!VAR "PwmChnls" = "0"!][!//
[!IF "(node:exists(as:modconf('Pwm')[1]/PwmGeneral))"!][!//
[!IF "(num:i(count(as:modconf('Mcu')[1]/McuModuleConfiguration/McuPwmConfiguration/*)) > 0)"!][!//
[!LOOP "as:modconf('Mcu')[1]/McuModuleConfiguration/McuPwmConfiguration/*"!][!//
[!VAR "PwmChnls" = "$PwmChnls+1"!][!//
[!ENDLOOP!][!//
[!ENDIF!][!//
[!ENDIF!][!//
#define MCU_NUM_OF_ASR_PWM_CHANNELS ([!"num:i($PwmChnls)"!]U)

/* MCU PWM Channel */
[!VAR "PwmChnls" = "0"!][!//
[!VAR "CddPwmChnls" = "0"!][!//
[!IF "(node:exists(as:modconf('Pwm')[1]/PwmGeneral))"!][!//
[!IF "(num:i(count(as:modconf('Mcu')[1]/McuModuleConfiguration/McuPwmConfiguration/*)) > 0)"!][!//
[!LOOP "as:modconf('Mcu')[1]/McuModuleConfiguration/McuPwmConfiguration/*"!][!//
[!VAR "PwmChnls" = "$PwmChnls+1"!][!//
[!ENDLOOP!][!//
[!ENDIF!][!//
[!ENDIF!][!//
[!IF "(node:exists(as:modconf('Cdd_Pwm')[1]/CddPwmGeneral))"!][!//
[!IF "(num:i(count(as:modconf('Mcu')[1]/McuModuleConfiguration/McuCddPwmConfiguration/*)) > 0)"!][!//
[!LOOP "as:modconf('Mcu')[1]/McuModuleConfiguration/McuCddPwmConfiguration/*"!][!//
[!VAR "CddPwmChnls" = "$CddPwmChnls+1"!][!//
[!ENDLOOP!][!//
[!ENDIF!][!//
[!ENDIF!][!//
#define MCU_PWM_CHANNEL ([!"num:i($PwmChnls+$CddPwmChnls)"!]U)

/* MCU ADC Channel */
[!VAR "AdcUnits" = "0"!][!//
[!LOOP "as:modconf('Mcu')[1]/McuModuleConfiguration/McuAdcConfiguration/*"!][!//
[!VAR "AdcUnits" = "$AdcUnits+1"!][!//
[!ENDLOOP!][!//
#define MCU_ADC_HWUNIT ([!"num:i($AdcUnits)"!]U)

/* MCU ETH Port */
[!VAR "EthPorts" = "0"!][!//
[!LOOP "as:modconf('Mcu')[1]/McuModuleConfiguration/McuEthConfiguration/*"!][!//
[!VAR "EthPorts" = "$EthPorts+1"!][!//
[!ENDLOOP!][!//
#define MCU_ETH_PORTS ([!"num:i($EthPorts)"!]U)

#endif /* DOXYGEN_SHOULD_SKIP_THIS */

/*********************************************************************************************************************
 * Exported Type Declarations
 *********************************************************************************************************************/

/* Design: MCAL-14429, MCAL-14424 */
/**
 *  \brief  This is the type of the reset enumerator containing the subset of
 *  reset types. <br>
 *  It is not required that all reset types are supported by hardware
 *
 */
typedef enum
{
    /** \brief Reset Reason Cleared */
    MCU_RESET_CLEAR,
    /** \brief POR Reset */
    MCU_POWER_ON_RESET,
    /** \brief Warm Reset due to MSS_WDT0 */
    MCU_WARM_RESET_WDT0,
    /** \brief Warm Reset due to MSS_WDT1 */
	MCU_WARM_RESET_WDT1,
    /** \brief Warm Reset due to MSS_WDT2 */
	MCU_WARM_RESET_WDT2,
    /** \brief Warm Reset due to MSS_WDT3 */
	MCU_WARM_RESET_WDT3,
    /** \brief Warm Reset due to TOPRCM WARM_RESET_CONFIG */
    MCU_WARM_RESET,
    /** \brief External Pad Reset */
    MCU_EXT_PAD_RESET,
    /** \brief Warm Reset due to HSM WDT */
    MCU_HSM_WDT_RESET,
    /** \brief Warm Reset due to Debugger reset */
	MCU_DEBUGGER_RESET,
    /** \brief Warm Reset due to Temprature sensor 0 */
	MCU_WARM_RESET_TEMP0,
    /** \brief Warm Reset due to Temprature sensor 1 */
	MCU_WARM_RESET_TEMP1,
    /** \brief UNDEFINED  reset */
    MCU_RESET_UNDEFINED
} Mcu_ResetType;


/**
 *  \enum Mcu_ClkModuleIdType
 *  \brief Clock source config modules id enum
 *
 *  Clock source config ids defines are used to set clock source for specific
 *  modules
 */
typedef enum
{
    /** \brief System Clock, clock select is ignored */
    MCU_CLKSRC_MODULE_ID_SYSCLK,
    /** \brief MSS MCAN0 clock */
    MCU_CLKSRC_MODULE_ID_MCAN0,
    /** \brief MSS MCAN1 clock */
    MCU_CLKSRC_MODULE_ID_MCAN1,
    /** \brief MSS MCAN2 clock */
	MCU_CLKSRC_MODULE_ID_MCAN2,
    /** \brief MSS MCAN3 clock */
	MCU_CLKSRC_MODULE_ID_MCAN3,
    /** \brief MSS RTIA clock */
    MCU_CLKSRC_MODULE_ID_RTI0,
    /** \brief MSS RTIB clock */
    MCU_CLKSRC_MODULE_ID_RTI1,
    /** \brief MSS RTIC clock */
    MCU_CLKSRC_MODULE_ID_RTI2,
    /** \brief MSS RTIC clock */
	MCU_CLKSRC_MODULE_ID_RTI3,
    /** \brief MSS WDT clock */
    MCU_CLKSRC_MODULE_ID_WDT0,
    /** \brief MSS WDT clock */
	MCU_CLKSRC_MODULE_ID_WDT1,
    /** \brief MSS WDT clock */
	MCU_CLKSRC_MODULE_ID_WDT2,
    /** \brief MSS WDT clock */
	MCU_CLKSRC_MODULE_ID_WDT3,
    /** \brief MSS QSPI clock */
    MCU_CLKSRC_MODULE_ID_QSPI,
    /** \brief MSS SPIA clock */
    MCU_CLKSRC_MODULE_ID_MCSPI0,
    /** \brief MSS SPIA clock */
	MCU_CLKSRC_MODULE_ID_MCSPI1,
    /** \brief MSS SPIA clock */
	MCU_CLKSRC_MODULE_ID_MCSPI2,
    /** \brief MSS SPIA clock */
	MCU_CLKSRC_MODULE_ID_MCSPI3,
    /** \brief MSS SPIA clock */
	MCU_CLKSRC_MODULE_ID_MCSPI4,
    /** \brief MSS SPIB clock */
    MCU_CLKSRC_MODULE_ID_SPIB,
    /** \brief MSS I2C clock */
    MCU_CLKSRC_MODULE_ID_I2C,
    /** \brief MSS SCIA clock */
    MCU_CLKSRC_MODULE_ID_SCI0,
    /** \brief MSS SCIB clock */
    MCU_CLKSRC_MODULE_ID_SCI1,
    /** \brief MSS SCIB clock */
	MCU_CLKSRC_MODULE_ID_SCI2,
    /** \brief MSS SCIB clock */
	MCU_CLKSRC_MODULE_ID_SCI3,
    /** \brief MSS SCIB clock */
	MCU_CLKSRC_MODULE_ID_SCI4,
    /** \brief MSS SCIB clock */
	MCU_CLKSRC_MODULE_ID_SCI5,
    /** \brief MSS CPSW clock */
    MCU_CLKSRC_MODULE_ID_CPSW,
    /** \brief MSS CPTS clock */
    MCU_CLKSRC_MODULE_ID_CPTS,
    /** \brief MSS MCU CLKOUT0 clock */
    MCU_CLKSRC_MODULE_ID_MCU_CLKOUT0,
    /** \brief MSS MCU CLKOUT1 clock */
    MCU_CLKSRC_MODULE_ID_MCU_CLKOUT1,
    /** \brief MSS PMIC CLKOUT clock */
    MCU_CLKSRC_MODULE_ID_PMIC_CLKOUT,
    /** \brief MSS MII 100 CLK clock */
    MCU_CLKSRC_MODULE_ID_MII100_CLK,
    /** \brief MSS MII 10 CLK clock */
    MCU_CLKSRC_MODULE_ID_MII10_CLK,
    /** \brief MSS RGMI CLK clock */
    MCU_CLKSRC_MODULE_ID_RGMI_CLK,
    /** \brief MSS CONTROLSS CLK clock */
	MCU_CLKSRC_MODULE_ID_CONTROLSS_CLK,
    /** \brief MSS Module ID max */
    MCU_CLKSRC_MODULE_ID_MAX
} Mcu_ClkModuleIdType;

/**
 * \brief  This is the type of the clock source in clock tree that is selectable
 *         for  peripheral. Please see TRM to map clock source to module.
 */
typedef enum
{
    /** \brief Clock source 0 */
    MCU_CLKSRC_0 = 0,
    /** \brief Clock source 1 */
    MCU_CLKSRC_1,
    /** \brief Clock source 2 */
    MCU_CLKSRC_2,
    /** \brief Clock source 3 */
    MCU_CLKSRC_3,
    /** \brief Clock source 4 */
    MCU_CLKSRC_4,
    /** \brief Clock source 5 */
    MCU_CLKSRC_5,
    /** \brief Clock source 6 */
    MCU_CLKSRC_6,
    /** \brief Clock source 7 */
    MCU_CLKSRC_7,
    /** \brief Clock source Max */
    MCU_CLKSRC_MAX
}Mcu_ClkSourceIdType;
[!IF "(node:exists(as:modconf('Eth')[1]/EthGeneral))"!]
/**
 *  \brief  Type/Speed/Duplex Connection Config Options
 *
 *  Connection Config Options
 *
 */
typedef enum
{
    MCU_ETH_MAC_CONN_TYPE_MII_10_HALF = 0x00U,
    /**< MAC connection type for half-duplex 10Mbps MII mode */
    MCU_ETH_MAC_CONN_TYPE_MII_10_FULL = 0x01U,
    /**< MAC connection type for full-duplex 10Mbps MII mode */
    MCU_ETH_MAC_CONN_TYPE_MII_100_HALF = 0x02U,
    /**< MAC connection type for half-duplex 100Mbps MII mode */
    MCU_ETH_MAC_CONN_TYPE_MII_100_FULL = 0x03U,
    /**< MAC connection type for full-duplex 100Mbps MII mode */
    MCU_ETH_MAC_CONN_TYPE_RMII_10_HALF = 0x04U,
    /**< MAC connection type for half-duplex 10Mbps RMII mode */
    MCU_ETH_MAC_CONN_TYPE_RMII_10_FULL = 0x05U,
    /**< MAC connection type for full-duplex 10Mbps RMII mode */
    MCU_ETH_MAC_CONN_TYPE_RMII_100_HALF = 0x06U,
    /**< MAC connection type for half-duplex 100Mbps RMII mode */
    MCU_ETH_MAC_CONN_TYPE_RMII_100_FULL = 0x07U,
    /**< MAC connection type for full-duplex 100Mbps RMII mode */
    MCU_ETH_MAC_CONN_TYPE_RGMII_FORCE_10_HALF = 0x08U,
    /**< MAC connection type for forced half-duplex 10Mbps RGMII mode */
    MCU_ETH_MAC_CONN_TYPE_RGMII_FORCE_10_FULL = 0x09U,
    /**< MAC connection type for forced full-duplex 10Mbps RGMII mode */
    MCU_ETH_MAC_CONN_TYPE_RGMII_FORCE_100_HALF = 0x0AU,
    /**< MAC connection type for forced half-duplex 100Mbps RGMII mode */
    MCU_ETH_MAC_CONN_TYPE_RGMII_FORCE_100_FULL = 0x0BU,
    /**< MAC connection type for forced full-duplex 100Mbps RGMII mode */
    MCU_ETH_MAC_CONN_TYPE_RGMII_FORCE_1000 = 0x0CU,
    /**< MAC connection type for forced 1000Mbps RGMII mode */
    MCU_ETH_MAC_CONN_TYPE_RGMII_DETECT_INBAND = 0x0DU,
    /**< MAC connection type for RGMII inband detection mode (speed determined
     *   based on received RGMII Rx clock) */
} Mcu_MacConnectionType;
[!ENDIF!]
/* Requirements: SWS_Mcu_00030 */
/**
 *  \brief Structure for data pre-setting to be initialized
 */
typedef struct
{
    /** \brief RAM section base address, Destination */
    P2VAR(uint8, AUTOMATIC, MCU_RAM_COPY) Mcu_RamSectionBaseAddress;
    /** \brief RAM Default Value */
    uint8  Mcu_RamDefaultValue;
    /** \brief Section Size */
    uint32 Mcu_RamSectionBytes;

} Mcu_RamSectionConfigType;

/* Requirements: SWS_Mcu_00031 */
/**
 *  \brief Structure for module clock setting
 */
typedef struct
{
    /** \brief ModuleId for which clock setting to be applied */
    Mcu_ClkModuleIdType Mcu_ClockModuleId;
    /** \brief Clock source Id for the module */
    Mcu_ClkSourceIdType Mcu_ClockSourceId;
    /** \brief Clock divider value for the module  */
    uint32              Mcu_ClockDiv;
    /** \brief Apply this configuration at Mcu_init time*/
    boolean             Mcu_InitCfg;

} Mcu_ClockConfigType;

[!IF "as:modconf('Mcu')[1]/McuGeneralConfiguration/McuNoPll = 'false'"!][!//
/**
 *  \brief Type for PLL source selection
 */
typedef enum
{
    /** \brief Clock source DPLL */
    MCU_CLKSRC_DPLL = 0,
    /** \brief Clock source APLL */
    MCU_CLKSRC_APLL
} Mcu_PllSourceIdType;


/**
 * \brief Structure for enumerating the clock outputs of HSDIVIDER
 */
typedef struct
{
    uint16  N;
    uint16  M2;
    uint16  FracM;
    uint16  sdDiv;
    uint64  MCU_PLL_CLKOUT;
    uint64  MCU_PLL_HSDIV0;
    uint64  MCU_PLL_HSDIV1;
    uint64  MCU_PLL_HSDIV2;

} Mcu_PllClkDivType;

/**
 *  \brief MCU PLL CONFIG structure
 */
typedef struct
{
    Mcu_PllClkDivType Mcu_PllClk1;
    Mcu_PllClkDivType Mcu_PllClk2;

} Mcu_PllConfigType;

/**
 * @brief HS Divider Clock Out Mux Clock Sources
 */
typedef enum
{
    DPLL_CORE_HSDIV0_CLKOUT2_PreMux = 0x0,
    DPLL_PER_HSDIV0_CLKOUT1_PreMux = 0x0,
    APLL_1p2G_HSDIV0_CLKOUT0 = 0x1,
    APLL_1p2G_HSDIV0_CLKOUT1 = 0x1,
    APLL_1p2G_HSDIV0_CLKOUT2 = 0x1,
    APLL_1p2G_HSDIV0_CLKOUT3 = 0x1,
    APLL_1p8G_HSDIV0_CLKOUT0 = 0x2,
    APLL_1p8G_HSDIV0_CLKOUT1 = 0x2,
    APLL_400MHZ = 0x3
} Mcu_HSDIVClkOutMuxClockSource;

/**
 *  \brief Pointer to PLL Config structure
 */
typedef P2CONST (Mcu_PllConfigType, AUTOMATIC, MCU_PBCFG)
Mcu_PllConfigPtrType;

[!ENDIF!][!//

/**
 *  \brief Structure for PWM clock configuration
 */
typedef struct
{
    /** \brief Channel id of PWM */
    uint8 Mcu_PwmChannelId;
    /** \brief Group id of PWM */
    uint8 Mcu_PwmGroupId;

} Mcu_PwmConfigType;

/**
 *  \brief Structure for ADC Buffer configuration
 */
typedef struct
{
    /** \brief HW id of ADC */
    uint8 Mcu_AdcHWUniId;

} Mcu_AdcConfigType;
[!IF "(node:exists(as:modconf('Eth')[1]/EthGeneral))"!]
/**
 *  \brief Structure for Eth CPSW Control configuration
 */
typedef struct
{
    /** \brief ETH MAC port number */
    uint8 macNum;
    /** \brief ETH MII Clock output disable */
    uint8 rmiiClkOutDisable;
    /** \brief ETH enable ID mode */
    uint8 idModeEnable;
    /** \brief ETH MII MAC connection type */
    Mcu_MacConnectionType macConnectionType;
} Mcu_EthConfigType;
[!ENDIF!]
/**
 *  \brief Structure for PRCM configuration
 */
typedef struct
{
    /** \brief Moudle Id to enable/disable */
    uint8 Mcu_RcmModuleId;
    /** \brief Moudle mode to set @sa MCAL_MCU_API:RCM modules mode defines */
    uint8 Mcu_RcmModuleMode;

} Mcu_RCMConfigType;

/**
 *  \brief Pointer to RamConfig structure
 */
typedef P2CONST (Mcu_RamSectionConfigType, AUTOMATIC, MCU_PBCFG)
Mcu_RamConfigPtrType;

/**
   \brief Pointer to PrcmConfig structure
*
*/
typedef P2CONST (Mcu_RCMConfigType, AUTOMATIC, MCU_PBCFG)
Mcu_RCMConfigPtrType;

/**
 *  \brief Pointer to Clock Config structure
 */
typedef P2CONST (Mcu_ClockConfigType, AUTOMATIC, MCU_PBCFG)
Mcu_ClockConfigPtrType;

/**
 *  \brief Pointer to PWM Clock Config structure
 */
typedef P2CONST (Mcu_PwmConfigType, AUTOMATIC, MCU_PBCFG)
Mcu_PwmConfigPtrType;

/**
 *  \brief Pointer to ADC buffer Config structure
 */
typedef P2CONST (Mcu_AdcConfigType, AUTOMATIC, MCU_PBCFG)
Mcu_AdcConfigPtrType;
[!IF "(node:exists(as:modconf('Eth')[1]/EthGeneral))"!]
/**
 *  \brief Pointer to Eth CPSW Control configuration
 */
typedef P2CONST (Mcu_EthConfigType, AUTOMATIC, MCU_PBCFG)
Mcu_EthConfigPtrType;
[!ENDIF!]
/**
 *  \brief MCU CONFIG Register READBACK structure
 */
typedef struct
{
    /** \brief Clock source selection */
    uint32 CLKSRCSEL0;
}Mcu_RegisterReadbackType;

/* Design: MCAL-14430, MCAL-15238, MCAL-14431, MCAL-14432 */
/**
 *  \brief MCU CONFIG ROOT structure
 */
typedef struct Mcu_ConfigType_s
{
    /** \brief Reset mode to be used @sa  MCAL_MCU_API:ResetModes */
    uint8                    Mcu_ResetMode;
    /** \brief Configration of Ram Sections */
    /* Requirements: SWS_Mcu_00030 */
    Mcu_RamConfigPtrType     Mcu_ConfigRamSection;
    /** \brief Number of entries in Mcu_ConfigRamSection */
    /* Requirements: SWS_Mcu_00031, SWS_Mcu_00019 */
    uint8                    Mcu_NumberOfRamSectors;
    /** \brief Configuration of Module functional clock source */
    Mcu_ClockConfigPtrType   Mcu_ClockConfig;
    /** \brief Number of entries in Mcu_ClockConfig */
    uint8                    Mcu_NumberOfClockConfig;
	#if (STD_OFF == MCU_NO_PLL)
    /** \brief PLL Configuration */
    Mcu_PllConfigPtrType     Mcu_PllConfig;
    /** \brief PLL source selection */
    Mcu_PllSourceIdType      Mcu_PllSourceId;
	#endif
	#if (STD_ON == MCU_PWM_ENABLE)
    /** \brief PWM Configuration */
	Mcu_PwmConfigPtrType     Mcu_Pwmconfig;
	#endif
	#if (STD_ON == MCU_ADC_ENABLE)
    /** \brief ADC Configuration */
	Mcu_AdcConfigPtrType     Mcu_AdcConfig;
	#endif
[!IF "(node:exists(as:modconf('Eth')[1]/EthGeneral))"!]
    #if (STD_ON == MCU_ETH_ENABLE)
    /** \brief ETH Configuration */
    Mcu_EthConfigPtrType     Mcu_EthConfig;
    #endif
[!ENDIF!]
} Mcu_ConfigType;

#ifndef DOXYGEN_SHOULD_SKIP_THIS

/** @brief Number of ETPWM instances */
#define MCU_CSL_ETPWM_PER_CNT                (32U)

/*Control MMRs partition*/
#define MCU_TOP_CTRL_PARTITION0                                (2U)
#define MCU_CONTROLSS_CTRL_PARTITION0                          (3U)
/*Clock and reset MMRs partition*/
#define MCU_TOP_RCM_PARTITION0                                 (5U)

/* MSS CTRL partition */
#define MCU_MSS_CTRL_PARTITION0                                (6U)

/* MSS CTRL base address */
#define MCU_CSL_MSS_CTRL_BASE   (0x50D00000U)

#define MCU_CSL_CONTROLSS_CTRL_EPWM_STATICXBAR_SEL0                          (0x00000004U)

#define MCU_CSL_TOP_RCM_U_BASE                                                   (0x53200000UL)
#define MCU_CSL_TOP_CTRL_U_BASE                                              (0x50D80000UL)
#define MCU_CSL_CONTROLSS_CTRL_U_BASE                                        (0x502F0000UL)
#define MCU_CSL_CONTROLSS_CTRL_LOCK0_KICK0                                   (0x00001008U)
#define MCU_CSL_CONTROLSS_CTRL_LOCK0_KICK1                                   (0x0000100CU)

#define MCU_CSL_CONTROLSS_CTRL_EPWM_CLKSYNC                                  (0x00000010U)

/* EPWM_CLKSYNC */
#define MCU_CSL_CONTROLSS_CTRL_EPWM_CLKSYNC_BIT_MASK                         (0xFFFFFFFFU)

#define MCU_CSL_TOP_CTRL_LOCK0_KICK0                                          (0x00001008U)
#define MCU_CSL_TOP_CTRL_LOCK0_KICK1                                          (0x0000100CU)
#define MCU_CSL_TOP_RCM_LOCK0_KICK0                                           (0x00001008U)
#define MCU_CSL_TOP_RCM_LOCK0_KICK1                                           (0x0000100CU)
#define MCU_CSL_MSS_CTRL_LOCK0_KICK0                                          (0x00001008U)
#define MCU_CSL_MSS_CTRL_LOCK0_KICK1                                          (0x0000100CU)

/* define the unlock and lock values for MSS_CTRL, TOP_CTRL, MSS_RCM, TOP_RCM*/
#define MCU_TEST_KICK_LOCK_VAL                           (0x00000000U)
#define MCU_TEST_KICK0_UNLOCK_VAL                        (0x01234567U)
#define MCU_TEST_KICK1_UNLOCK_VAL                        (0x0FEDCBA8U)

/* EPWM_CHANNELS */
#define MCU_PWM_CHANNEL_0   0U
#define MCU_PWM_CHANNEL_1   1U
#define MCU_PWM_CHANNEL_2   2U
#define MCU_PWM_CHANNEL_3   3U
#define MCU_PWM_CHANNEL_4   4U
#define MCU_PWM_CHANNEL_5   5U
#define MCU_PWM_CHANNEL_6   6U
#define MCU_PWM_CHANNEL_7   7U
#define MCU_PWM_CHANNEL_8   8U
#define MCU_PWM_CHANNEL_9   9U
#define MCU_PWM_CHANNEL_10 10U
#define MCU_PWM_CHANNEL_11 11U
#define MCU_PWM_CHANNEL_12 12U
#define MCU_PWM_CHANNEL_13 13U
#define MCU_PWM_CHANNEL_14 14U
#define MCU_PWM_CHANNEL_15 15U
#define MCU_PWM_CHANNEL_16 16U
#define MCU_PWM_CHANNEL_17 17U
#define MCU_PWM_CHANNEL_18 18U
#define MCU_PWM_CHANNEL_19 19U
#define MCU_PWM_CHANNEL_20 20U
#define MCU_PWM_CHANNEL_21 21U
#define MCU_PWM_CHANNEL_22 22U
#define MCU_PWM_CHANNEL_23 23U
#define MCU_PWM_CHANNEL_24 24U
#define MCU_PWM_CHANNEL_25 25U
#define MCU_PWM_CHANNEL_26 26U
#define MCU_PWM_CHANNEL_27 27U
#define MCU_PWM_CHANNEL_28 28U
#define MCU_PWM_CHANNEL_29 29U
#define MCU_PWM_CHANNEL_30 30U
#define MCU_PWM_CHANNEL_31 31U

/* EPWM_GROUPS */
#define MCU_PWM_CONTROLSS_G0   0U
#define MCU_PWM_CONTROLSS_G1   1U
#define MCU_PWM_CONTROLSS_G2   2U
#define MCU_PWM_CONTROLSS_G3   3U

/* ADC_GROUPS */
#define MCU_ADC_HWUNIT_0   0U
#define MCU_ADC_HWUNIT_1   1U
#define MCU_ADC_HWUNIT_2   2U
#define MCU_ADC_HWUNIT_3   3U
#define MCU_ADC_HWUNIT_4   4U

/* ADC BUFFER CONTROL */
#define MCU_CSL_TOP_CTRL_ADC_REFBUF0_CTRL                                     (0x00000C00U)
#define MCU_CSL_TOP_CTRL_ADC_REFBUF1_CTRL                                     (0x00000C04U)

#define MCU_CSL_TOP_CTRL_ADC_REF_COMP_CTRL                                    (0x00000C08U)

void Mcu_IntXbar(void);
void Mcu_InputXbar(void);
void Mcu_GpioXbarConfig(void);

/*********************************************************************************************************************
 *  Exported Object Declarations
 *********************************************************************************************************************/
[!LOOP "as:modconf('Mcu')[1]/McuModuleConfiguration/."!]
/** \brief MCU Configuration struct declaration */
extern const struct Mcu_ConfigType_s Mcu_Config;
[!ENDLOOP!]

#endif /* DOXYGEN_SHOULD_SKIP_THIS */

#ifdef __cplusplus
}
#endif

/**
* @}
*/

#endif /* #ifndef MCU_CFG_H */
/**********************************************************************************************************************
 *  End of File: Mcu_Cfg.h
 *********************************************************************************************************************/
