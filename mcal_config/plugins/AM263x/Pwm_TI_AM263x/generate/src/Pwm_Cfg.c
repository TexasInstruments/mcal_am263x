[!IF "(as:modconf('Pwm')[1]/IMPLEMENTATION_CONFIG_VARIANT = 'VariantPreCompile') or (as:modconf('Pwm')[1]/IMPLEMENTATION_CONFIG_VARIANT = 'VariantPostBuild')"!]
/* ======================================================================
 *   Copyright (C) 2022-2023 Texas Instruments Incorporated
 *
 *   All rights reserved. Property of Texas Instruments Incorporated.
 *   Restricted rights to use, duplicate or disclose this code are
 *   granted through contract.
 *
 *   The program may not be used without the written permission
 *   of Texas Instruments Incorporated or against the terms and conditions
 *   stipulated in the agreement under which this program has been
 *   supplied.
 * ==================================================================== */

/**

 *  -------------------------------------------------------------------------------------------------------------------
 *  FILE DESCRIPTION
 *  -------------------------------------------------------------------------------------------------------------------
 *         File:  Pwm_Cfg.c
 *      Project:  TI Sitara MCU AM263x PwmDriver
 *       Module:  DriverPwm
 *    Generator:  EB Tresos
 *
 *  Description:  This component provides services for initialization and control of the microcontroller internal
 *                PWM unit (pulse width modulation). The PWM module generates pulses with variable pulse width.
 *                It allows the selection of the duty cycle and the signal period time.
 *
 *********************************************************************************************************************/


/**********************************************************************************************************************
    Project: [!"$project"!]

    This file is generated by EB Tresos
    Do not modify this file, otherwise the software may behave in unexpected way.
 *********************************************************************************************************************/

#include "Std_Types.h"

#include "Pwm.h"
#ifdef __cplusplus

extern "C" {
#endif

[!AUTOSPACING!]

/* ---- Perform version checking  ----------------------------------------- */
 #if ((PWM_SW_MAJOR_VERSION != ([!"substring-before($moduleSoftwareVer,'.')"!]U))||(PWM_SW_MINOR_VERSION != ([!"substring-before(substring-after($moduleSoftwareVer,'.'),'.')"!]U)))
  #error "Version numbers of Pwm_PBcfg.c and Pwm_Cfg.h are inconsistent!"
#endif

#if ((PWM_CFG_MAJOR_VERSION != ([!"substring-before($moduleSoftwareVer,'.')"!]U))||(PWM_CFG_MINOR_VERSION != ([!"substring-before(substring-after($moduleSoftwareVer,'.'),'.')"!]U)))
  #error "Version numbers of Pwm_Cfg.c and Pwm_Cfg.h are inconsistent!"
#endif

/*Requirements : SWS_Pwm_60075*/
/*
*Design: MCAL-13123
*/
#define PWM_START_SEC_CONFIG_DATA
#include "Pwm_MemMap.h"

[!MACRO "GetAddress", "ChannelNumber", "ChannelNumber2", "HWNumber"!][!//
[!NOCODE!]    
    [!VAR "BaseAddr" = "BaseAddr + 1342177280"!]
    [!VAR "Channeloffset" = "Channeloffset + 4096"!]
    [!VAR "HWunitOffset" = "HWunitOffset + 262144"!]
    [!VAR "ChannelBase"  = "$Channeloffset*$ChannelNumber"!]  
       

    [!IF "($HWNumber = 'PWM_CONTROLSS_G0')"!]
    [!VAR "HWunitBase"   = "$HWunitOffset*0"!]
    [!ENDIF!]

    [!IF "($HWNumber = 'PWM_CONTROLSS_G1')"!]
    [!VAR "HWunitBase"   = "$HWunitOffset*1"!]
    [!ENDIF!]
    
    
    [!IF "($HWNumber = 'PWM_CONTROLSS_G2')"!]
    [!VAR "HWunitBase"   = "$HWunitOffset*2"!]
    [!ENDIF!]
    
    
    [!IF "($HWNumber = 'PWM_CONTROLSS_G3')"!]
    [!VAR "HWunitBase"   = "$HWunitOffset*3"!]
    [!ENDIF!]
    
    [!CODE!][!"num:inttohex($BaseAddr+$ChannelBase+$HWunitBase)"!][!ENDCODE!] 
[!ENDNOCODE!][!//
[!ENDMACRO!][!//

[!VAR "notifyFxnList" = "' '"!]
[!LOOP "as:modconf('Pwm')[1]/PwmChannelConfigSet/PwmChannel/*"!][!//
[!IF "not(node:empty(PwmNotification/*)) and not(text:match(PwmNotification/*,'NULL_PTR'))"!][!//
[!IF "not(node:containsValue(text:split($notifyFxnList),node:value(PwmNotification/*)))"!][!//
[!"concat('extern void ',PwmNotification/*,' (void);')"!]
[!VAR "notifyFxnList" = "concat($notifyFxnList,' ',PwmNotification/*)"!][!//
[!ENDIF!][!//
[!ENDIF!][!//
[!ENDLOOP!][!//

[!LOOP "as:modconf('Pwm')[1]/PwmChannelConfigSet"!]
[!VAR "NumChannels" = "num:i(count(as:modconf('Pwm')[1]/PwmChannelConfigSet/PwmChannel/*))"!]
[!ENDLOOP!]
[!AUTOSPACING!]
[!VAR "Index" = "0"!]
[!VAR "Index1" = "0"!]
[!VAR "Ticks" = "0"!]
/* Pwm Channel Configuration parameters */
[!LOOP "as:modconf('Pwm')[1]/PwmChannelConfigSet"!]
CONST(struct Pwm_ConfigType_PC_s, PWM_CONFIG_DATA)
    [!"@name"!]_PC =
{
    .chCfg =
    {
    [!LOOP "PwmChannel/*"!][!/*Channel Loop */!]
        [[!"num:i($Index1)"!]] =
        {
            .channelId = PwmConf_PwmChannel_[!"@name"!],
            .channelHwId = PWM_CHANNEL_[!"PwmHwUnit"!]_PWMCHANNEL[!"num:i(PwmHWChannelId)"!],
            .outputCh = (uint32)[!"PwmOutputChSelect"!], /*Output Channel Select*/
        }[!VAR "Index1" = "$Index1+1"!][!IF "not(node:islast())"!],[!ENDIF!][!CR!][!ENDLOOP!]
    },
};
[!VAR "Index" = "$Index+1"!][!ENDLOOP!][!/*End of PwmChannelConfigSet Loop*/!]

[!IF "(as:modconf('Pwm')[1]/IMPLEMENTATION_CONFIG_VARIANT = 'VariantPreCompile')"!]
[!VAR "Index" = "0"!]
[!VAR "Index1" = "0"!]
[!VAR "Ticks" = "0"!]
/* Pwm Channel Configuration parameters */
[!LOOP "as:modconf('Pwm')[1]/PwmChannelConfigSet"!]
CONST(struct Pwm_ConfigType_s, PWM_CONFIG_DATA)
     [!"@name"!] =
{
    .chCfg =
    {
    [!LOOP "PwmChannel/*"!][!/*Channel Loop */!]
        [[!"num:i($Index1)"!]] =
        {
            .baseaddr = [!CALL "GetAddress", "ChannelNumber" = "PwmHWChannelId", "HWNumber" = "PwmHwUnit"!]UL,
            .instanceClkHz = [!"PwmFunctionalClock"!]U,
            .dutyCycle = [!IF "PwmPeriodDefault = num:f('0')"!][!"num:i('0')"!][!ELSE!][!"num:inttohex(PwmDutycycleDefault)"!][!ENDIF!]U,/* Dutycycle */
            [!IF "PwmPeriodDefault != num:f('0')"!]
              [!VAR "Sys_ClkFreq" = "PwmFunctionalClock"!]
                  [!VAR "HsPrescaler" = "(num:i(PwmHSClkPrescaler) * 2)"!]
                  [!IF "$HsPrescaler = num:i('0') "!]
                    [!VAR "HsPrescalerVal" = "1"!]
                  [!ELSE!]
                    [!VAR "HsPrescalerVal" = "num:i($HsPrescaler)"!]
                  [!ENDIF!]
                  [!VAR "Prescalers" = " (bit:shl(1,num:i(PwmClkPrescaler)) * (num:i($HsPrescalerVal)))"!]
                  [!VAR "Ticks" = " (((num:i($Sys_ClkFreq) div num:i($Prescalers)) div (num:i(round(1 div num:f(PwmPeriodDefault))))) div 2)"!]
                  [!IF "(num:i($Ticks) > num:hextoint('0xffff'))"!][!ERROR "Configured Period is not possible or Invalid, please refer 'Configurable Interfaces' section in Pwm User guide for details!!"!][!ENDIF!]
                  [!IF "(num:f($Ticks) - floor(num:f($Ticks)))  > 0"!][!WARNING "Configured Period is not integer, please refer 'Configurable Interfaces' section in Pwm User guide for details"!][!ENDIF!]
               
            [!ENDIF!]
            .hwPeriod = [!IF "PwmPeriodDefault = num:f('0')"!][!"num:i('0')"!][!ELSE!][!"num:i($Ticks)"!][!ENDIF!]U, /* Number of HW Unit ticks value which sets initial period */
            .polarity = [!"PwmPolarity"!],/* Polarity */
            .idleState = [!"PwmIdleState"!],/* Idle State */
            .channelClass = [!"PwmChannelClass/*"!],
            [!IF "PwmChannelClass/* = 'PWM_FIXED_PERIOD_SHIFTED'"!][!ERROR "Configured Channel Class is not supported!!"!][!ENDIF!]
            [!IF "node:empty(PwmChannelClass/*) = 'true'"!][!ERROR "PwmChannelClass is not configured"!][!ENDIF!][!//
            .prescale = [!"PwmClkPrescaler"!], /* prescale */
            .hsPrescale = [!"PwmHSClkPrescaler"!], /*High Speed Clock Divider*/
            .enableHR = [!IF "PwmEnableHighRes = 'true'"!]TRUE[!ELSE!]FALSE[!ENDIF!], /*Enable High Resolution */
#if (PWM_NOTIFICATION_SUPPORTED == STD_ON)
            .notificationHandler = (Pwm_NotifyFuncType)[!IF "PwmNotification/* != ''"!] [!"PwmNotification/*"!][!ELSE!]  NULL_PTR [!ENDIF!], /*Notification Function*/
            [!IF "node:empty(PwmNotification/*) = 'true'"!][!ERROR "PwmNotification is not configured"!][!ENDIF!][!//
#endif
        }[!VAR "Index1" = "$Index1+1"!][!IF "not(node:islast())"!],[!ENDIF!][!CR!][!ENDLOOP!]
    }[!IF "not(node:islast())"!],[!ENDIF!][!CR!]
};
[!VAR "Index" = "$Index+1"!][!ENDLOOP!][!/*End of PwmChannelConfigSet Loop*/!]
[!ENDIF!][!//

#ifdef __cplusplus
}
#endif

/*</PWM_CONFIGURATION>*/
#define PWM_STOP_SEC_CONFIG_DATA
#include "Pwm_MemMap.h"

/**********************************************************************************************************************
 *  END OF FILE: Pwm_Cfg.c                                                                                          *
 *********************************************************************************************************************/
[!ELSE!]
/* The last generated configuration variant is not 
       POST-BUILD variant. Refer Pwm_Cfg.c */
[!ENDIF!]