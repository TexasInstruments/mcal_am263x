/*
*
* Copyright (c) 2022-2023 Texas Instruments Incorporated
*
* All rights reserved not granted herein.
*
* Limited License.
*
* Texas Instruments Incorporated grants a world-wide, royalty-free, non-exclusive
* license under copyrights and patents it now or hereafter owns or controls to make,
* have made, use, import, offer to sell and sell ("Utilize") this software subject to the
* terms herein.  With respect to the foregoing patent license, such license is granted
* solely to the extent that any such patent is necessary to Utilize the software alone.
* The patent license shall not apply to any combinations which include this software,
* other than combinations with devices manufactured by or for TI ("TI Devices").
* No hardware patent is licensed hereunder.
*
* Redistributions must preserve existing copyright notices and reproduce this license
* (including the above copyright notice and the disclaimer and (if applicable) source
* code license limitations below) in the documentation and/or other materials provided
* with the distribution
*
* Redistribution and use in binary form, without modification, are permitted provided
* that the following conditions are met:
*
* *       No reverse engineering, decompilation, or disassembly of this software is
* permitted with respect to any software provided in binary form.
*
* *       any redistribution and use are licensed by TI for use only with TI Devices.
*
* *       Nothing shall obligate TI to provide you with source code for the software
* licensed and provided to you in object code.
*
* If software source code is provided to you, modification and redistribution of the
* source code are permitted provided that the following conditions are met:
*
* *       any redistribution and use of the source code, including any resulting derivative
* works, are licensed by TI for use only with TI Devices.
*
* *       any redistribution and use of any object code compiled from the source code
* and any resulting derivative works, are licensed by TI for use only with TI Devices.
*
* Neither the name of Texas Instruments Incorporated nor the names of its suppliers
*
* may be used to endorse or promote products derived from this software without
* specific prior written permission.
*
* DISCLAIMER.
*
* THIS SOFTWARE IS PROVIDED BY TI AND TI'S LICENSORS "AS IS" AND ANY EXPRESS
* OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL TI AND TI'S LICENSORS BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
* BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
* OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
* OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
* OF THE POSSIBILITY OF SUCH DAMAGE.
*
*/

/**
 *  \file     Spi_Cfg.h
 *
 *  \brief    This file contains generated pre compile configuration file
 *            for SPI MCAL driver
 */

  /*****************************************************************************
    Project: Mcal_Demo_Cfg
    This file is generated by EB Tresos
    Do not modify this file, otherwise the software may behave in unexpected way.
 ******************************************************************************/



#ifndef SPI_CFG_H_
#define SPI_CFG_H_

/**
 * \addtogroup SPI Spi API GUIDE Header file
 * @{
 */

/* ========================================================================== */
/*                             Include Files                                  */
/* ========================================================================== */
#include "Os.h"
#include "Dem.h"
#include "Det.h"

#ifdef __cplusplus
extern "C" {
#endif

#ifndef DOXYGEN_SHOULD_SKIP_THIS

/**
*  \name Spi Driver Configuration SW Version Info
*
*  Defines for Spi Driver configuration version
*  @{
*/
/** \brief Spi configuration Major Version */
#define SPI_CFG_MAJOR_VERSION           (10U)
/** \brief Spi configuration Minor Version */
#define SPI_CFG_MINOR_VERSION           (2U)
/** \brief Spi configuration Patch Version */
#define SPI_CFG_PATCH_VERSION           (1U)
/* @} */

/**
*  \name SPI Build Variant.
*   Build variants.(i.e Pre Compile,Post Build or Link time)
* @{
*/

#define SPI_PRE_COMPILE_VARIANT       (STD_OFF)

#define SPI_VARIANT_POST_BUILD        (STD_ON)

#define SPI_LINK_TIME_VARIANT         (STD_OFF)
/* @} */

/** \brief SPI Config ID */
#define SPI_CFG_ID          (0x1U)



/**
 *  \name Pre-Compile Switches for API Services
 *  @{
 */

/** \brief Enable/disable SPI dev detect error */
#define SPI_DEV_ERROR_DETECT        (STD_ON)
/** \brief Enable/disable SPI job log */
#define SPI_JOB_LOG                 (STD_OFF)
/** \brief Concurrent sync transmit support - by defualt this is off */
#define SPI_SUPPORT_CONCURRENT_SYNC_TRANSMIT    (STD_OFF)
/** \brief Enable/disable SPI get version info API */
#define SPI_VERSION_INFO_API        (STD_ON)
/** \brief Enable/disable SPI HW Status API */
#define SPI_HW_STATUS_API           (STD_ON)
/** \brief Enable/disable SPI cancel API */
#define SPI_CANCEL_API              (STD_ON)
/** \brief Enable/disable SPI register read back API */
#define SPI_REGISTER_READBACK_API   (STD_OFF)
/** \brief Enable/disable SPI safety API */
#define SPI_SAFETY_API   (STD_OFF)
/**\brief LoopBack API Enable/Disable*/
#define SPI_SET_LOOPBACK_MODE_API      (STD_OFF)
/* @} */

/*
 *Design: MCAL-14218, MCAL-14217
 */
/** \brief Buffer mode - Internal or External or Both */
#define SPI_CHANNELBUFFERS          (SPI_IB_EB)

/** \brief Internal Buffer length in bytes - applicable only for SPI_IB */
#define SPI_IB_MAX_LENGTH           (64U)

/** \brief Maximum job log entries when logging is ON */
#define SPI_MAX_JOB_LOG             (100U)


/** \brief Maximum SPI DMA Enabled Hardware Unit */
#define SPI_MAX_HW_DMA_UNIT         (1U)

/** \brief Enable/disable SPI DMA Support */
#define SPI_DMA_ENABLE              (STD_ON)

 /*
 *Design: MCAL-14089, MCAL-14079, MCAL-14080, MCAL-14081, MCAL-14082, MCAL-14083, MCAL-14085,  MCAL-14086,  MCAL-14087, MCAL-14091, MCAL-14074, MCAL_14073, MCAL_14067, MCAL_14071, MCAL_14070, MCAL_14068, MCAL_14064, MCAL_14072, MCAL_14066, MCAL_14069
 */
/*
 * Scalability levels
 */
/** \brief Basic Synchronous functions */
#define SPI_LEVEL_0                     (0U)
/** \brief Basic Asynchronous functions */
#define SPI_LEVEL_1                     (1U)
/** \brief Synchronous and Asynchronous functions */
#define SPI_LEVEL_2                     (2U)
/*
 *Design: MCAL-14198, MCAL-14197
 */

/** \brief Scalability level */
#define SPI_SCALEABILITY            (SPI_LEVEL_2)
/* @} */
/**
 * \name Static memory allocation
 * All below macros are used for static memory allocation and can be changed to
 * match the usecase requirements.
 * @{
 */
/** \brief Maximum channels allowed per job */
#define SPI_MAX_CHANNELS_PER_JOB    (4U)

/** \brief Maximum jobs allowed per sequence */
#define SPI_MAX_JOBS_PER_SEQ        (4U)

/** \brief Maximum channels across all jobs/sequence/hwunit */
#define SPI_MAX_CHANNELS            (10U)

/** \brief Maximum jobs across all sequence/hwunit */
#define SPI_MAX_JOBS                (6U)

/** \brief Maximum sequence across all hwunit */
#define SPI_MAX_SEQ                 (3U)

/**
 *  \brief Maximum HW unit - This should match the sum for the below units ISR
 *  which are ON.
 */
#define SPI_MAX_HW_UNIT             (5U)

/**
 *  \brief Maximum external device cfg
 */
#define SPI_MAX_EXT_DEV             (5U)


/* @} */
/**
 * \name SPI ISR Types
 * All below macros are used for enabling the ISR for a particular hardware.
 * @{
 */

/** \brief Enable/disable SPI MCSPI unit ISR */
#define SPI_UNIT_MCSPI0_ACTIVE
#define SPI_UNIT_MCSPI1_ACTIVE
#define SPI_UNIT_MCSPI2_ACTIVE
#define SPI_UNIT_MCSPI3_ACTIVE
#define SPI_UNIT_MCSPI4_ACTIVE


/** \brief ISR type */
#define SPI_ISR_TYPE                (SPI_ISR_CAT1)
/* @} */
/** \brief OS counter ID - used for timeout in case of error */
#define SPI_OS_COUNTER_ID           ((CounterType)OsCounter_0)

/**
 *  \brief SPI timeout - used in McSPI IP reset
 *   Each tick is 31.25us (for 32K Counter). Wait for 100ms which comes to
 *   below value
 */
#define SPI_TIMEOUT_DURATION        (64000U)

/**
 * \name SPI Symbolic Name
 * @{
 */


/** \brief Symbolic Name Channel Id  - 0 SpiChannel_0 */
#define SpiConf_SpiChannel_SpiChannel_0   0
/** \brief Symbolic Name Channel Id  - 1 SpiChannel_1 */
#define SpiConf_SpiChannel_SpiChannel_1   1
/** \brief Symbolic Name Channel Id  - 2 SpiChannel_2 */
#define SpiConf_SpiChannel_SpiChannel_2   2
/** \brief Symbolic Name Channel Id  - 3 SpiChannel_3 */
#define SpiConf_SpiChannel_SpiChannel_3   3
/** \brief Symbolic Name Channel Id  - 4 SpiChannel_4 */
#define SpiConf_SpiChannel_SpiChannel_4   4
/** \brief Symbolic Name Channel Id  - 5 SpiChannel_5 */
#define SpiConf_SpiChannel_SpiChannel_5   5
/** \brief Symbolic Name Channel Id  - 6 SpiChannel_6 */
#define SpiConf_SpiChannel_SpiChannel_6   6
/** \brief Symbolic Name Channel Id  - 7 SpiChannel_7 */
#define SpiConf_SpiChannel_SpiChannel_7   7
/** \brief Symbolic Name Channel Id  - 8 SpiChannel_8 */
#define SpiConf_SpiChannel_SpiChannel_8   8
/** \brief Symbolic Name Channel Id  - 9 SpiChannel_9 */
#define SpiConf_SpiChannel_SpiChannel_9   9

/** \brief Symbolic Name Chip Select  - 0 */
#define SpiConf_SpiExternalDevice_CS0 (SPI_CS0)


/** \brief Symbolic Name Job Id - 0 SpiJob_0 */
#define SpiConf_SpiJob_SpiJob_0            0


/** \brief Symbolic Name Chip Select  - 1 */
#define SpiConf_SpiExternalDevice_CS1 (SPI_CS0)


/** \brief Symbolic Name Job Id - 1 SpiJob_1 */
#define SpiConf_SpiJob_SpiJob_1            1


/** \brief Symbolic Name Chip Select  - 2 */
#define SpiConf_SpiExternalDevice_CS2 (SPI_CS0)


/** \brief Symbolic Name Job Id - 2 SpiJob_2 */
#define SpiConf_SpiJob_SpiJob_2            2


/** \brief Symbolic Name Chip Select  - 3 */
#define SpiConf_SpiExternalDevice_CS3 (SPI_CS0)


/** \brief Symbolic Name Job Id - 3 SpiJob_3 */
#define SpiConf_SpiJob_SpiJob_3            3

/** \brief Symbolic Name Sequence Id - 0 SpiSequence_0 */
#define SpiConf_SpiSequence_SpiSequence_0  0
/** \brief Symbolic Name Sequence Id - 1 SpiSequence_1 */
#define SpiConf_SpiSequence_SpiSequence_1  1
/** \brief Symbolic Name Sequence Id - 2 SpiSequence_2 */
#define SpiConf_SpiSequence_SpiSequence_2  2


#define SpiConf_SpiExternalDevice_SpiExternalDevice_0_CS0 SCS0
#define SpiConf_SpiExternalDevice_SpiExternalDevice_1_CS0 SCS0
#define SpiConf_SpiExternalDevice_SpiExternalDevice_2_CS0 SCS0
#define SpiConf_SpiExternalDevice_SpiExternalDevice_3_CS0 SCS0
#define SpiConf_SpiExternalDevice_SpiExternalDevice_4_CS1 SCS1
/** \brief Symbolic Name HW Unit - 0 */
#define SpiConf_SpiExternalDevice_SpiExternalDevice_0_HwUnitId0 CSIB0
/** \brief Symbolic Name HW Unit - 0 */
#define SpiConf_SpiExternalDevice_SpiExternalDevice_1_HwUnitId1 CSIB1
/** \brief Symbolic Name HW Unit - 0 */
#define SpiConf_SpiExternalDevice_SpiExternalDevice_2_HwUnitId2 CSIB2
/** \brief Symbolic Name HW Unit - 0 */
#define SpiConf_SpiExternalDevice_SpiExternalDevice_3_HwUnitId3 CSIB3
/** \brief Symbolic Name HW Unit - 0 */
#define SpiConf_SpiExternalDevice_SpiExternalDevice_4_HwUnitId4 CSIB4

/* @} */

/**
 *  \name SPI DEM Error codes to report
 *
 *  Pre-compile switches for enabling/disabling DEM events
 *  @{
 */

#ifndef SPI_E_HARDWARE_ERROR
 /*
 *Design: MCAL-14077, MCAL-14075, MCAL-14076
 */
/** \brief Hardware failed */
#define SPI_E_HARDWARE_ERROR        (DemConf_DemEventParameter_SPI_E_HARDWARE_ERROR)
#endif



/* Requirements : SWS_Spi_00376,SWS_Spi_00355,SWS_Spi_00164,MCAL-1363,
* MCAL-1364, MCAL-1365 */
/*
 *
 *Design: MCAL-14295, MCAL-14313, MCAL-14340
 */
/** \brief Type of application data buffer elements */
typedef uint8 Spi_DataBufferType;
/** \brief Type of Register pointer */
typedef uint32 Spi_RegisterPtrType;

/* Requirements : SWS_Spi_00377,SWS_Spi_00165,MCAL-1366, MCAL-1367 */
/*
 *
 *Design: MCAL-14293, MCAL-14339
 */
/**
 *  \brief Type for defining the number of data elements of the type
 *  Spi_DataBufferType to send and / or receive by Channel
 */
typedef uint16 Spi_NumberOfDataType;

/* Requirements : SWS_Spi_00356,SWS_Spi_00166,MCAL-1368, MCAL-1369, MCAL-1370 */
/*
 *
 *Design: MCAL-14292, MCAL-14311, MCAL-14337
 */
/** \brief Specifies the identification (ID) for a Channel */
typedef uint8 Spi_ChannelType;

/* Requirements :SWS_Spi_00379,SWS_Spi_00357,SWS_Spi_00167, MCAL-1371,
*  MCAL-1372, MCAL-1373 */
/*
 *
 *Design: MCAL-14290, MCAL-14309, MCAL-14336
 */
/** \brief Specifies the identification (ID) for a Job */
typedef uint16 Spi_JobType;

/* Requirements : SWS_Spi_00380,SWS_Spi_00358,SWS_Spi_00168,MCAL-1374,
* MCAL-1375, MCAL-1376 */
/*
 *
 *Design: MCAL-14289, MCAL-14308, MCAL-14334
 */
/** \brief Specifies the identification (ID) for a sequence of jobs */
typedef uint8 Spi_SequenceType;

/* Requirements : SWS_Spi_00381,SWS_Spi_00359,SWS_Spi_00169,MCAL-1377,
*  MCAL-1378, MCAL-1379 */
/*
 *
 *Design: MCAL-14288, MCAL-14306, MCAL-14333
 */
/**
 *  \brief Specifies the identification (ID) for a SPI Hardware micro
 *   controller  peripheral (unit)
 */
typedef uint8 Spi_HWUnitType;

/**
 *  SPI HW unit Info
 */

/** \brief MCSPI0 instance */
#define SPI_UNIT_MCSPI0                     ((Spi_HWUnitType) CSIB0)
/** \brief MCSPI1 instance */
#define SPI_UNIT_MCSPI1                     ((Spi_HWUnitType) CSIB1)
/** \brief MCSPI2 instance */
#define SPI_UNIT_MCSPI2                     ((Spi_HWUnitType) CSIB2)
/** \brief MCSPI3 instance */
#define SPI_UNIT_MCSPI3                     ((Spi_HWUnitType) CSIB3)
/** \brief MCSPI4 instance */
#define SPI_UNIT_MCSPI4                     ((Spi_HWUnitType) CSIB4)

/**
 * \brief Spi Max Timeout for Transmission
 *
 */
#define SPI_MAX_TIMEOUT_DURATION         (20000U)


/**
 *  \brief Total HW units - used for array allocation. This should be +1 of the
 *  max unit number
 */
#define SPI_HW_UNIT_CNT                 (5U)

extern const uint32 Spi_HwUnitBaseAddr[SPI_HW_UNIT_CNT];


/** \brief SPI Configuration struct declaration */
extern const struct Spi_ConfigType_s Spi_Config;

#endif /* DOXYGEN_SHOULD_SKIP_THIS */

/* ========================================================================== */
/*                        Typedefs,Enums and structures                                  */
/* ========================================================================== */

/** \brief Typedef for job end notification function pointer */
/* Requirements : SWS_Spi_00192 */
typedef P2FUNC (void, SPI_APPL_CODE, Spi_JobEndNotifyType)(void);

/** \brief Typedef for sequence end notification function pointer */
/* Requirements : SWS_Spi_00073,SWS_Spi_00193,SWS_Spi_00341,SWS_Spi_00193 */
typedef P2FUNC (void, SPI_APPL_CODE, Spi_SeqEndNotifyType)(void);

/**
 *  \brief This type defines a range of specific status for SPI
 *   Handler/Driver
 */

 typedef enum
{
	/** \brief  MCSPI0 instance */
    CSIB0 = 0U,
    /** \brief  MCSPI1 instance */
    CSIB1,
    /** \brief  MCSPI2 instance */
    CSIB2,
    /** \brief MCSPI3 instance */
    CSIB3,
    /** \brief MCSPI4 instance */
    CSIB4

} Spi_HwUnitType;

/*
 *
 *Design: MCAL-14299, MCAL-14346, MCAL-14328, MCAL-14327, MCAL-14351, MCAL-14323, MCAL-14322, MCAL-14321, MCAL-14320, MCAL-14319
 */
/**
 *  \brief This type defines the status of SPI Handler/Driver
 *  Handler/Driver
 */
typedef enum
{
	/** \brief The SPI Handler/Driver is not initialized or not usable */
    SPI_UNINIT = 0U,
    /** \brief The SPI Handler/Driver is not currently transmitting
	 *   any Job */
    SPI_IDLE = 1U,
    /** \brief The SPI Handler/Driver is performing a SPI Job (transmit) */
    SPI_BUSY = 2U
} Spi_StatusType;

/**
 *  \brief This type defines a range of specific Jobs status for SPI
 *  Handler/Driver
 */
/* Requirements :SWS_Spi_00015,SWS_Spi_00374,SWS_Spi_00062,SWS_Spi_00261,
* SWS_Spi_00012, SWS_Spi_00384,SWS_Spi_00119, MCAL-1350, MCAL-1351, MCAL-1353 */
/*
 *
 *Design: MCAL-14298, MCAL-14344, MCAL-14326, MCAL-14350, MCAL-14318
 */
typedef enum
{
	/** \brief The last transmission of the Job has been finished
	*   successfully */
    SPI_JOB_OK = 0U,
    /** \brief The SPI Handler/Driver is performing a SPI Job.
     *   The meaning of this status is equal to SPI_BUSY */
    SPI_JOB_PENDING = 1U,
    /** \brief The last transmission of the Job has failed */
    SPI_JOB_FAILED = 2U,
    /** \brief An asynchronous transmit Job has been accepted, while
     * actual transmission for this Job has not started yet */
    SPI_JOB_QUEUED = 3U
} Spi_JobResultType;

/**
 *  \brief This type defines a range of specific Sequences status for
 *  SPI Handler/Driver
 */
 /*
 *
 *Design: MCAL-14297, MCAL-14317, MCAL-14330, MCAL-14348, MCAL-14316, MCAL-14315, MCAL-14314, MCAL-14347
 */
/* Requirements :SWS_Spi_00353,SWS_Spi_00354,SWS_Spi_00017,SWS_Spi_00352,
* SWS_Spi_00351,SWS_Spi_00019,SWS_Spi_00251,SWS_Spi_00375,SWS_Spi_00120 ,
* SWS_Spi_00120, MCAL-1355, MCAL-1357, MCAL-1359 */
typedef enum
{
	/** \brief The last transmission of the Sequence has been finished
	 *   successfully */
    SPI_SEQ_OK = 0U,
    /** \brief The SPI Handler/Driver is performing a SPI Sequence.
	 * The meaning of this status is equal to SPI_BUSY */
    SPI_SEQ_PENDING = 1U,
    /** \brief The last transmission of the Sequence has failed */
    SPI_SEQ_FAILED = 2U,
    /** \brief The last transmission of the Sequence has been canceled by
	 * user */
    SPI_SEQ_CANCELLED = 3U
} Spi_SeqResultType;

/**
 *  \brief This type defines a range of specific HW unit status for
 *  SPI Handler/Driver
 */
typedef enum
{
	/** \brief HW unit result is ok */
    SPI_HW_UNIT_OK = 0U,
    /** \brief HW unit result is pending */
    SPI_HW_UNIT_PENDING = 1U,
    /** \brief HW unit result is failed */
    SPI_HW_UNIT_FAILED = 2U
} Spi_HwUnitResultType;

/**
 *  \brief Specifies the asynchronous mechanism mode for SPI busses
 *   handled asynchronously in LEVEL 2
 */
/* Requirements : SWS_Spi_00382,SWS_Spi_00360,SWS_Spi_00170,SWS_Spi_00150,
* SWS_Spi_00361,SWS_Spi_00362,MCAL-1380, MCAL-1381, MCAL-1382, MCAL-1383,
 *                MCAL-1384, MCAL-1385, MCAL-1300 */
 /*
 *
 *Design: MCAL-14286, MCAL-14303, MCAL-14332,MCAL-22662, MCAL-14302, MCAL-14301
 */
typedef enum
{
	/** \brief The asynchronous mechanism is ensured by polling, so
	* interrupts related to SPI busses handled asynchronously
	* are disabled */
    SPI_POLLING_MODE = 0U,
    /** \brief The asynchronous mechanism is ensured by
     * interrupt, so interrupts related to SPI busses
     * handled asynchronously are enabled */
    SPI_INTERRUPT_MODE = 1U
} Spi_AsyncModeType;

/**
 *  \brief Word transfer order - MSB first or LSB first
 */
typedef enum
{
	/** \brief MSB is transferred first. Only this is supported */
    SPI_MSB = 0U,
    /** \brief LSB is transferred first. This is not supported */
    SPI_LSB = 1U
} Spi_TransferType;

/**
 *  \brief Type for SPI Chip Select Polarity and Clock Idle Level.
 */
typedef enum
{
	/** \brief Low clock or chip select */
    SPI_LOW = STD_LOW,
    /** \brief High clock or chip select */
    SPI_HIGH
} Spi_LevelType;

/**
 *  \brief SPI Chip Select Pin.
 */
typedef enum
{
	/** \brief Chip select 0 */
    SPI_CS0 = 0U,
    /** \brief Chip select 1 */
    SPI_CS1,
    /** \brief Chip select 2 */
    SPI_CS2,
    /** \brief Chip select 3 */
    SPI_CS3
} Spi_CsPinType;

/**
 *  \brief SPI Clock Mode - sets the clock polarity and phase.
 *   Note: These values are a direct register mapping.
 *   So don't change value.
 */
typedef enum
{
	/** \brief SPI Clock Phase = 0 (rising edge latch),
	 *                                   Polarity = 0 (Active HIGH) */
    SPI_CLK_MODE_0 = 0x00U,
     /** \brief SPI Clock Phase = 1 (falling edge latch),
	 *                                   Polarity = 0 (Active HIGH) */
    SPI_CLK_MODE_1 = 0x01U,
    /** \brief SPI Clock Phase = 0 (rising edge latch),
	 *                                    Polarity = 1 (Active LOW) */
    SPI_CLK_MODE_2 = 0x02U,
    /** \brief SPI Clock Phase = 1 (falling edge latch),
	 *                                    Polarity = 1 (Active LOW) */
    SPI_CLK_MODE_3 = 0x03U,
} Spi_ClkMode;

/**
 *  \brief SPI TX/RX Mode.
 *
 * Note:
 *1. These values are a direct register mapping. So don't change value
 *2. RX only mode doesn't make sense in master mode because to receive
 *   data the master has to generate clock, which means it should
 *   transmit. Hence this mode is not supported. The user can
 *   alternatively set the TX buffer pointer to NULL and set the
 *   default TX value (defaultTxData) to make TX data line at the
 *   desired level.
 */
typedef enum
{
	/** \brief Both TX and RX are enabled */
    SPI_TX_RX_MODE_BOTH = 0x00U,
    /** \brief Only TX is enabled */
    SPI_TX_RX_MODE_TX_ONLY = 0x02U,
} Spi_TxRxMode;

/**
 *  \brief SPI Job Priority.
 */
/* Requirements : MCAL-1277 */
 /*
 *Design: MCAL-14229, MCAL-14230, MCAL-14231,
 */
typedef enum
{
	/** \brief Job priority 0 - low */
    SPI_JOB_PRIORITY_0 = 0U,
    /** \brief Job priority 1*/
    SPI_JOB_PRIORITY_1,
    /** \brief Job priority 2 */
    SPI_JOB_PRIORITY_2,
    /** \brief Job priority 3 - High */
    SPI_JOB_PRIORITY_3
} Spi_JobPriorityType;

/**
 *  \brief SPI Chip Select Mode.
 */
typedef enum
{
	/** \brief Chip select mode - single. Active only when transfer is on.*/
    SPI_SINGLE = 0U,
    /** \brief Chip select mode - continuous. Active throughout.*/
    SPI_CONTINUOUS = 1U
} Spi_CsModeType;

/**
 *  \brief Spi_DataDelayType defines the number of interface clock
 *  cycles between CS toggling and first or last edge of MCSPI clock.
 */
typedef enum
{
	/** \brief 0.5 clock cycles delay */
    SPI_DATADELAY_0 = 0U,
    /** \brief 1.5 clock cycles delay */
    SPI_DATADELAY_1 = 1U,
    /** \brief 2.5 clock cycles delay */
    SPI_DATADELAY_2 = 2U,
    /** \brief 3.5 clock cycles delay */
    SPI_DATADELAY_3 = 3U,
} Spi_DataDelayType;

/**
 *  \brief Spi_DataLineReceiveType defines the lines selected for
 * reception
 */
typedef enum
{
	/** \brief Data line 0 (SPIDAT[0]) selected for reception */
    DATA_LINE_0_RECEPTION = 0U,
    /** \brief Data line 1 (SPIDAT[1]) selected for reception */
    DATA_LINE_1_RECEPTION = 1U,
} Spi_DataLineReceiveType;

/**
 *  \brief Spi_DataLineTransmitType defines the lines selected for
 * transmission
 */
typedef enum
{
	/** \brief No transmission on data lines */
    DATA_LINE_NO_TRANSMISSION = 0x3U,
    /** \brief Data line 0 (SPIDAT[0]) selected for transmission */
    DATA_LINE_0_TRANSMISSION = 0x2U,
    /** \brief Data line 1 (SPIDAT[1]) selected for transmission */
    DATA_LINE_1_TRANSMISSION = 0x1U,
    /** \brief Data line 0 and 1 (SPIDAT[0] & SPIDAT[1]) selected for
	* transmission */
    DATA_LINE_BOTH_TRANSMISSION = 0x0U,
} Spi_DataLineTransmitType;

/**
 * \brief Irq status and std return type
 */
typedef enum
{
	/** \brief No event ocuurs in Overflow/Under flow */
    SPI_NO_EVENT = 0U,
    /** \brief Event occurs in Overflow/Under flow */
    SPI_EVENT_PENDING = 1U,
    /** \brief The status reading fails */
    SPI_STATUS_READ_FAIL = 2U,
} Mcspi_IrqStatusType;

/**
 *  \brief SPI Channel configuration structure.
 */
/*
 * Requirements : MCAL-1256, MCAL-1257, MCAL-1264, MCAL-1265,
 *                MCAL-1336
 */
typedef struct
{
	/** \brief Channel ID */
	Spi_ChannelType       channelId;
    /** \brief Buffer Type IB/EB */
    uint8                 channelBufType;
    /** \brief Width of clock frame in bits.
     *   In case of McSPI, valid values are from 1 to 32 bits. */
    uint8                 dataWidth;
    /** \brief Default transmit value when TX buffer is NULL_PTR */
    uint32                defaultTxData;
    /** \brief Max data length for external or internal buffer in SPI words.
     *   In case of internal buffers, this represents the number of
	 *    words to  copy from application buffer to internal buffer
	 *	 in case of Spi_WriteIB() API or from internal buffer to
	 *	 application buffer in case of Spi_ReadIB().
     *   The value of this should be less than or equal to the SPI
     *   configuration SPI_IB_MAX_LENGTH as this macro is is used for
 	 *   buffer allocation.
      */
    Spi_NumberOfDataType  maxBufLength;
    /** \brief Start with MSB or LSB.
     *   Only MSB is supported.  */
    Spi_TransferType      transferType;
} Spi_ChannelConfigType;

/**
 * \brief SPI Job configuration structure specific to McSPI peripheral
 */
typedef struct
{
	/** \brief Chip select functionality on/off */
    uint16            csEnable;
    /** \brief Select single or continuous mode
     *   Note: Applicable only for McSPI; */
    Spi_CsModeType    csMode;
    /** \brief Chip select pin polarity high or low */
    Spi_LevelType     csPolarity;
    /** \brief CS idle time (Timing between clock and chip select) if single
 	 * mode is chosen. Values in case of McSPI
     *                  McSPI
     *   0x00   -   0.5 clock cycles
     *   0x01   -   1.5 clock cycles
     *   0x02   -   2.5 clock cycles
     *   0x03   -   3.5 clock cycles */
    Spi_DataDelayType csIdleTime;
    /** \brief Clock divider. This is used to derive the required baudrate
	 *   from the McSPI functional clock. This value should be 1 less
     *   than the actual divider value. So a value of 0 means the
	 *   divider is 1.
     *  Maximum allowed value of divider is
	 *  4095(12 bit register field)*/
    uint32            clkDivider;
    /** \brief Mode 0 = {0=CPOL,0=CPHA}; Mode 1={0,1}; Mode 2={1,0}
	 *   Mode 3={1,1} */
    Spi_ClkMode       clkMode;
    /** \brief TX and RX mode */
    Spi_TxRxMode      txRxMode;
    /** \brief Start bit D/CX added before SPI transfer. Polarity is defined
	 *   by start bit level (below). */
    uint16            startBitEnable;
    /** \brief Start-bit polarity used when startBitEnable is TRUE. */
    Spi_LevelType     startBitLevel;
    /** \brief Defines the data lines selected for reception. */
    Spi_DataLineReceiveType     receptionLineEnable;
    /** \brief Defines the data lines selected for transmission. */
    Spi_DataLineTransmitType    transmissionLineEnable;
} Spi_McspiExternalDeviceConfigType;

/**
 *  \brief SPI external device specific configuration structure .
 */
typedef struct
{
	/** \brief MCSPI HW specific external device config. Should be populated
	 *   only if hwUnitId is MCSPI */
    Spi_McspiExternalDeviceConfigType mcspi;
} Spi_ExternalDeviceConfigType;

/**
 *  \brief SPI Job configuration structure.
 */
/* Requirements :SWS_Spi_00340,SWS_Spi_00071,SWS_Spi_00192,SWS_Spi_00048,
 * SWS_Spi_00044, SWS_Spi_00075,MCAL-1231, MCAL-1244
 *                MCAL-1248, MCAL-1249, MCAL-1276, MCAL-1337,
 *                MCAL-1339
 */
typedef struct
{
	/** \brief Job priority */
    Spi_JobPriorityType  jobPriority;
    /** \brief HWUnit associated with this job */
    Spi_HWUnitType       hwUnitId;
    /** \brief Job end notification callback fxn pointer */
    Spi_JobEndNotifyType   Spi_JobEndNotification;
    /** \brief Number of channels for this job.
     *   Should not be more than SPI_MAX_CHANNELS_PER_JOB */
    uint32               channelPerJob;
    /** \brief Channel index list */
    Spi_ChannelType      channelList[SPI_MAX_CHANNELS_PER_JOB];
    /** \brief Job ID */
	 uint8                jobId;
    /** \brief Chip select pin to use */
	 Spi_CsPinType        csPin;
    /** \brief index into SpiConfig.extDevCfg[] indicating the devCfg associated
     *   with the job */
	 uint8                externalDeviceCfgId;
} Spi_JobConfigType;

/**
 *  \brief SPI Sequence configuration structure.
 */
/* Requirements : SWS_Spi_00044,SWS_Spi_00048,SWS_Spi_00264,SWS_Spi_00265,
* MCAL-1251, MCAL-1338, MCAL-1286  */
typedef struct
{
	/** \brief Sequence ID */
	Spi_SequenceType     seqId;
    /** \brief Sequence interruptible or not (TRUE/FALSE) */
    uint8                seqInterruptible;
    /** \brief Sequence end notification callback fxn pointer */
    Spi_SeqEndNotifyType Spi_SequenceEndNotification;
    /** \brief Number of jobs for this sequence.
     *   Should not be more than SPI_MAX_JOBS_PER_SEQ */
    uint32               jobPerSeq;
    /** \brief Job index list */
    Spi_JobType          jobList[SPI_MAX_JOBS_PER_SEQ];
} Spi_SeqConfigType;

/**
 *  \brief SPI Hardware unit configuration structure.
 */
typedef struct
{
	/** \brief SPI HW unit to use */
    Spi_HWUnitType hwUnitId;
    /** \brief Enable SPI DMA Support per instance */
    boolean        enableDmaMode;
    /** \brief DMA TX Handler ID from CDD DMA configuration for SPI instance */
    uint32         dmaTxHandlerID;
    /** \brief DMA RX Handler ID from CDD DMA configuration for SPI instance */
    uint32         dmaRxHandlerID;
} Spi_HwUnitConfigType;

/**
 *  \brief SPI config structure
 */
/*
 * Requirements : SWS_Spi_00372,SWS_Spi_00344,SWS_Spi_00008,SWS_Spi_00063,
 * SWS_Spi_00064,MCAL-1333, MCAL-1334, MCAL-1335, MCAL-1502,
 *                MCAL-1503
 */
 /*
 *
 *Design: MCAL-14300, MCAL-14324, MCAL-14354, MCAL-14342, MCAL-14353, MCAL-14341, MCAL-14352
 */
typedef struct Spi_ConfigType_s
{
	/** \brief Maximum number of channels.
     *   Should not be more than SPI_MAX_CHANNELS */
    uint8                        maxChannels;
    /** \brief Maximum number of jobs
     *   Should not be more than SPI_MAX_JOBS */
    uint8                        maxJobs;
    /** \brief Maximum number of sequences
     *   Should not be more than SPI_MAX_SEQ */
    uint8                        maxSeq;
    /** \brief Maximum number of HW unit
     *   Should not be more than SPI_MAX_HW_UNIT */
    uint8                        maxHwUnit;
    /** \brief Maximum number of external device configurations
     *   Should not be more than SPI_MAX_EXT_DEV */
    uint8                        maxExtDevCfg;
    /** \brief Channel configurations */
    Spi_ChannelConfigType        channelCfg[SPI_MAX_CHANNELS];
    /** \brief Job configurations */
    Spi_JobConfigType            jobCfg[SPI_MAX_JOBS];
    /** \brief Sequence configurations */
    Spi_SeqConfigType            seqCfg[SPI_MAX_SEQ];
    /** \brief HW Unit configurations */
    Spi_HwUnitConfigType         hwUnitCfg[SPI_MAX_HW_UNIT];
    /** \brief External HW device config */
    Spi_ExternalDeviceConfigType extDevCfg[SPI_MAX_EXT_DEV];
    /** \brief Maximum number of dlc's */
	uint8 Spi_MaxDlcs;
} Spi_ConfigType;

/**
 *  \brief SPI channel config structure parameters Pre-Compile only
 */
typedef struct Spi_ChannelConfigType_PC_s
{
	/** \brief Channel ID */
    Spi_ChannelType      channelId;
} Spi_ChannelConfigType_PC;

/* Requirements : MCAL-1245, MCAL-1246 */
/**
 *  \brief SPI job config structure parameters Pre-Compile only
 */
typedef struct Spi_JobConfigType_PC_s
{
	/** \brief Job ID */
    Spi_JobType          jobId;
    /** \brief Chip select pin to use */
    Spi_CsPinType        csPin;
    /** \brief index into SpiConfig.extDevCfg[] indicating the devCfg
	 *   associated with the job */
    uint8                externalDeviceCfgId;
} Spi_JobConfigType_PC;

/**
 *  \brief SPI sequence config structure parameters Pre-Compile only
 */
typedef struct Spi_SeqConfigType_PC_s
{
	/** \brief Sequence ID */
    Spi_SequenceType     seqId;
} Spi_SeqConfigType_PC;

#if (STD_ON == SPI_REGISTER_READBACK_API)
/**
 *  \brief SPI register readback structure
 *
 */
typedef struct
{
    /*
     * McSPI related registers
     */
	/** \brief IP revision identifier */
    uint32       mcspiHlRev;
    /** \brief Information about the IP module's hardware configuration */
    uint32       mcspiHlHwInfo;
    /** \brief Clock management configuration */
    uint32       mcspiHlSysConfig;
    /** \brief IP revision number */
    uint32       mcspiRev;
    /** \brief IP status information */
    uint32       mcspiSysStatus;
    /** \brief System config */
    uint32       mcspiSyst;
    /** \brief module ctrl register MCSPI_MODULCTRL */
    uint32       mcspiModulctrl;
    /** \brief sysconfig register MCSPI_SYSCONFIG */
    uint32       mcspiSysConfig;
    /** \brief module Channel config Register MCSPI_CHCONF_0 */
    uint32       mcspiCh0config;
	/** \brief module Channel config Register MCSPI_CHCONF_1 */
    uint32       mcspiCh1config;
	/** \brief module Channel config Register MCSPI_CHCONF_2 */
    uint32       mcspiCh2config;
	/** \brief module Channel config Register MCSPI_CHCONF_3 */
    uint32       mcspiCh3config;
    /** \brief Irqenable MCSPI_IRQENABLE */
    uint32 	     mcspiIrqenable;
} Spi_RegisterReadbackType;
#endif  /* #if (STD_ON == SPI_REGISTER_READBACK_API) */

#ifdef __cplusplus
}
#endif

/**
* @}
 */

#endif  /* #ifndef SPI_CFG_H_ */


