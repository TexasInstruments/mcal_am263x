/* ======================================================================
 *   Copyright (c) 2023-2024 Texas Instruments Incorporated
 *
 *   All rights reserved. Property of Texas Instruments Incorporated.
 *   Restricted rights to use, duplicate or disclose this code are
 *   granted through contract.
 *
 *   The program may not be used without the written permission
 *   of Texas Instruments Incorporated or against the terms and conditions
 *   stipulated in the agreement under which this program has been
 *   supplied.
 * ==================================================================== */

/**
 *  \file     Spi_Cfg.h
 *
 *  \brief    This file contains generated pre compile configuration file
 *            for SPI MCAL driver
 */

  /*********************************************************************************************************************
    Project: AM273
	Date   : 2024-02-12 19:17:58 
	
    This file is generated by EB Tresos 
    Do not modify this file, otherwise the software may behave in unexpected way.
    
 *********************************************************************************************************************/

/**
 *  \defgroup MCAL_SPI_CFG SPI Configuration
 *
 *  This files defines SPI MCAL configuration structures
 *  @{
 */

#ifndef SPI_CFG_H_
#define SPI_CFG_H_

/* ========================================================================== */
/*                             Include Files                                  */
/* ========================================================================== */

#include "Std_Types.h"
#include "SchM_Spi.h"
#include "Os.h"


#include "Det.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 *  \name Spi Driver Configuration SW Version Info
 *
 *  Defines for Spi Driver configuration version
 *  @{
 */
/** \brief Spi configuration Major Version */
#define SPI_CFG_MAJOR_VERSION           (10U)
/** \brief Spi configuration Minor Version */
#define SPI_CFG_MINOR_VERSION    (1U)
/** \brief Spi configuration Patch Version */
#define SPI_CFG_PATCH_VERSION           (0U)
/* @} */


/**
*  \name SPI Build Variant.
*   Build variants.(i.e Pre Compile,Post Build or Link time)
* @{
*/

#define SPI_PRE_COMPILE_VARIANT       (STD_OFF)

#define SPI_VARIANT_POST_BUILD        (STD_ON)

#define SPI_LINK_TIME_VARIANT         (STD_OFF)
/* @} */
/* ========================================================================== */
/*                           Macros & Typedefs                                */
/* ========================================================================== */
/** \brief SPI Config ID */
#define SPI_ID                      (0x1U)

#define SPI_DLC_MIBTXSIZE    128U
#define SPI_DLC_MIBRXSIZE    128U

/**
 *  \name Pre-Compile Switches for API Services
 *  @{
 */
  
/** \brief Enable/disable SPI dev detect error */
#define SPI_DEV_ERROR_DETECT        (STD_ON)
/** \brief Enable/disable SPI job log */
#define SPI_JOB_LOG                 (STD_OFF)
/** \brief Concurrent sync transmit support - by defualt this is off */
#define SPI_SUPPORT_CONCURRENT_SYNC_TRANSMIT    (STD_ON)
/** \brief Enable/disable SPI get version info API */
#define SPI_VERSION_INFO_API        (STD_ON)
/** \brief Enable/disable SPI HW Status API */
#define SPI_HW_STATUS_API           (STD_ON)
/** \brief Enable/disable SPI cancel API */
#define SPI_CANCEL_API              (STD_ON)
/** \brief Enable/disable SPI register read back API */
#define SPI_REGISTER_READBACK_API   (STD_ON)
/** \brief Enable/disable SPI safety API */
#define SPI_SAFETY_API                 (STD_OFF)
/**\brief LoopBack API Enable/Disable*/
#define SPI_SET_LOOPBACK_MODE_API   (STD_ON)
/* @} */
/*
 *Design: MCAL-14218, MCAL-14217
 */
/** \brief Buffer mode - only external is supportted */
#define SPI_CHANNELBUFFERS          (SPI_EB)

/** \brief Maximum job log entries when logging is ON */
#define SPI_MAX_JOB_LOG             (100U)


/**
 * \name Scalability levels
 * @{
 */
/** \brief Basic Synchronous functions */
#define SPI_LEVEL_0                     (0U)
/** \brief Basic Synchronous functions: Duplicate define used in Configurator */
#define SPI_CFG_LEVEL_0                 (SPI_LEVEL_0)
/** \brief Basic Asynchronous functions */
#define SPI_LEVEL_1                     (1U)
/** \brief Basic Asynchronous functions: Duplicate define used in Configurator */
#define SPI_CFG_LEVEL_1                 (SPI_LEVEL_1)
/** \brief Synchronous and Asynchronous functions */
#define SPI_LEVEL_2                     (2U)
/** \brief Synchronous and Asynchronous: Duplicate define used in Configurator */
#define SPI_CFG_LEVEL_2                 (SPI_LEVEL_2)


/*
 *Design: MCAL-14198, MCAL-14197
 */
 
/** \brief Scalability level - only level 1 is supported */
#define SPI_SCALEABILITY            (SPI_LEVEL_2)
/* @} */
/**
 * \name Static memory allocation
 * All below macros are used for static memory allocation and can be changed to
 * match the usecase requirements.
 * @{
 */
/** \brief Maximum channels allowed per job */
#define SPI_MAX_CHANNELS_PER_JOB    (4U)

/** \brief Maximum jobs allowed per sequence */
#define SPI_MAX_JOBS_PER_SEQ        (4U)

/** \brief Maximum channels across all jobs/sequence/hwunit */
#define SPI_MAX_CHANNELS            (28U)

/** \brief Maximum jobs across all sequence/hwunit */
#define SPI_MAX_JOBS                (14U)

/** \brief Maximum sequence across all hwunit */
#define SPI_MAX_SEQ                 (14U)

/**
 *  \brief Maximum HW unit - This should match the sum for the below units ISR
 *  which are ON.
 */
#define SPI_MAX_HW_UNIT             (5U)

/**
 *  \brief Maximum external device cfg
 */
#define SPI_MAX_EXT_DEV             (5U)

/** 
*Total Hw Unit Instances
*/
#define SPI_HW_UNIT_CNT              (5U)




#define SPI_UNIT_QSPI1_DMA_ENABLE  (STD_ON)

#define SPI_UNIT_QSPI1_DMA_HANDLER  (CddDmaConf_CddDmaDriverHandler_0_Qspi)

/* @} */
/**
 * \name SPI ISR Types
 * All below macros are used for enabling the ISR for a particular hardware.
 * @{
 */

/** \brief Enable/disable SPI QSPI1 unit ISR */

#define SPI_UNIT_QSPI1_ACTIVE       (STD_ON)

/** \brief Enable/disable SPI MIBSPI1 unit ISR */

#define SPI_UNIT_MIBSPI1_ACTIVE      (STD_ON)

/** \brief Enable/disable SPI MIBSPI2 unit ISR */

#define SPI_UNIT_MIBSPI2_ACTIVE      (STD_ON)

/** \brief Enable/disable RCSS SPI MIBSPI1 unit ISR */

#define SPI_UNIT_RCSS_MIBSPI1_ACTIVE      (STD_ON)

/** \brief Enable/disable RCSS SPI MIBSPI2 unit ISR */

#define SPI_UNIT_RCSS_MIBSPI2_ACTIVE      (STD_ON)


/** \brief ISR type */
#define SPI_ISR_TYPE                (SPI_ISR_CAT1)
/* @} */
/** \brief OS counter ID - used for timeout in case of error */
#define SPI_OS_COUNTER_ID           ((CounterType)OsCounter_0)
/**
 *  \brief SPI timeout - used in MIBSPI IP reset and QSPI idle wait
 *   Each tick is 31.25us (for 32K Counter). Wait for 100ms which comes to
 *   below value
 */
#define SPI_TIMEOUT_DURATION        (64000U)



/* @} */
#define SpiConf_SpiChannel_SpiChannel_0 0
#define SpiConf_SpiJob_SpiJob_0 0
#define SpiConf_SpiExternalDevice_SpiExternalDevice_0_CS0 CS0
#define SpiConf_SpiExternalDevice_SpiExternalDevice_0_HwUnitId0 MIBSPI1
#define SpiConf_SpiSequence_SpiSequence_0 0

/*
 *  \brief MiBSPI functional clock input in Hz.
 *   This clock is used to generate the serial clock output after the divider.
 *
 *   Note: This is given here for reference and can't be changed.
 */
#define SPI_MIBSPI_FCLK                  (40000000U)

/**
 * \brief Spi Max Timeout for Transmission
 *
 */
#define SPI_MAX_TIMEOUT_DURATION         (20000U)

/**
 *  \brief QSPI maximum word count (frame length) allowed in single transfer.
 *   Application should take care to make sure framelength for single transfer
 *   doesnt exceed max allowed framelength.
 */
#define SPI_QSPI_MAX_FRAMELEN                  (4096U)

/**
 *  \name SPI Config Ids
 *
 *  The Config Ids used for different
 *  SPI Configuration builds
 *  @{
 */
/** \brief Config 0 (All configurations ON) */
#define  SPI_ID_0     (0x01U)
/** \brief Config 1 (All configurations OFF).
 *         SPI_ID_1 is used only for compile check */
#define  SPI_ID_1     (0x02U)
/** \brief Config 2 (All configurations ON except DET OFF) */
#define  SPI_ID_2     (0x04U)
/** \brief Config 3 (Configurator auto generated file) */
#define  SPI_ID_3     (0x08U)
/* @} */

/* ========================================================================== */
/*                         Structures and Enums                               */
/* ========================================================================== */

/** \brief Type of application data buffer elements */
/* Requirements : SWS_Spi_00376, SWS_Spi_00355, SWS_Spi_00164 */
/*
 * 
 *Design: MCAL-14295, MCAL-14313, MCAL-14340
 */
typedef uint8 Spi_DataBufferType;
/**
 *  \brief Type for defining the number of data elements of the type
 *  Spi_DataBufferType to send and / or receive by Channel
 */
/* Requirements : SWS_Spi_00377, SWS_Spi_00165 */
/*
 * 
 *Design: MCAL-14293, MCAL-14339
 */
typedef uint16 Spi_NumberOfDataType;
/** \brief Specifies the identification (ID) for a Channel */
/* Requirements : SWS_Spi_00378, SWS_Spi_00356, SWS_Spi_00166 */
/*
 * 
 *Design: MCAL-14292, MCAL-14311, MCAL-14337
 */
typedef uint8 Spi_ChannelType;
/** \brief Specifies the identification (ID) for a Job */
/* Requirements : SWS_Spi_00379, SWS_Spi_00357, SWS_Spi_00167 */
/*
 * 
 *Design: MCAL-14290, MCAL-14309, MCAL-14336
 */
typedef uint16 Spi_JobType;
/** \brief Specifies the identification (ID) for a sequence of jobs */
/* Requirements : SWS_Spi_00380, SWS_Spi_00358, SWS_Spi_00168 */
/*
 * 
 *Design: MCAL-14289, MCAL-14308, MCAL-14334
 */
typedef uint8 Spi_SequenceType;

/** \brief Specifies the identification (ID) for external devices */
typedef uint8  Spi_ExternalDeviceType;

/** \brief Specifies the SPI data element */
typedef uint8  Spi_DataType;

/** \brief Typedef for job end notification function pointer */
/* Requirements : SWS_Spi_00192 */
typedef void (*Spi_JobEndNotifyType)( void ) ;
/** \brief Typedef for sequence end notification function pointer */
/* Requirements : SWS_Spi_00193 */
typedef void (*Spi_SeqEndNotifyType)( void ) ;

/**
 *  \brief Specifies the identification (ID) for a SPI Hardware micro controller
 *  peripheral (unit)
 */
/* Requirements : SWS_Spi_00381, SWS_Spi_00359, SWS_Spi_00169 */
/*
 * 
 *Design: MCAL-14288, MCAL-14306, MCAL-14333
 */
typedef uint8 Spi_HWUnitType;

/**
 *  \brief This type defines a range of specific status for SPI Handler/Driver
 */
/* Requirements : SWS_Spi_00367, SWS_Spi_00373, SWS_Spi_00061, SWS_Spi_00011 */
/*
 * 
 *Design: MCAL-14299, MCAL-14346, MCAL-14328, MCAL-14327, MCAL-14351, MCAL-14323, MCAL-14322, MCAL-14321, MCAL-14320, MCAL-14319
 */
typedef enum
{
    SPI_UNINIT = 0U,
    /**< The SPI Handler/Driver is not initialized or not usable */
    SPI_IDLE = 1U,
    /**< The SPI Handler/Driver is not currently transmitting any Job */
    SPI_BUSY = 2U
               /**< The SPI Handler/Driver is performing a SPI Job (transmit) */
} Spi_StatusType;


/**
 *  \name SPI HW unit Info
 *  @{
 */
/** \brief MIBSPI1 instance */
#define SPI_UNIT_MIBSPI1                 ((Spi_HWUnitType) 0U)
/** \brief MIBSPI2 instance */
#define SPI_UNIT_MIBSPI2                 ((Spi_HWUnitType) 1U)
/** \brief QSPI1 instance */
#define SPI_UNIT_QSPI1                  ((Spi_HWUnitType) 2U)
/** \brief RCSS_MIBSPI1 instance */
#define RCSS_SPI_UNIT_MIBSPI1                 ((Spi_HWUnitType) 3U)
/** \brief RCSS_MIBSPI2 instance */
#define RCSS_SPI_UNIT_MIBSPI2                 ((Spi_HWUnitType) 4U)
/* @} */


/**
 *  \brief This type defines a range of specific Jobs status for SPI
 *  Handler/Driver
 */
/* Requirements : SWS_Spi_00374, SWS_Spi_00062, SWS_Spi_00012 */
/*
 * 
 *Design: MCAL-14298, MCAL-14344, MCAL-14326, MCAL-14350, MCAL-14318
 */
typedef enum
{
    SPI_JOB_OK = 0U,
    /**< The last transmission of the Job has been finished successfully */
    SPI_JOB_PENDING = 1U,
    /**< The SPI Handler/Driver is performing a SPI Job.
     *   The meaning of this status is equal to SPI_BUSY */
    SPI_JOB_FAILED = 2U,
    /**< The last transmission of the Job has failed */
    SPI_JOB_QUEUED = 3U
                     /**< An asynchronous transmit Job has been accepted, while
                      * actual
                      *   transmission for this Job has not started yet */
} Spi_JobResultType;

/**
 *  \brief This type defines a range of specific Sequences status for SPI
 *  Handler/Driver
 */
 /*
 * 
 *Design: MCAL-14297, MCAL-14317, MCAL-14330, MCAL-14348, MCAL-14316, MCAL-14315, MCAL-14314, MCAL-14347
 */
/* Requirements : SWS_Spi_00375, SWS_Spi_00019, SWS_Spi_00017 */
typedef enum
{
    SPI_SEQ_OK = 0U,
    /**< The last transmission of the Sequence has been finished successfully */
    SPI_SEQ_PENDING = 1U,
    /**< The SPI Handler/Driver is performing a SPI Sequence. The meaning of
     *   this status is equal to SPI_BUSY */
    SPI_SEQ_FAILED = 2U,
    /**< The last transmission of the Sequence has failed */
    SPI_SEQ_CANCELLED = 3U
                        /**< The last transmission of the Sequence has been
                         *canceled by user */
} Spi_SeqResultType;

/**
 *  \brief This type defines a range of specific HW unit status for SPI
 *  Handler/Driver
 */
typedef enum
{
    SPI_HW_UNIT_OK = 0U,
    /**< HW unit result is ok */
    SPI_HW_UNIT_PENDING = 1U,
    /**< HW unit result is pending */
    SPI_HW_UNIT_FAILED = 2U
                         /**< HW unit result is failed */
} Spi_HwUnitResultType;

/**
 *  \brief Specifies the asynchronous mechanism mode for SPI busses handled
 *  asynchronously in LEVEL 2
 */
/* Requirements : SWS_Spi_00382, SWS_Spi_00360, SWS_Spi_00170, SWS_Spi_00150,
 *                SWS_Spi_00361, SWS_Spi_00362, SWS_Spi_00155 */
  /*
 * 
 *Design: MCAL-14286, MCAL-14303, MCAL-14332,MCAL-22662, MCAL-14302, MCAL-14301
 */
typedef enum
{
    SPI_POLLING_MODE = 0U,
    /**< The asynchronous mechanism is ensured by polling, so interrupts
     *   related to SPI busses handled asynchronously are disabled */
    SPI_INTERRUPT_MODE = 1U
                         /**< The asynchronous mechanism is ensured by
                          * interrupt, so interrupts related to SPI busses
                          * handled asynchronously are enabled */
} Spi_AsyncModeType;

/**
 *  \brief Word transfer order - MSB first or LSB first
 */
typedef enum
{
    SPI_MSB = 0U,
    /**< MSB is transferred first. Only this is supported */
    SPI_LSB = 1U
              /**< LSB is transferred first. This is not supported */
} Spi_TransferType;

/**
 *  \brief Type for SPI Chip Select Polarity and Clock Idle Level.
 */
typedef enum
{
    SPI_LOW = STD_LOW,
    /**< Low clock or chip select */
    SPI_HIGH
    /**< High clock or chip select */
} Spi_LevelType;

/**
 *  \brief SPI Chip Select Pin.
 */
typedef enum
{
    SPI_CS0 = 0U,
    /**< Chip select 0 */
    SPI_CS1,
    /**< Chip select 1 */
    SPI_CS2,
    /**< Chip select 2 */
    SPI_CS3
    /**< Chip select 3 */
} Spi_CsPinType;

/**
 *  \brief SPI Clock Mode - sets the clock polarity and phase.
 *   Note: These values are a direct register mapping. So don't change value.
 */
typedef enum
{
    SPI_CLK_MODE_0 = 0x00U,
    /**< SPI Clock Phase = 0 (rising edge latch),  Polarity = 0 (Active HIGH) */
    SPI_CLK_MODE_1 = 0x01U,
    /**< SPI Clock Phase = 1 (falling edge latch), Polarity = 0 (Active HIGH) */
    SPI_CLK_MODE_2 = 0x02U,
    /**< SPI Clock Phase = 0 (rising edge latch),  Polarity = 1 (Active LOW) */
    SPI_CLK_MODE_3 = 0x03U,
    /**< SPI Clock Phase = 1 (falling edge latch), Polarity = 1 (Active LOW) */
} Spi_ClkMode;



/**
 *  \brief SPI TX/RX Mode.
 *
 *   Note:
 *      1. These values are a direct register mapping. So don't change value.
 *      2. RX only mode doesn't make sense in master mode because to receive
 *         data the master has to generate clock, which means it should
 *         transmit. Hence this mode is not supported. The user can
 *         alternatively set the TX buffer pointer to NULL and set the
 *         default TX value (defaultTxData) to make TX data line at the desired
 *         level.
 */
typedef enum
{
    SPI_TX_RX_MODE_BOTH = 0x00U,
    /**< Both TX and RX are enabled */
    SPI_TX_RX_MODE_TX_ONLY = 0x02U,
    /**< Only TX is enabled */
} Spi_TxRxMode;

/**
 *  \brief SPI Job Priority.
 */
/* Requirements : SWS_Spi_00093 */
 /*
 *Design: MCAL-14229, MCAL-14230, MCAL-14231,
 */
typedef enum
{
    SPI_JOB_PRIORITY_0 = 0U,
    /**< Job priority 0 - low */
    SPI_JOB_PRIORITY_1,
    /**< Job priority 1*/
    SPI_JOB_PRIORITY_2,
    /**< Job priority 2 */
    SPI_JOB_PRIORITY_3
    /**< Job priority 3 - High */
} Spi_JobPriorityType;

/**
 *  \brief SPI Chip Select Mode.
 */
typedef enum
{
    SPI_SINGLE = 0U,
    /**< Chip select mode - single. Active only when transfer is on. */
    SPI_CONTINUOUS = 1U
                     /**< Chip select mode - continuous. Active throughout. */
} Spi_CsModeType;

/**
 *  \brief SPI QSPI data delay.
 */
typedef enum
{
    SPI_DATADELAY_0 = 0U,
    /**< Data is output on the same cycle as the qspi1_cs[x] goes active */
    SPI_DATADELAY_1 = 1U,
    /**< Data is output 1 qspi1_sclk cycle after the qspi1_cs[x] goes active */
    SPI_DATADELAY_2 = 2U,
    /**< Data is output 2 qspi1_sclk cycle after the qspi1_cs[x] goes active */
    SPI_DATADELAY_3 = 3U,
    /**< Data is output 3 qspi1_sclk cycle after the qspi1_cs[x] goes active */
} Spi_DataDelayType;

/**
 *  \brief SPI QSPI memsetup number of address bytes to be sent
 */
typedef enum
{
    SPI_QSPI_MEMSETUP_NUMADDR_BYTES_1 = 0U,
    /**< 1 address byte to be sent for serial flash interface */
    SPI_QSPI_MEMSETUP_NUMADDR_BYTES_2 = 1U,
    /**< 2 address byte to be sent for serial flash interface */
    SPI_QSPI_MEMSETUP_NUMADDR_BYTES_3 = 2U,
    /**< 3 address byte to be sent for serial flash interface */
    SPI_QSPI_MEMSETUP_NUMADDR_BYTES_4 = 3U
                                        /**< 4 address byte to be sent for
                                         *serial flash interface */
} Spi_QspiMemSetupNumAddrBytesType;

/**
 *  \brief SPI QSPI memsetup number of dummy bytes to be used for fast read
 */
typedef enum
{
    SPI_QSPI_MEMSETUP_NUMDUMMY_BYTES_0 = 0U,
    /**< 0x0: No dummy bytes required. Use the value in numDummyBits */
    SPI_QSPI_MEMSETUP_NUMDUMMY_BYTES_1 = 1U,
    /**< 0x1: Use 8 bits dummy for fast read */
    SPI_QSPI_MEMSETUP_NUMDUMMY_BYTES_2 = 2U,
    /**< 0x2: Use 16 bits dummy for fast read */
    SPI_QSPI_MEMSETUP_NUMDUMMY_BYTES_3 = 3U
                                         /**< 0x3: Use 24 bits dummy for fast
                                          *read */
} Spi_QspiMemSetupNumDummyBytesType;

/**
 *  \brief SPI QSPI memsetup read type to determine single/dual/quad read mode
 */
typedef enum
{
    SPI_QSPI_MEMSETUP_READTYPE_NORMAL_0 = 0U,
    /**< 0x0: Normal read (all data input on qspi1_d[1]) */
    SPI_QSPI_MEMSETUP_READTYPE_DUAL = 1U,
    /**< 0x1: Dual read (odd bytes input on qspi1_d[1]; even bytes on
     * qspi1_d[0]) */
    SPI_QSPI_MEMSETUP_READTYPE_NORMAL_1 = 2U,
    /**<0x2: Normal read (all data input on qspi1_d[1]) */
    SPI_QSPI_MEMSETUP_READTYPE_QUAD = 3U
                                      /**< 0x3: Quad read (uses also qspi1_d[2]
                                       *and qspi1_d[3]) */
} Spi_QspiMemSetupReadType;
/**
 *  \brief SPI Chconfig QSPI serial flash channel mode
 */
typedef enum
{
    SPI_QSPI_SFI_CHMODE_CMD = 0U,
    /**< Channel used for Serial flash cmd */
    SPI_QSPI_SFI_CHMODE_ADDR = 1U,
    /**< Channel used for Serial flash address programing  */
    SPI_QSPI_SFI_CHMODE_DUMMY = 2U,
    /**< Channel used for Serial flash address programing  */
    SPI_QSPI_SFI_CHMODE_DATA = 3U,
    /**< Channel used for Serial flash write/read (memory or config ) from
     *  flash. */
} Spi_QspiChModeType;

/**
 *  \brief SPI Chconfig QSPI serial flash channel direction
 */
typedef enum
{
    SPI_QSPI_SFI_CH_XFER_CMD_RESERVED_0 = 0U,
    /**< 0x0: Reserved . Not to be configured by app */
    SPI_QSPI_SFI_CH_XFER_CMD_4PIN_RD_SINGLE = 1U,
    /**< 0x1: 4-pin Read Single */
    SPI_QSPI_SFI_CH_XFER_CMD_4PIN_WR_SINGLE = 2U,
    /**< 0x1: 4-pin Write Single */
    SPI_QSPI_SFI_CH_XFER_CMD_4PIN_RD_DUAL = 3U,
    /**< 0x1: 4-pin Read Dual */
    SPI_QSPI_SFI_CH_XFER_CMD_RESERVED_1 = 4U,
    /**< 0x4: Reserved . Not to be configured by app */
    SPI_QSPI_SFI_CH_XFER_CMD_3PIN_RD_SINGLE = 5U,
    /**< 0x5: 3-pin Read Single */
    SPI_QSPI_SFI_CH_XFER_CMD_3PIN_WR_SINGLE = 6U,
    /**< 0x6: 3-pin Write Single */
    SPI_QSPI_SFI_CH_XFER_CMD_6PIN_RD_QUAD = 7U
                                            /**< 0x7: 6-pin Read Quad */
} Spi_QspiChXferCmdType;


/* descriptor type definition for buffers */
typedef struct
{
    P2VAR(Spi_DataBufferType, AUTOMATIC, SPI_APPL_DATA) Spi_Tx_pt;
    /* Transmit buffer pointer */
    P2VAR(Spi_DataBufferType, AUTOMATIC, SPI_APPL_DATA) Spi_Rx_pt;
    /* Receive buffer pointer */
    uint16 Spi_TxRxLength;
    /* length to send and receive */
} Spi_BufferDescriptorType;

/**
 *  \brief SPI Channel configuration structure.
 */
/*
 * Requirements : SWS_Spi_00111, SWS_Spi_00279, SWS_Spi_00112, SWS_Spi_00280,
 *                SWS_Spi_00063
 */
/* Design : AUTORADAR_MCAL-1115, AUTORADAR_MCAL-1227, AUTORADAR_MCAL-1116, AUTORADAR_MCAL-1228, AUTORADAR_MCAL-1092 */
typedef struct
{
    Spi_ChannelType       channelId;
    /**< Channel ID */
    uint8                 channelBufType;
    /**< Buffer Type IB/EB */
    uint8                 dataWidth;
    /**< Width of clock frame in bits.
     *   In case of MiBSPI/QSPI, valid values are from 1 to 32 bits. */
    uint16                defaultTxData;
    /**< Default transmit value when TX buffer is NULL */
    Spi_NumberOfDataType  maxBufLength;
    /**< Max data length external or internal buffer */
    Spi_TransferType      transferType;
    /**< Start with MSB or LSB.
     *   Only MSB is supported.  */
    Spi_QspiChModeType    qspiChMode;
    /**< Channel Mode when doing QSPI xfer connected to serial flash interface.
     *   Not applicable for MiBSPI */
    Spi_QspiChXferCmdType qspiXferCmd;
    /**< Channel transfer command.
     *   Not applicable for MIBSPI */
} Spi_ChannelConfigType;

/**
 *  \brief Contains the read/write command setup for the memory mapped protocol
 *
 *         By default (reset), the device uses a write command of 2, read
 *         command of 3 and address bytes number of 3.
 *         Default covers most of the serial flash devices,but can be changed
 */
typedef struct
{
    uint8                             readCmd;
    /**< Read Command */
    uint8                             writeCmd;
    /**< Write Command */
    uint8                             numDummyBits;
    /**< Number of dummy bits to use if numDummyBytes = 0x0.In range 0 - 31 */
    Spi_QspiMemSetupReadType          readType;
    /**< Determines if the read command is a single/dual/quad read mode cmd */
    Spi_QspiMemSetupNumAddrBytesType  numAddrBytes;
    /**< Number of address bytes to be sent */
    Spi_QspiMemSetupNumDummyBytesType numDummyBytes;
    /**< Number of dummy bytes to be sent */
} Spi_QspiMemSetupConfigType;

/**
 *  \brief SPI Job configuration structure specific to QSPI peripheral.
 */
typedef struct
{
    Spi_LevelType              csPolarity;
    /**< Chip select pin polarity high or low */
    Spi_DataDelayType          csIdleTime;
    /**< CS idle time (Timing between clock and chip select) if single mode
     *   is chosen. Values in case of MiBSPI/QSPI
     *                  QSPI
     *   0x00   -   0 clock cycle
     *   0x01   -   1 clock cycles
     *   0x02   -   2 clock cycles
     *   0x03   -   3 clock cycles */
    uint16                     clkDivider;
    /**< Clock divider. This is used to derive the required baudrate from
     *   the QSPI functional clock. This value should be 1 less
     *   than the actual divider value. So a value of 0 means the divider is 1.
     *   Maximum allowed value of divider is 65535(15 bit register field)*/
    Spi_ClkMode                clkMode;
    /**< Mode 0 = {0=CPOL,0=CPHA}; Mode 1={0,1}; Mode 2={1,0} Mode 3={1,1} */
    Spi_QspiMemSetupConfigType qspiMemSetup;
    /**< QSPI read/write command setup to memory map current CS */
} Spi_QspiExternalDeviceConfigType;


/**
 *  \brief SPI Job configuration structure specific to MiBSPI peripheral.
 */
typedef struct
{
    Spi_CsPinType Spi_DioPin;
    /**< Holds the configured Dio pin for toggling CS */
    Spi_LevelType Spi_CsProperty;
    /**< Low byte the CS idle level, high byte res. */
    uint16 Spi_Baudrate;
    /**< Baudrate setting for the external device*/
    Spi_ClkMode  Spi_Mode;
    /**< Mode 0 = {0=CPOL,0=CPHA}; Mode 1={0,1}; Mode 2={1,0} Mode 3={1,1} */
    uint16 Spi_ClkDelays[2U];
    /**< includes CS2Clk, Clk2Cs, Clk2Ena, Ena2Clk */
    uint16 Spi_CsIdleTime;
    /**< CS idle time if single mode is chosen */
    Spi_CsModeType  Spi_CsMode;
    /**< Select single or continuous mode */
    uint8  Spi_HwInstance;
    /**< SPI HW Instance */
     Spi_TxRxMode      txRxMode;
    /**< TX and RX mode */
}Spi_MibspiExternalDeviceConfigType;



/**
 *  \brief SPI external device specific configuration structure .
 */
typedef struct
{
    
    Spi_MibspiExternalDeviceConfigType mibspi;
    /**< MIBSPI HW specific external device config. Should be populated only
     * if hwUnitId is MIBSPI */
	 Spi_QspiExternalDeviceConfigType  qspi;
    /**< QSPI HW specific external device config. Should be populated only
     *   if hwUnitId is of type QSPI */
} Spi_ExternalDeviceConfigType;



/**
 *  \brief SPI Job configuration structure.
 */
/* Requirements : SWS_Spi_00050, SWS_Spi_00066, SWS_Spi_00263, SWS_Spi_00370
 *                SWS_Spi_00368, SWS_Spi_00262, SWS_Spi_00002, SWS_Spi_00009,
 *                SWS_Spi_00010
 */
typedef struct
{
    uint8                jobId;
    /**< Job ID */
    Spi_JobPriorityType  jobPriority;
    /**< Job priority */
    Spi_HWUnitType       hwUnitId;
    /**< HWUnit associated with this job */
    Spi_CsPinType        csPin;
    /**< Chip select pin to use */
    Spi_JobEndNotifyType Spi_JobEndNotification;
    /**< Job end notification callback fxn pointer */
    uint32               channelPerJob;
    /**< Number of channels for this job.
     *   Should not be more than SPI_MAX_CHANNELS_PER_JOB */
    Spi_ChannelType      channelList[SPI_MAX_CHANNELS_PER_JOB];
    /**< Channel index list */
    uint8                externalDeviceCfgId;
    /**< index into SpiConfig.extDevCfg[] indicating the devCfg associated
     *   with the job */
    uint8                qspiEnableMemMapMode;
    /**< Enable QSPI memory mapped mode read/write */
} Spi_JobConfigType;

/**
 *  \brief SPI Sequence configuration structure.
 */
/* Requirements : SWS_Spi_00236, SWS_Spi_00064, SWS_Spi_00121  */
/* Design : AUTORADAR_MCAL-1195, AUTORADAR_MCAL-1093, AUTORADAR_MCAL-1124  */
typedef struct
{
    Spi_SequenceType     seqId;
    /**< Sequence ID */
    uint8                seqInterruptible;
    /**< Sequence interruptible or not (TRUE/FALSE) */
    Spi_SeqEndNotifyType Spi_SequenceEndNotification;
    /**< Sequence end notification callback fxn pointer */
    uint32               jobPerSeq;
    /**< Number of jobs for this sequence.
     *   Should not be more than SPI_MAX_JOBS_PER_SEQ */
    Spi_JobType          jobList[SPI_MAX_JOBS_PER_SEQ];
    /**< Job index list */
} Spi_SeqConfigType;

/**
 *  \brief SPI Hardware unit configuration structure.
 */
typedef struct
{
    Spi_HWUnitType hwUnitId;
    /**< SPI HW unit to use */
} Spi_HwUnitConfigType;

typedef struct
{
    P2VAR(Spi_JobResultType, AUTOMATIC, SPI_VAR_ZERO_INIT) Spi_JobResult;      /* job result      */
    P2VAR(Spi_SeqResultType, AUTOMATIC, SPI_VAR_ZERO_INIT) Spi_SeqResult;      /* sequence result */
    P2VAR(Spi_HwUnitResultType, AUTOMATIC, SPI_VAR_ZERO_INIT) Spi_DlcResult;   /* hardware result */
} Spi_ResultType;

/**
 *  \brief SPI config structure
 */
/*
 * Requirements : SWS_Spi_00372, SWS_Spi_00344, SWS_Spi_00008, SWS_Spi_00044,
 *                SWS_Spi_00048
 */
 /*
 * 
 *Design: MCAL-14300, MCAL-14324, MCAL-14354, MCAL-14342, MCAL-14353, MCAL-14341, MCAL-14352
 */
typedef struct Spi_ConfigType_s
{
    uint8                        maxChannels;
    /**< Maximum number of channels.
     *   Should not be more than SPI_MAX_CHANNELS */
    uint8                        maxJobs;
    /**< Maximum number of jobs
     *   Should not be more than SPI_MAX_JOBS */
    uint8                        maxSeq;
    /**< Maximum number of sequences
     *   Should not be more than SPI_MAX_SEQ */
    uint8                        maxHwUnit;
    /**< Maximum number of HW unit
     *   Should not be more than SPI_MAX_HW_UNIT */
    uint8                        maxExtDevCfg;
    /**< Maximum number of external device configurations
     *   Should not be more than SPI_MAX_EXT_DEV */
    uint8 Spi_MaxDlcs;
    /**< Maximum number of dlc's */
	 Spi_ExternalDeviceConfigType extDevCfg[SPI_MAX_EXT_DEV];
    /**< External HW device config */
    Spi_ChannelConfigType        channelCfg[SPI_MAX_CHANNELS];
    /**< Channel configurations */
    Spi_JobConfigType            jobCfg[SPI_MAX_JOBS];
    /**< Job configurations */
    Spi_SeqConfigType            seqCfg[SPI_MAX_SEQ];
    /**< Sequence configurations */
    Spi_HwUnitConfigType         hwUnitCfg[SPI_MAX_HW_UNIT];
    /**< HW Unit configurations */
} Spi_ConfigType;

typedef struct
{
    uint32 Spi_GCR0 ;         
    /* SPI Global Control Register 0 */
    uint32 Spi_GCR1 ;         
    /* SPI Global Control Register 1 */
    uint32 Spi_DEF  ;         
    /* SPI Default Chip Select Register */
    uint32 Spi_EN   ;         
    /* Multi-buffer Mode Enable Register */

    /*
     * QSPI related registers
     */
    uint32      qspiPid;
    /**< IP revision */
    uint32      qspiSysConfig;
    /**< Clock management configuration */
}Spi_RegisterReadbackType;

typedef struct
 {
     volatile uint32 Spi_FUN  ; /* Offset: 0x14 */
     volatile uint32 Spi_DIR  ; /* Offset: 0x18 */
     volatile uint32 Spi_DIN  ; /* Offset: 0x1C */
     volatile uint32 Spi_DOUT ; /* Offset: 0x20 */
     volatile uint32 Spi_DSET ; /* Offset: 0x24 */
     volatile uint32 Spi_DCLR ; /* Offset: 0x28 */
     volatile uint32 Spi_PDR  ; /* Offset: 0x2C */
     volatile uint32 Spi_PDIS ; /* Offset: 0x30 */
     volatile uint32 Spi_PSEL ; /* Offset: 0x34 */
 } Spi_PinCtrlType;
 
 typedef struct
 {
     volatile uint16 TxData;
     volatile uint16 TxCtrl;
 }Spi_TxField;
 
 typedef struct
 {
     volatile uint16 RxData;
     volatile uint16 RxStat;
 }Spi_RxField;
 
 typedef struct
 {
     volatile uint32 Spi_TGITENST  ; /* Offset: 0x74 */
     volatile uint32 Spi_TGITENCR  ; /* Offset: 0x78 */
     volatile uint32 Spi_TGITLVST  ; /* Offset: 0x7C */
     volatile uint32 Spi_TGITLVCR  ; /* Offset: 0x80 */
     volatile uint32 Spi_TGINTFLAG ; /* Offset: 0x84 */
     volatile uint32 Spi_Reserved0 ; /* Offset: 0x88 */
     volatile uint32 Spi_Reserved1 ; /* Offset: 0x8C */
     volatile uint32 Spi_TICKCNT   ; /* Offset: 0x90 */
     volatile uint32 Spi_LTGPEND   ; /* Offset: 0x94 */
     volatile uint32 Spi_TGCTRL[16U] ; /* Offset: 0x98 - 0xD4 */
 } Spi_TGCTRLRegType;
 
 typedef struct
 {
     volatile uint32 Spi_DMACTRL[8U] ;  /* Offset: 0xD8- 0xF8 */
     volatile uint32 Spi_DMACOUNT[8U] ; /* Offset: 0xFC - 0x114 */
     volatile uint32 Spi_DMACNTLEN ;   /* Offset: 0x118 */
 } Spi_DMACTRLRegType;
 
 typedef struct
  {
      volatile uint32 Spi_GCR0 ;         /* Offset: 0x00 */
      volatile uint32 Spi_GCR1 ;         /* Offset: 0x04 */
      volatile uint32 Spi_INT0 ;         /* Offset: 0x08 */
      volatile uint32 Spi_LVL  ;         /* Offset: 0x0C */
      volatile uint32 Spi_FLG  ;         /* Offset: 0x10 */
      Spi_PinCtrlType Spi_PC ;           /* Offset: 0x14 - 0x34 */
      volatile Spi_TxField Spi_DAT0 ;    /* Offset: 0x38 */
      volatile Spi_TxField Spi_DAT1 ;    /* Offset: 0x3C */
      volatile Spi_RxField Spi_BUF  ;    /* Offset: 0x40 */
      volatile uint32 Spi_EMU  ;         /* Offset: 0x44 */
      volatile uint16 Spi_DELAY[2U] ;     /* Offset: 0x48 */
      volatile uint32 Spi_DEF   ;        /* Offset: 0x4C */
      volatile uint32 Spi_FMT[4U] ;       /* Offset: 0x50 - 0x5C */
      volatile uint32 Spi_TGINTVECT[2U];  /* Offset: 0x60 -0x64 */
      volatile uint32 Spi_SRSEL  ;       /* Offset: 0x68 */
      volatile uint32 Spi_PMCTRL ;       /* Offset: 0x6C */
      volatile uint32 Spi_EN  ;          /* Offset: 0x70 */
      Spi_TGCTRLRegType Spi_RegTGCTL ;   /* Offset: 0x74 - 0xD4 */
      Spi_DMACTRLRegType Spi_RegDMACTRL; /* Offset: 0xD8 - 0x118 */
      volatile uint32 Spi_Reserved2 ;    /* Offset: 0x11C */
      volatile uint32 Spi_UERRCTRL ;     /* Offset: 0x120 */
      volatile uint32 Spi_UERRSTAT ;     /* Offset: 0x124 */
      volatile uint32 Spi_UERRADDR1 ;    /* Offset: 0x128 */
      volatile uint32 Spi_UERRADDR0 ;    /* Offset: 0x12C */
      volatile uint32 Spi_RXOVRN_ADDR;   /* Offset: 0x130 */
      volatile uint32 Spi_IOLPBTSTCR ;   /* Offset: 0x134 */
      volatile uint32 Spi_EXT_PRESCALE1; /* Offset: 0x138 */
  }Spi_RegisterType;
 
 typedef struct
 {
     volatile Spi_TxField Spi_TxBank[SPI_DLC_MIBTXSIZE] ; /* TxBank consists of 16bit control and 16bit txdata */
     volatile Spi_RxField Spi_RxBank[SPI_DLC_MIBRXSIZE] ; /* RxBank consists of 16bit status  and 16bit rxdata */
 }Spi_RamBufferType ;
 
 typedef P2VAR(volatile Spi_RegisterType,  AUTOMATIC, MSR_REGSPACE) Spi_RegisterPtrType ;
 typedef P2VAR(volatile Spi_RamBufferType, AUTOMATIC, MSR_REGSPACE) Spi_RamBufferPtrType;
 
 typedef struct
 {
     uint8 Spi_RamUsed;
     uint8 Spi_UnitID;
 }Spi_HWUnitPropertyType;
 
  /* ========================================================================== */
  /*                         Global Variable                                    */
  /* ========================================================================== */
  
  /*LDRA_INSPECTED 127 S MR:8.12Reason : "Array is generated at precompile time" */
 extern CONST(Spi_RegisterPtrType, SPI_CONST) Spi_HWUnit_at[SPI_MAX_HW_UNIT];
 /*LDRA_INSPECTED 127 S MR:8.12Reason : "Array is generated at precompile time" */
 extern CONST(Spi_RamBufferPtrType, SPI_CONST) Spi_RamUnit_at[SPI_MAX_HW_UNIT];
 /*LDRA_INSPECTED 127 S MR:8.12Reason : "Array is generated at precompile time" */
 extern CONST(Spi_HWUnitPropertyType, SPI_CONST) Spi_UnitProperty_at[SPI_MAX_HW_UNIT];
 
/** \brief SPI Configuration struct declaration */
extern const struct Spi_ConfigType_s SpiDriver_0;

#ifdef __cplusplus
}
#endif

#endif  /* #ifndef SPI_CFG_H_ */

/* @} */



