/*
*
* Copyright (c) 2023 Texas Instruments Incorporated
*
* All rights reserved not granted herein.
*
* Limited License.
*
* Texas Instruments Incorporated grants a world-wide, royalty-free, non-exclusive
* license under copyrights and patents it now or hereafter owns or controls to make,
* have made, use, import, offer to sell and sell ("Utilize") this software subject to the
* terms herein.  With respect to the foregoing patent license, such license is granted
* solely to the extent that any such patent is necessary to Utilize the software alone.
* The patent license shall not apply to any combinations which include this software,
* other than combinations with devices manufactured by or for TI ("TI Devices").
* No hardware patent is licensed hereunder.
*
* Redistributions must preserve existing copyright notices and reproduce this license
* (including the above copyright notice and the disclaimer and (if applicable) source
* code license limitations below) in the documentation and/or other materials provided
* with the distribution
*
* Redistribution and use in binary form, without modification, are permitted provided
* that the following conditions are met:
*
* *       No reverse engineering, decompilation, or disassembly of this software is
* permitted with respect to any software provided in binary form.
*
* *       any redistribution and use are licensed by TI for use only with TI Devices.
*
* *       Nothing shall obligate TI to provide you with source code for the software
* licensed and provided to you in object code.
*
* If software source code is provided to you, modification and redistribution of the
* source code are permitted provided that the following conditions are met:
*
* *       any redistribution and use of the source code, including any resulting derivative
* works, are licensed by TI for use only with TI Devices.
*
* *       any redistribution and use of any object code compiled from the source code
* and any resulting derivative works, are licensed by TI for use only with TI Devices.
*
* Neither the name of Texas Instruments Incorporated nor the names of its suppliers
*
* may be used to endorse or promote products derived from this software without
* specific prior written permission.
*
* DISCLAIMER.
*
* THIS SOFTWARE IS PROVIDED BY TI AND TI'S LICENSORS "AS IS" AND ANY EXPRESS
* OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL TI AND TI'S LICENSORS BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
* BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
* OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
* OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
* OF THE POSSIBILITY OF SUCH DAMAGE.
*
*/

  /*********************************************************************************************************************
    Project: ADC_AM273_
    Date   : 2024-01-04 00:51:04

    This file is generated by EB Tresos
    Do not modify this file, otherwise the software may behave in unexpected way.

 *********************************************************************************************************************/

/**
 *  \file     Adc_Cfg.h
 *
 *  \brief    This file contains generated pre compile configuration file
 *            for ADC MCAL driver
 *
 */

/**
 *  \defgroup MCAL_ADC_CFG ADC Configuration
 *
 *  This files defines ADC MCAL configuration structures
 *  @{
 */


#ifndef ADC_CFG_H_
#define ADC_CFG_H_

/* ========================================================================== */
/*                             Include Files                                  */
/* ========================================================================== */
#include "Os.h"
#include "Dem.h"

#ifdef __cplusplus
extern "C" {
#endif

/* ========================================================================== */
/*                           Macros & Typedefs                                */
/* ========================================================================== */
/**
*  \brief ADC Build Variant.
*   Build variants.(i.e Pre Compile,Post Build)
*/
#define ADC_VARIANT_PRE_COMPILE   (STD_OFF)

#define ADC_VARIANT_POST_BUILD    (STD_ON)



/** \brief ADC Config ID */
#define ADC_ID                          (ADC_ID_0)

/** \brief Enable/disable ADC AdcEnableHardwareTrigger and AdcDisableHardwareTrigger group notify API */
#define ADC_HW_TRIGGER_API              (STD_OFF)

/** \brief  Enable/disable ADC polling main function API */
#define ADC_POLLING_MAINFUNCTION_API              (STD_OFF)

/** \brief Enable/disable ADC GetStreamLastPointer API */
#define ADC_GET_STREAM_LAST_POINTER     (STD_OFF)

/** \brief Enable/disable ADC DMA Access method. */
#define ADC_DMA_MODE                   (STD_OFF)
/**
 *  \name Adc Driver Configuration SW Version Info
 *
 *  Defines for ADC Driver configuration version
 *  @{
 */
#define ADC_CFG_MAJOR_VERSION    (10U)
#define ADC_CFG_MINOR_VERSION    (1U)
#define ADC_CFG_PATCH_VERSION    (1U)
/* @} */

/** \brief Enable/disable ADC dev detect error */
#define ADC_DEV_ERROR_DETECT             (STD_ON)

/** \brief Enable/disable ADC get version info API */
#define ADC_VERSION_INFO_API             (STD_ON)

/** \brief Read group API */
#define ADC_READ_GROUP_API               (STD_ON)

/** \brief Enable/disable ADC enable/disable group notify API */
#define ADC_GRP_NOTIF_CAPABILITY_API     (STD_ON)

/** \brief Enable/disable ADC start/stop group notify API */
#define ADC_ENABLE_START_STOP_GROUP_API  (STD_ON)

/** \brief Enable/disable ADC deinit API */
#define ADC_DEINIT_API                   (STD_ON)

/** \brief Enable/disable AdcReadTemperatureApi API */
#define ADC_READ_TEMPERATURE_API         (STD_ON)

/** \brief Determines whether a priority mechanism is available for
 *   prioritization of the conversion requests and if available, the type of
 *   prioritization mechanism */
#define ADC_PRIORITY_IMPLEMENTATION     (ADC_PRIORITY_HW_SW)

/** \brief Determines, if the queuing mechanism is active in case of priority
 *   mechanism disabled */
#define ADC_ENABLE_QUEUING               (STD_ON)

/** \brief Alignment of ADC raw results in ADC result buffer
 *  (left/right alignment) */
#define ADC_RESULT_ALIGNMENT            (ADC_ALIGN_RIGHT)

/** \brief Maximum group across all hwunit */
#define ADC_MAX_GROUP                   (4U)

/**
 *  \brief Maximum HW unit - This should match the sum for the below units ISR
 *  which are ON.
 */
#define ADC_MAX_HW_UNIT                 (1U)

/**\brief Group IDs for all the groups*/

/**
 *  \brief Symbolic name for AdcGroup_0 Group ID for
 *  AdcConfigSet_0 configuration set
 */
#define AdcConf_AdcConfigSet_0_AdcGroup_AdcGroup_0  (0U)

/**
 *  \brief Symbolic name for AdcGroup_1 Group ID for
 *  AdcConfigSet_0 configuration set
 */
#define AdcConf_AdcConfigSet_0_AdcGroup_AdcGroup_1  (1U)

/**
 *  \brief Symbolic name for AdcGroup_2 Group ID for
 *  AdcConfigSet_0 configuration set
 */
#define AdcConf_AdcConfigSet_0_AdcGroup_AdcGroup_2  (2U)

/**
 *  \brief Symbolic name for AdcGroup_3 Group ID for
 *  AdcConfigSet_0 configuration set
 */
#define AdcConf_AdcConfigSet_0_AdcGroup_AdcGroup_3  (3U)


/** \brief number of channels for each group*/

/**
 *  \brief Symbolic name for number of channels in AdcGroup_0 Group for
 *  AdcConfigSet_0 configuration set
 */
#define AdcConf_AdcConfigSet_0_AdcGroup_AdcGroup_0_size     (3U)

/**
 *  \brief Symbolic name for number of channels in AdcGroup_1 Group for
 *  AdcConfigSet_0 configuration set
 */
#define AdcConf_AdcConfigSet_0_AdcGroup_AdcGroup_1_size     (12U)

/**
 *  \brief Symbolic name for number of channels in AdcGroup_2 Group for
 *  AdcConfigSet_0 configuration set
 */
#define AdcConf_AdcConfigSet_0_AdcGroup_AdcGroup_2_size     (2U)

/**
 *  \brief Symbolic name for number of channels in AdcGroup_3 Group for
 *  AdcConfigSet_0 configuration set
 */
#define AdcConf_AdcConfigSet_0_AdcGroup_AdcGroup_3_size     (3U)


/** \brief Channel Ids for each group*/

/**
 *  \brief Symbolic name for channel AdcChannel_9 in AdcGroup_0 Group for
 *  AdcConfigSet_0 configuration set
 */
#define AdcConf_AdcConfigSet_0_AdcGroup_AdcGroup_0_AdcChannel_9        (9U)

/**
 *  \brief Symbolic name for channel AdcChannel_10 in AdcGroup_0 Group for
 *  AdcConfigSet_0 configuration set
 */
#define AdcConf_AdcConfigSet_0_AdcGroup_AdcGroup_0_AdcChannel_10        (10U)

/**
 *  \brief Symbolic name for channel AdcChannel_11 in AdcGroup_0 Group for
 *  AdcConfigSet_0 configuration set
 */
#define AdcConf_AdcConfigSet_0_AdcGroup_AdcGroup_0_AdcChannel_11        (11U)

/**
 *  \brief Symbolic name for channel AdcChannel_0 in AdcGroup_1 Group for
 *  AdcConfigSet_0 configuration set
 */
#define AdcConf_AdcConfigSet_0_AdcGroup_AdcGroup_1_AdcChannel_0        (0U)

/**
 *  \brief Symbolic name for channel AdcChannel_1 in AdcGroup_1 Group for
 *  AdcConfigSet_0 configuration set
 */
#define AdcConf_AdcConfigSet_0_AdcGroup_AdcGroup_1_AdcChannel_1        (1U)

/**
 *  \brief Symbolic name for channel AdcChannel_2 in AdcGroup_1 Group for
 *  AdcConfigSet_0 configuration set
 */
#define AdcConf_AdcConfigSet_0_AdcGroup_AdcGroup_1_AdcChannel_2        (2U)

/**
 *  \brief Symbolic name for channel AdcChannel_3 in AdcGroup_1 Group for
 *  AdcConfigSet_0 configuration set
 */
#define AdcConf_AdcConfigSet_0_AdcGroup_AdcGroup_1_AdcChannel_3        (3U)

/**
 *  \brief Symbolic name for channel AdcChannel_4 in AdcGroup_1 Group for
 *  AdcConfigSet_0 configuration set
 */
#define AdcConf_AdcConfigSet_0_AdcGroup_AdcGroup_1_AdcChannel_4        (4U)

/**
 *  \brief Symbolic name for channel AdcChannel_5 in AdcGroup_1 Group for
 *  AdcConfigSet_0 configuration set
 */
#define AdcConf_AdcConfigSet_0_AdcGroup_AdcGroup_1_AdcChannel_5        (5U)

/**
 *  \brief Symbolic name for channel AdcChannel_6 in AdcGroup_1 Group for
 *  AdcConfigSet_0 configuration set
 */
#define AdcConf_AdcConfigSet_0_AdcGroup_AdcGroup_1_AdcChannel_6        (6U)

/**
 *  \brief Symbolic name for channel AdcChannel_7 in AdcGroup_1 Group for
 *  AdcConfigSet_0 configuration set
 */
#define AdcConf_AdcConfigSet_0_AdcGroup_AdcGroup_1_AdcChannel_7        (7U)

/**
 *  \brief Symbolic name for channel AdcChannel_8 in AdcGroup_1 Group for
 *  AdcConfigSet_0 configuration set
 */
#define AdcConf_AdcConfigSet_0_AdcGroup_AdcGroup_1_AdcChannel_8        (8U)

/**
 *  \brief Symbolic name for channel AdcChannel_9 in AdcGroup_1 Group for
 *  AdcConfigSet_0 configuration set
 */
#define AdcConf_AdcConfigSet_0_AdcGroup_AdcGroup_1_AdcChannel_9        (9U)

/**
 *  \brief Symbolic name for channel AdcChannel_10 in AdcGroup_1 Group for
 *  AdcConfigSet_0 configuration set
 */
#define AdcConf_AdcConfigSet_0_AdcGroup_AdcGroup_1_AdcChannel_10        (10U)

/**
 *  \brief Symbolic name for channel AdcChannel_11 in AdcGroup_1 Group for
 *  AdcConfigSet_0 configuration set
 */
#define AdcConf_AdcConfigSet_0_AdcGroup_AdcGroup_1_AdcChannel_11        (11U)

/**
 *  \brief Symbolic name for channel AdcChannel_0 in AdcGroup_2 Group for
 *  AdcConfigSet_0 configuration set
 */
#define AdcConf_AdcConfigSet_0_AdcGroup_AdcGroup_2_AdcChannel_0        (0U)

/**
 *  \brief Symbolic name for channel AdcChannel_1 in AdcGroup_2 Group for
 *  AdcConfigSet_0 configuration set
 */
#define AdcConf_AdcConfigSet_0_AdcGroup_AdcGroup_2_AdcChannel_1        (1U)

/**
 *  \brief Symbolic name for channel AdcChannel_0 in AdcGroup_3 Group for
 *  AdcConfigSet_0 configuration set
 */
#define AdcConf_AdcConfigSet_0_AdcGroup_AdcGroup_3_AdcChannel_0        (0U)

/**
 *  \brief Symbolic name for channel AdcChannel_5 in AdcGroup_3 Group for
 *  AdcConfigSet_0 configuration set
 */
#define AdcConf_AdcConfigSet_0_AdcGroup_AdcGroup_3_AdcChannel_5        (5U)

/**
 *  \brief Symbolic name for channel AdcChannel_7 in AdcGroup_3 Group for
 *  AdcConfigSet_0 configuration set
 */
#define AdcConf_AdcConfigSet_0_AdcGroup_AdcGroup_3_AdcChannel_7        (7U)


/** \brief Channels IDs for all the channels*/

/**
 *  \brief Symbolic name for channel AdcChannel_7 in channel list for
 *  AdcConfigSet_0 configuration set
 */
#define AdcConf_AdcConfigSet_0_AdcChannel_AdcChannel_0      (0U)

/**
 *  \brief Symbolic name for channel AdcChannel_7 in channel list for
 *  AdcConfigSet_0 configuration set
 */
#define AdcConf_AdcConfigSet_0_AdcChannel_AdcChannel_1      (1U)

/**
 *  \brief Symbolic name for channel AdcChannel_7 in channel list for
 *  AdcConfigSet_0 configuration set
 */
#define AdcConf_AdcConfigSet_0_AdcChannel_AdcChannel_2      (2U)

/**
 *  \brief Symbolic name for channel AdcChannel_7 in channel list for
 *  AdcConfigSet_0 configuration set
 */
#define AdcConf_AdcConfigSet_0_AdcChannel_AdcChannel_3      (3U)

/**
 *  \brief Symbolic name for channel AdcChannel_7 in channel list for
 *  AdcConfigSet_0 configuration set
 */
#define AdcConf_AdcConfigSet_0_AdcChannel_AdcChannel_4      (4U)

/**
 *  \brief Symbolic name for channel AdcChannel_7 in channel list for
 *  AdcConfigSet_0 configuration set
 */
#define AdcConf_AdcConfigSet_0_AdcChannel_AdcChannel_5      (5U)

/**
 *  \brief Symbolic name for channel AdcChannel_7 in channel list for
 *  AdcConfigSet_0 configuration set
 */
#define AdcConf_AdcConfigSet_0_AdcChannel_AdcChannel_6      (6U)

/**
 *  \brief Symbolic name for channel AdcChannel_7 in channel list for
 *  AdcConfigSet_0 configuration set
 */
#define AdcConf_AdcConfigSet_0_AdcChannel_AdcChannel_7      (7U)

/**
 *  \brief Symbolic name for channel AdcChannel_7 in channel list for
 *  AdcConfigSet_0 configuration set
 */
#define AdcConf_AdcConfigSet_0_AdcChannel_AdcChannel_8      (8U)

/**
 *  \brief Symbolic name for channel AdcChannel_7 in channel list for
 *  AdcConfigSet_0 configuration set
 */
#define AdcConf_AdcConfigSet_0_AdcChannel_AdcChannel_9      (9U)

/**
 *  \brief Symbolic name for channel AdcChannel_7 in channel list for
 *  AdcConfigSet_0 configuration set
 */
#define AdcConf_AdcConfigSet_0_AdcChannel_AdcChannel_10      (10U)

/**
 *  \brief Symbolic name for channel AdcChannel_7 in channel list for
 *  AdcConfigSet_0 configuration set
 */
#define AdcConf_AdcConfigSet_0_AdcChannel_AdcChannel_11      (11U)



/*
 * All below macros are used for enabling the ISR for a particular hardware.
 */
/** \brief Enable/disable ADC 1 unit ISR */
#define ADC_UNIT_1_ACTIVE (STD_ON)




/** \brief ISR type */
#define ADC_ISR_TYPE                    (ADC_ISR_CAT1)

/** \brief Counter ID for counter used to count wait ticks */
#define ADC_OS_COUNTER_ID               ((CounterType)0U)

/** \brief Enable/disable ADC register read back API */
#define ADC_REGISTER_READBACK_API       (STD_OFF)

/**
*  \brief ADC timeout - used in ADC AFE busy wait and FSM busy wait.
*   Each tick is 31.25us (for 32K Counter). Wait for 1ms which comes to
*   below value
*
*  Max Number of Sample collect : 256
*  Max Time for 256 samples collection : 256 * 16/10MHz = 409.6us
*  Add 10 % margin : 450us
*  Add 550us for skip samples
*  Total timeout: 1ms
*/
#define ADC_TIMEOUT_DURATION            (64U)


/**
 *  \name ADC DEM Error codes to report
 *
 *  Pre-compile switches for enabling/disabling DEM events
 *  @{
 */



#ifndef ADC_E_HARDWARE_ERROR
/** \brief Hardware failed */
#define ADC_E_HARDWARE_ERROR          (DemConf_DemEventParameter_ADC_E_HARDWARE_ERROR)
#endif

/* ========================================================================== */
/*                         Structures and Enums                               */
/* ========================================================================== */

/** \brief ADC Configuration struct declaration */
extern const struct Adc_ConfigType_s AdcConfigSet_0;


/**
 *  \name ADC HW unit Info
 *  @{
 */
/** \brief ADC1 instance */
#define ADC_UNIT_1                      ((Adc_HWUnitType) 0U)
/* @} */

/**
 *  \brief Total HW units - used for array allocation. This should be +1 of the
 *  max unit number
 */
#define ADC_HW_UNIT_CNT                 (1U)

/**
 *  \brief The default channel resolution supported by the current ADC hardware.
 *  No other value is supported by the hardware.
 */
#define ADC_DEF_CHANNEL_RESOLUTION      (10U)

/**
 *  \brief Number of MCAL channels - in terms of ADC HW, this represents the
 *  number of hardware steps.
 *  Note: In terms of ADC IP number of steps is 16.
 *        Due to AUTOSAR specification, the channel ID's should be unique i.e
 *        each channel Id and actual HW channel should have one to one mapping.
 *        So ADC_NUM_CHANNEL is fixed to 12 as number of actual HW channels
 *        available is also 12.
 *
 */
#define ADC_NUM_CHANNEL                 (12U)
/** \brief Minimum value of channel ID */
#define ADC_MIN_CHANNEL_ID              (0U)
/** \brief Maximum value of channel ID */
#define ADC_MAX_CHANNEL_ID              (ADC_NUM_CHANNEL - 1U)

/**
 *  \brief Number of actual HW channels - in terms of ADC HW, this represents
 *  the actual channel input to the ADC module.
 *  Note: This is a fixed value as per the ADC module and can't be changed.
 */
#define ADC_NUM_HW_CHANNEL              (12U)
/** \brief Minimum value of HW channel ID */
#define ADC_MIN_HW_CHANNEL_ID           (0U)
/** \brief Maximum value of HW channel ID */
#define ADC_MAX_HW_CHANNEL_ID           (ADC_NUM_HW_CHANNEL - 1U)

#define ADC_MIN_RANGE                   (0x00U)
/** \brief Maximum value of range */
#define ADC_MAX_RANGE                   (0x3FFU)

/*
 *Design: MCAL-14594
 */
typedef uint8   Adc_ChannelType;

/** \brief Numeric ID of an ADC channel group */
/*
 * Design: MCAL-14595
 */
typedef uint8   Adc_GroupType;

/**
 * \brief Type for reading the converted values of a channel group (raw,
 *  without further scaling, right aligned).
 *
 *  Note: Even though the resolution for this ADC HW is 10-bit, we set this
 *  to 32-bit integer as the register read access is 32-bit.
 */
/*
 * Design: MCAL-14596
 */
typedef uint32  Adc_ValueGroupType;

/** \brief Type of clock prescaler factor. */
/*
 * Design: MCAL-14603
 */
typedef uint32  Adc_PrescaleType;

/**
 *  \brief Type of conversion time, i.e. the time during which the sampled
 *  analogue value is converted into digital representation.
 */
/*
 * Design: MCAL-14606
 */
typedef uint16  Adc_ConversionTimeType;

/**
 *  \brief Type of sampling time, i.e. the time during which the value is
 *  sampled (in clockcycles).
 */
/*
 * Design: MCAL-14610
 */
typedef uint16  Adc_SamplingTimeType;

/** \brief Type of channel resolution in number of bits. */
/*
 * Design: MCAL-14616
 */
typedef uint8   Adc_ResolutionType;

/** \brief Priority level of the channel. Lowest priority is 0. */
/*
 * Design: MCAL-14620
 */
typedef uint8   Adc_GroupPriorityType;

/** \brief Type of assignment of channels to a channel group. */
/*
 * Design: MCAL-14621
 */
typedef uint8  Adc_GroupDefType;

/**
 *  \brief Type for configuring the number of group conversions in streaming
 *   access mode (in single access mode, parameter is 1).
 */
/*
 * Design: MCAL-14622
 */
typedef uint16  Adc_StreamNumSampleType;

/** \brief Type for the value of the ADC module embedded timer. */
/*
 * Design: MCAL-14626
 */
typedef uint8   Adc_HwTriggerTimerType;

/**
 *  \brief Specifies the identification (ID) for a ADC Hardware microcontroller
 *  peripheral (unit)
 */
typedef uint8   Adc_HWUnitType;

/**
 *  \addtogroup MCAL_ADC_CFG ADC Configuration
 *  @{
 */

/** \brief Typedef for group end notification function pointer */
typedef P2FUNC(void, ADC_APPL_CODE, Adc_GroupEndNotifyType)(void);

/**
 *  \brief Current status of the conversion of the requested ADC Channel group
 */
/*
 * Design: MCAL-14617
 */
typedef enum
{
    ADC_IDLE,
    /**< The conversion of the specified group has not been started.
     *   No result is available */
    ADC_BUSY,
    /**< The conversion of the specified group has been started and is still
     *   going on. So far no result is available */
    ADC_COMPLETED,
    /**< A conversion round (which is not the final one) of the specified group
     *  has been finished. A result is available for all channels of the
     *  group */
    ADC_STREAM_COMPLETED
    /**< The result buffer is completely filled. For each channel of the
     *   selected group the number of samples to be acquired is available */
    /**< This state is not supported in the ar1xxx ADC Driver as only one
     *   shot access mode is used. */
} Adc_StatusType;

/**
 *  \brief Type for configuring the trigger source for an ADC Channel group
 *
 *  Note: Only ADC_TRIGG_SRC_SW is supported in the ar1xxx ADC Driver.
 */
/*
 * Design: MCAL-14618
 */
typedef enum
{
    ADC_TRIGG_SRC_SW,
    /**< Group is triggered by a software API call */
    ADC_TRIGG_SRC_HW
    /**< Group is triggered by a hardware event
     *   Note: This feature is not supported in the AWR1XXX ADC hardware */
} Adc_TriggerSourceType;

/**
 *  \brief Type for configuring the conversion mode of an ADC Channel group
 *
 *  Note: only one shot mode is supported in the ar1xxx ADC Driver.
 */
/*
 * Design: MCAL-14619
 */
typedef enum
{
    ADC_CONV_MODE_ONESHOT,
    /**< Exactly one conversion of each channel in an ADC channel group is
     *   performed after the configured trigger event */
    ADC_CONV_MODE_CONTINUOUS
    /**< Repeated conversions of each ADC channel in an ADC channel
     *   group are performed
     *  Note: This feature is not supported in the AWR1XXX ADC hardware */
} Adc_GroupConvModeType;

/**
 *  \brief Type for configuring the streaming access mode buffer type
 *
 *  Note: This feature is not supported in the awr1xxx ADC Driver.
 */
/*
 * Design: MCAL-14623
 */
typedef enum
{
    ADC_STREAM_BUFFER_LINEAR,
    /**< The ADC Driver stops the conversion as soon as the stream buffer
     *   is full (number of samples reached) */
    ADC_STREAM_BUFFER_CIRCULAR
    /**< The ADC Driver continues the conversion even if the stream buffer is
     *   full (number of samples reached) by wrapping around the stream buffer
     *   itself */
} Adc_StreamBufferModeType;

/**
 *  \brief Type for configuring the access mode to group conversion results
 *
 *   Note: ar1xxx ADC Driver only supports ADC_ACCESS_MODE_SINGLE in
 *         one-shot mode.
 */
/*
 * Design: MCAL-14624
 */
typedef enum
{
    ADC_ACCESS_MODE_SINGLE,
    /**< Single value access mode */
    ADC_ACCESS_MODE_STREAMING
    /**< Streaming access mode */
} Adc_GroupAccessModeType;

/**
 *  \brief Interrupt Mode or Polling Mode
 *  for monitoring ADC conversion done status
 *
 */
/* Requirements :  */
typedef enum
{
    ADC_INTERRUPT_MODE,
    /**< Interrupt for channel conversion done */
	ADC_POLLING_MODE
    /**< Poll for channel conversion done */
} Adc_HwUnitMonitorModeType;

/**
 *  \brief Type for configuring on which edge of the hardware trigger signal
 *  the driver should react, i.e. start the conversion.
 *
 *  Note: This feature is not supported in the ar1xxx ADC Driver.
 */
/*
 * Design: MCAL-14625
 */
typedef enum
{
    ADC_HW_TRIG_RISING_EDGE,
    /**< React on the rising edge of the hardware trigger signal */
    ADC_HW_TRIG_FALLING_EDGE,
    /**< React on the falling edge of the hardware trigger signal */
    ADC_HW_TRIG_BOTH_EDGES
    /**< React on both edges of the hardware trigger signal */
} Adc_HwTriggerSignalType;

/**
 *  \brief Type for configuring the prioritization mechanism.
 *
 *   Note: ar1xxx ADC Driver doesn't support priority mechanism, so
 *         ADC_PRIORITY_NONE should be selected.
 */
/*
 * Design: MCAL-14627
 */
typedef enum
{
    ADC_PRIORITY_NONE,
    /**< Priority mechanism is not available */
    ADC_PRIORITY_HW,
    /**< Hardware priority mechanism is available only */
    ADC_PRIORITY_HW_SW
    /**< Hardware and software priority mechanism is available */
} Adc_PriorityImplementationType;

/**
 *  \brief Replacement mechanism, which is used on ADC group level, if a group
 *  conversion is interrupted by a group which has a higher priority.
 *
 *   Note: ar1xxx ADC Driver doesn't support priority mechanism so this
 *         feature is not used in the driver.
 */
/*
 * Design: MCAL-14628
 */
typedef enum
{
    ADC_GROUP_REPL_ABORT_RESTART,
    /**< Abort/Restart mechanism is used on group level, if a group is
     *   interrupted by a higher priority group */
    ADC_GROUP_REPL_SUSPEND_RESUME,
    /**< Suspend/Resume mechanism is used on group level, if a group is
     *   interrupted by a higher priority group.
     *   Note: The implementation is same as abort/restart i.e. when a group
     *   is started again, previous intermediate results are discarded and
     *   the driver always starts from first channel of the group */
} Adc_GroupReplacementType;

/**
 *  \brief In case of active limit checking: defines which conversion values
 *  are taken into account related to the boardes defined with
 *  AdcChannelLowLimit and AdcChannelHighLimit.
 *
 *  Note: This feature is not supported.
 */
/*
 * Design: MCAL-14629
 */
typedef enum
{
    ADC_RANGE_UNDER_LOW,
    /**< Range below low limit - low limit value included */
    ADC_RANGE_BETWEEN,
    /**< Range between low limit and high limit - high limit value included */
    ADC_RANGE_OVER_HIGH,
    /**< Range above high limit */
    ADC_RANGE_ALWAYS,
    /**< Complete range - independent from channel limit settings */
    ADC_RANGE_NOT_UNDER_LOW,
    /**< Range above low limit */
    ADC_RANGE_NOT_BETWEEN,
    /**< Range above high limit or below low limit - low limit value included */
    ADC_RANGE_NOT_OVER_HIGH
    /**< Range below high limit - high limit value included */
} Adc_ChannelRangeSelectType;

/**
 *  \brief Type for alignment of ADC raw results in ADC result buffer
 *  (left/right alignment).
 */
/* Requirements :  */
typedef enum
{
    ADC_ALIGN_LEFT,
    /**< Left alignment.
     *   Note: This feature is not supported in this driver */
    ADC_ALIGN_RIGHT
    /**< Right alignment */
} Adc_ResultAlignmentType;

/**
 *  \brief Power state currently active or set as target power state.
 */
/*
 * Design: MCAL-14631
 */
typedef enum
{
    ADC_FULL_POWER,
    /**< Full Power (0) */
    ADC_ZERO_POWER
    /**< Power modes with decreasing power consumptions */
} Adc_PowerStateType;

/**
 *  \brief Result of the requests related to power state transitions.
 */
/*
 * Design: MCAL-14634
 */
typedef enum
{
    ADC_SERVICE_ACCEPTED,
    /**< Power state change executed */
    ADC_NOT_INIT,
    /**< ADC Module not initialized */
    ADC_SEQUENCE_ERROR,
    /**< Wrong API call sequence */
    ADC_HW_FAILURE,
    /**< The HW module has a failure which prevents it to enter the required
     *   power state */
    ADC_POWER_STATE_NOT_SUPP,
    /**< ADC Module does not support the requested power state */
    ADC_TRANS_NOT_POSSIBLE,
    /**< ADC Module cannot transition directly from the current power state
     *   to the requested power state or the HW peripheral is still busy */
} Adc_PowerStateRequestResultType;

/**
* \brief  Structure containing parameters for ADC MCAL channel configuration.
*         In term of ADC hardware, this represents the step configuration.
*         There are ADC_NUM_CHANNEL steps in the ADC hardware and each step
*         could be mapped to an actual hardware input channel.
*/
typedef struct
{
    Adc_ChannelType            hwChannelId;
    /**< The hardware channel number from which input is given.
     *   Valid values: ADC_MIN_HW_CHANNEL_ID to ADC_MAX_HW_CHANNEL_ID
     *   0x0 = Channel 1
     *   0x1 = Channel 2
     *   0x2 = Channel 3
     *   0x3 = Channel 4
     *   0x4 = Channel 5
     *   0x5 = Channel 6
     *   0x6 = Channel 7
     *   0x7 = Channel 8
     *   0x8 = Channel 9
     *   0x9 = Dig DSP Temp Sensor
     *   0xA = Dig HWA Temp Sensor
     *   0xB = Dig HSM Temp Sensor
     */
    uint8 settlingTime;
    /* in unit of 100ns = CollectSamples*16 + SkipSamples */


    boolean isConfigured;
    /**< GPADC driver considers channels configuration passed to the
     *   driver by the application only if this flag is set
     *   TRUE: Channel Configured for channelID,
     *   FALSE: Channel is not configured
     */


    uint32 channelConfigValue;
    /**< Unique muxing config value per channel
     */

    uint32 channelParamValue;
    /**< Channel parameters including channel paramVal(subsystem-type), collect samples
     *    and skip samples
     */

    uint32 skipSamples;
    /**< Number of samples to be skipped before collecting samples per
     *   input channel
     */


    uint8 collectSamples;
    /**< Number of samples to be collected for conversion per each input channel
     */

    boolean useLuTable;
    /**<  TRUE: Use predefined lookup table to load number of skipSamples and collectSamples
     *    configuration for the specific input channel.
     *
     *   FALSE: Use skipSamples and collectSamples configuration from the data
     *   structure passed by the application for each configured channel
     */

    boolean isBufferedMode;
    /* TRUE: buffered mode FALSE: non-buffered mode */

} Adc_ChannelConfigType;

/**
 *  \brief ADC Group configuration structure.
 */
/*
 *Design: MCAL-14593, MCAL-14832, MCAL-14837, MCAL-14838, MCAL-14839, MCAL-14840, MCAL-14842
 */
typedef struct
{
    Adc_GroupType                   groupId;
    /**< Group ID - This should be same as that of the index in to the
     *   groupCfg[] array */
    Adc_GroupPriorityType           groupPriority;
    /**< Group priority */
    Adc_HWUnitType                  hwUnitId;
    /**< HWUnit associated with this group */
    Adc_GroupEndNotifyType          Adc_GroupEndNotification;
    /**< Group end notification callback fxn pointer */
    Adc_ResolutionType              resolution;
    /**< Group resolution - This is not configurable and should be set to
     *   ADC_DEF_CHANNEL_RESOLUTION */

    Adc_GroupConvModeType           convMode;
    /**< Operation mode of the group */
    /**< Note: Only one shot mode is supported */
    Adc_TriggerSourceType           triggSrc;
    /**< Determines the trigger source (hw or sw trigger).
     *   Note: Only SW trigger is supported */
    Adc_GroupAccessModeType         accessMode;
    /**< Defines the type of the groups buffer */
    /**< Note: Only one shot access mode is supported */
    Adc_GroupReplacementType        groupReplacement;
    /**< Group replacement logic when priority mechanism is ON - i.e
     *   prioritySupport is not ADC_PRIORITY_NONE. */
    uint32                          numChannels;
    /**< Number of channels in this group */
    Adc_GroupDefType                           hwChannelID[ADC_NUM_CHANNEL];
    /**< Channel (HW step) configuration. numChannels elements should be
     *   initialized */
} Adc_GroupConfigType;

/**
 *  \brief ADC Hardware unit configuration structure.
 */
typedef struct
{
    Adc_HWUnitType      hwUnitId;
    /**< ADC HW unit to use */

    Adc_HwUnitMonitorModeType hwUnitMonitorMode;
    /**< ADC HW interrupt mode/ polling mode */
} Adc_HwUnitConfigType;

#if (STD_ON == ADC_REGISTER_READBACK_API)
/**
 *  \brief ADC register readback structure
 *
 */
typedef struct
{

    /**< IP revision identifier */
    uint16      adcCtrl1;
    uint16      adcCtrl2;
    /**< Control Register */

} Adc_RegisterReadbackType;
#endif  /* #if (STD_ON == ADC_REGISTER_READBACK_API) */

/**
 *  \brief ADC config structure
 */
/* Requirements : MCAL-14593, SWS_Adc_00138 */
/*
 *Design: MCAL-14593
 */
typedef struct Adc_ConfigType_s
{
    uint8                   maxGroup;
    /**< Maximum number of group
     *   Should not be more than ADC_MAX_GROUP */
    uint8                   maxHwUnit;

    uint8                   maxChannel;
    /**< Channel configurations */
    Adc_ChannelConfigType   channelConfig[ADC_NUM_CHANNEL];
    /**< Maximum number of HW unit
     *   Should not be more than ADC_MAX_HW_UNIT */
    Adc_GroupConfigType     groupCfg[ADC_MAX_GROUP];
    /**< Group configurations */
    Adc_HwUnitConfigType    hwUnitCfg[ADC_MAX_HW_UNIT];
    /**< HW Unit configurations */

} Adc_ConfigType;

/*! \brief
* The Temperature sensor values structure
*/
typedef struct
{
   sint16     DigDspTempValue;
   /**< Calculated temperature value of digital DSP temp sensor */

   sint16     DigHwaTempValue;
   /**< Calculated temperature value of digital HWA temp sensor */

   sint16     DigHsmTempValue;
   /**< Calculated temperature value of digital HSM temp sensor */

} Adc_TempSensValueType;

/* ========================================================================== */
/*                          Function Declarations                             */
/* ========================================================================== */

/**
 *  \brief Type for GetCounterValue CB function
 */
typedef StatusType (*GetCounterValueCBType)(CounterType CounterID, TickRefType Value);

/**
 *  \brief Type for GetElapsedValue CB function
 */
typedef StatusType (*GetElapsedValueCBType)(CounterType CounterID, TickRefType Value, TickRefType ElapsedValue);

/**
 *  \brief Get Counter value for Adc
 */
StatusType GetCounterValueWrapper(CounterType CounterID, TickRefType Value);

/**
 *  \brief Get elapsed value for Adc
 */
StatusType GetElapsedValueWrapper(CounterType CounterID, TickRefType Value, TickRefType ElapsedValue);

#ifdef __cplusplus
}
#endif

#endif  /* #ifndef ADC_CFG_H_ */

/* @} */
