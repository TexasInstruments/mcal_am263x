# AUTOSAR Integration Guide

## Introduction

MCAL and CDD drivers offered by TI are compatible with AUTOSAR basic software provided by different AUTOSAR vendors.
These drivers are specific to MCU hardware and work as abstraction layer which makes rest of BSW independent of MCAL.
The intention of this document is to provide information on integrating TI MCALs/CDDs to AUTOSAR BSW provided by different vendors to ensure smooth interfacing.

## How to use TI MCAL with Vector Stack

This chapter explains how TI MCAL can be integrated into Vector stack with respect to different use cases.

### Board Bring-up with Vector's startup code

#### Objective for Board Bring-up

The intention of this use case is to bring the program flow at the start of application, perform the startup activities such as but not limited to initialization of Interrupt Vector Table, Exception Vector Table, initialization of data, initialization of default clocks etc. This is achieved by integrating Vector startup code and Vector stack. Vector startup code has some dependencies on TI SDK which are explained in detail in subsequent chapter.
Further, the required BSW modules are initialized and periodic scheduling is started via OS and RTE.

#### List of Modules

##### Vector Modules

| Sl. No. | Vector Modules | Description | Significance in use case |
|----|--------|----------|----|
|1| EcuC (Autosar EcuC module), <br> vSet (Vector Common Settings module)| EcuC and vSet are virtual modules that collect the global and ECU specific configuration information. | In this use case, this module is necessary to provide the partition and core information <br> along with default global configurations for ECU.|
|2| vBaseEnv (Vector Base Environment), <br> vBRS (Vector Basic Runtime System) | These modules together constitute Vector startup code that provide basic hardware setup options <br> such as memory init, PLL init, Port init and Watchdog init etc. in order to set up the environment <br> for cyclic runtime behavior. These modules can be configured to select which of its features shall <br> be enabled and executed during startup to setup the environment based on use case.| In this use case, these modules are used to initialize memory, interrupt vector tables, exception vector tables. <br> It initializes OS and EcuM and hands over control to EcuM for further processing|
|3| vLinkGen (Vector Linkers-script Generator) | The MICROSAR linker script generator provides a way to create a linker file in order to place the <br> code, constants and data in intended memory location.| In this use case, this module is used to setup the application entry point, IVT etc. |
|4| OS (MICROSAR Operating System)| The Operating System is mainly responsible for handling of tasks and interrupts.| In this use case, it used to define a periodic task. |
|5| Rte (MICROSAR Runtime Environment) | The Runtime Environment module manages the information flow between <br> Software Components (SWCs), BSW and CDDs.|In this use case, it is used to schedule the periodic task defined in OS. |
|6| EcuM (MICROSAR Ecu State Manager) | The Ecu State Manager starts/stops OS, SchM, BswM and other BSW modules. <br> It is responsible for startup, shutdown, sleep modes and wakeup sources of the ECU. |In this use case, it used to start/stop OS and scheduler.|

```{Note}
For detailed information on each module and its features, please refer to the Technical Reference Manual provided by Vector for each of these modules
```

##### TI SDK

Vector startup code requires some low level functions that can interact directly with hardware e.g. to setup the interrupt vector table and interrupt controller, to set the clock etc. These kind of low level functions can be take from TI Software Development Kit (SDK).

SDK : [MCU-PLUS-SDK-AM263](https://www.ti.com/tool/MCU-PLUS-SDK-AM263X)

From downloaded SDK package copy following to your workspace -

| Sl. No. | TI Modules | Description |
|----|--------|----------|
|1.|kernel | Include all the headers files from path {sdk_installation_dir}/source/kernel |
|2.|drivers | Include all the headers files from path {sdk_installation_dir}/source/drivers |

#### Configuration of modules in Board Bring-up

This chapter explains the minimum configurations that must be applied on top of the default configuration for each module, to realize this use case:

##### EcuC

This module contains the information of different partitions on each core. For this use case, we only require one partition on one core to run the OS. This partition is configured as below -

```{figure} Assets/images/fig19MicroMentionInEcuc.png
:alt: Microcontroller mentioned in the vBaseEnvDerivativeInformation
:align: center

EcuC Module Configuration
```

Configure the ASIL level as per the requirement. For this use case, ASIL Level is configured as QM.

##### vBaseEnv and vBRS

In vBaseEnv module the derivative of MCU being used is selected as shown below. Once this derivative is selected all MCU specific information is automatically set -

```{figure} Assets/images/fig19MicroMentionInVbaseEnv1.png
:alt: Microcontroller mentioned in the vBaseEnvDerivativeInformation
:align: center

Microcontroller mentioned in the vBaseEnvDerivativeInformation
```

```{figure} Assets/images/fig19MicroMentionInVbaseEnv.png
:alt: Microcontroller mentioned in the vBaseEnvDerivativeInformation
:align: center

Microcontroller mentioned in the vBaseEnvDerivativeInformation
```

vBRS module is configured to enable features offered by startup code that are needed for this use case.
The default configuration settings offered by vBRS are enough to achieve this use case.
In this use case, we configure the vBRS to set the application entry point, clock frequencies, define the user code for make support, define the initialization pattern for data etc.
Please ensure that configurations shown in below screenshots are intact:

As this use case is an application category, execution instance is selected as Application -

```{figure} Assets/images/fig20vBrsGen.png
:alt: vBRSGeneral Configuration
:align: center

vBRSGeneral Configuration
```

##### vLinkGen

vLinkGen configurations are done to generate a linker script that will store data/code/constants in desired memory location.
By default vLinkGen will populate some variable/constant groups and memory regions based on other configured modules.
The mandatory parameters in the default configurations shall be updated with the help of TechnicalReference_vLinkGen.
To define the entry point to vector startup code, you add the entry point in generated linker file as shown below:

--entry_point=intvect_CoreExceptions             /*ENTRY POINT*/

The entry point can be defined in multiple ways:
The option --entry_point can be set to either intvect_CoreException OR _start in linker file. When entry point is set to intvect_CoreExceptions, the program counter points to the start of interrupt vector table after reset vector. Entry point is set to _start only when using debugger to preset the start address. In this use case we use the entry_point as intvect_CoreExceptions.

If the entry point is not set in linker file, then the default entry point (_cinit) is used, which uses a compiler based startup code instead of vector startup code -

```{figure} Assets/images/fig25CINT.png
:alt: CINIT memory section configuration
:align: center

CINIT memory section configuration
```

```{Note}
 entry_point generation is not supported in the current Vector package. Hence, the â€“entry_point needs to be set to intvect_CoreExceptions in the linker file manually.
```

For details about vLinkGen configuration please refer Vector document TechnicalReference_vLinkGen.

##### OS

To achieve an OS task with 10 ms as the period. The following are the main parameters to be configured in OS module. Task Period should be 0.01s in OS tasks container. Which is shown in the below figure -

```{figure} Assets/images/fig27OsCounter.png
:alt: Os_Task_10ms configuration
:align: center

Counter configuration
```

Default auto-start tasks are created as shown below. These tasks participate in startup process. The default definition of task is present in startup code. For this use case, it is used as-is, however it can be modified as need be -

```{figure} Assets/images/fig27OsAutoStart.png
:alt: Auto-start task configuration
:align: center

Auto start task configuration1
```

```{figure} Assets/images/fig27OsAutoStart1.png
:alt: Auto-start task configuration
:align: center

Auto start task configuration2
```

Then we can configure a periodic task (10 ms) as shown below. This task is used to schedule the periodic runnable. In this use case, there is only one BSW module with a schedulable periodic runnable, which is EcuM -

```{figure} Assets/images/fig27OsTask10ms.png
:alt: Auto-start task configuration
:align: center

10 ms task configuration
```

##### Rte

ECUM main function is mapped to 10ms task and position is given as shown. Importance of position parameter come into picture if more than more function is mapped in the TASK. Position parameter determines which mapped function will execute first within the particular task -

```{figure} Assets/images/fig28MappingECUm.png
:alt: Mapping of EcuM main function
:align: center

Mapping of EcuM main function
```

Thus, the Rte generates the mapping of the runnable to the task.

##### EcuM

In this use case, EcuM is used to start the OS and scheduler via EcuM_Init and EcuM_StartupTwo function calls in startup code. It also manages all the wakeup events associated with ECU. The mandatory configurations related to wakeup/sleep can be updated as shown below, however wakeup scenario is not part of this use case -

```{figure} Assets/images/fig29MCUmode.png
:alt: MCU mode setting of EcuM
:align: center

MCU mode setting of EcuM
```

```{figure} Assets/images/fig30OsResourceAddedin.png
:alt: OsResource added in the OS module is mapped in EcuM.
:align: center

OsResource added in the OS module is mapped in EcuM.
```

```{Note}
 Reference to Mcu Mode Setting Configuration is provided as placeholder because it is a mandatory parameter. This configuration is not used in this use case. Any MCU module definition can be used as reference. (e.g. Autosar standard definition of MCU already available in Vector Modules list).
```

### Importing TI MCAL modules from EB Tresos to Vector DaVinci Configurator

#### Objective

The TI MCAL modules are configured using EB Tresos tool. When Vector DaVinci Configurator is used for BSW stack configuration, we may require to import the MCAL modules to DaVinci Configurator so that Vector modules can have reference to MCAL modules e.g. The clock references from MCU module may be required by other module to derive their own clock. This chapter explains how TI MCAL modules can be imported to Vector DaVinci Configurator.

#### Files required for import

1.Export of MCAL from EB Tresos (ARXML): The MCAL modules can be exported from EB Tresos into an ARXML file as instructed in [Run Export](./MCAL_Configuration_and_EB_Tresos.md#run-export). This ARXML contains ECU configuration of MCAL modules.
2.Vendor Specific Module Definition (ARXML): TI defines Vendor Specific Module Definition for each MCAL module based on AUTOSAR Standard Module definition. This file is needed by Vector DaVinci Configurator to understand the parameters in MCAL modules. This ARXML file can be found as given in [Module Plugin Directory Structure](./MCAL_Configuration_and_EB_Tresos.md#module-plugin-directory-structure).
3.BSW Module Description File (ARXML): The BSWMD is a formal notation of all information belonging to a certain BSW module in addition to the implementation of the artifact. Each MCAL module generates it's BSWMD file. Please refer [Generate BSWMD](./MCAL_Configuration_and_EB_Tresos.md#generate-bswmd) for details.

#### Steps to import

1.Provide the path of Vendor Specific Module Definition (ARXML) and BSW Module Description File (ARXML) in Additional Definitions settings in DaVinci project settings as shown below -

```{figure} Assets/images/Davinci_Project_Setting.png
:alt: Additional Definition Settings
:align: center
Additional Definition Settings
```

2.Import the MCAL Module Export from EB Tresos, e.g. -

```{figure} Assets/images/Importing_the_MCAL_Module.png
:alt: Importing MCAL module from EB Tresos
:align: center
Importing MCAL module from EB Tresos
```

3.Provide the path of ARXML export of MCAL modules from EB Tresos, e.g. -

```{figure} Assets/images/Path_ARXML_MCAL_module.png
:alt: Import File Selection
:align: center
Import File Selection
```

4.Select the MCAL modules to be imported. If there are any stubs/unwanted modules in export, they can be deselected -

```{figure} Assets/images/Module_Selection.png
:alt: Import MCAL module Selection
:align: center
Import MCAL module Selection
```

5.The imported modules can be seen in DaVinci Configurator as shown below -

```{figure} Assets/images/Imported_Modules.png
:alt: DaVinci Basic Editor View
:align: center
DaVinci Basic Editor View
```

6.As shown in below image, the TI MCAL driver and it's vendor specific module definition file are mapped to the respective driver -

```{figure} Assets/images/Import_final.png
:alt: DaVinci Basic Editor View
:align: center
DaVinci Basic Editor View
```

```{Note}
 This import of MCAL modules to DaVinci configurator is only for reference to other modules. The MCAL modules can't be updated/generated from DaVinci configurator.
```

### CAN Integration

#### Objective for CAN Integration

The intention of CAN Integration is to have successful CAN communication by configuring TI MCAL modules along with Vector BSW Modules. Further details are explained in the subsequent chapter.

#### List Of Modules for CAN

##### MCAL Modules for CAN Integration

| Sl. No. | MCAL Modules | Description | Significance in use case |
|----|--------|----------|----|
|1| CAN Driver | The CAN module initializes and controls the internal CAN Controllers of the microcontroller. It provides services to write, read, and configure mailboxes of the CAN controllers. |In this use case , this module is responsible for configuring the CAN hardware unit, hardware mailboxes, scheduled functions etc.|
|2| Mcu| The MCU module manages microcontroller features such as power modes, clock settings, and interrupts. |In this use case, this module is responsible for providing the clock for CAN communication. |
|3| Port | The PORT module provides an interface to configure and control microcontroller pins (e.g., GPIO, ADC, PWM). | In this use case, this module is responsible for configuring the hardware pins necessary for CAN communication. |

```{Note}
For detailed information, please refer to the section [CAN Module](./Module_User_Guide_Can.md#can-module).
```

##### Vector Modules for CAN Integration

| Sl. No. | Vector Modules | Description | Significance in use case |
|----|--------|----------|----|
|1| EcuC (Autosar EcuC module)| EcuC is a virtual module that collect the global and ECU specific configuration information. | In this use case, this module is necessary to provide the partition and core information <br> along with default global configurations for ECU.|
|2| CanIf | The CanIf module provides an interface between the CAN driver and upper layers. It handles message transmission and reception, manages hardware object, and offers error handling.|In this use case, CanIf module mainly acts as interface between CAN driver and upper layers of communication stack, configures transmit/receive hardware objects etc.|
|3| PduR | PduR routes protocol data units between communication modules and ensures that the correct Pdus are transmitted to the appropriate destination.| In this use case, PduR module handles the routing of Pdus to and from Com layer and CAN driver. |
|4| Com | Com is responsible to provide a signal-based interface to the upper layer. It handles signal conversion, transmission and reception.|In this use case, Com module handles packing of AUTOSAR signals to I-Pdus to be transmitted and unpacking of received I-Pdus.|
|5| CanSM | The CAN State Manager (CanSM) realizes a software layer between the Communication Manager (ComM) and the CAN Interface (CanIf). The CanSM handles the startup and shutdown of the communication of a CAN network. The CAN State Manager maps the CAN State Manager states to the states of the ComM and causes the necessary actions to change the CAN State Manager state to those requested by the ComM. | In this use case, CanSM module manages the state transitions of the CAN controller, mainly from NO COMMUNICATION to FULL COMMUNICATION.|
|6| ComM | The Communication Manager is a resource manager, which encapsulates the control of the underlying communication services. It controls more than one communication bus channel of an ECU by implementing a channel state machine for every channel.|In this use case, ComM provides a mechanism for users to request communication modes, coordinating requests from multiple independent users.|
|7| OS (MICROSAR Operating System)| The Operating System is mainly responsible for handling tasks and interrupts.|In this use case, OS module is used to define periodic tasks needed for CAN communication such as processing transmit and receive message. |
|8| RTE (MICROSAR Runtime Environment) | The Runtime Environment module manages the information flow between Software Components (SWCs), BSW and CDDs.|In this use case, Rte module is used to schedule the periodic tasks defined in the operating system (OS) and sender receiver ports created for sending receiving CAN messages from application. |
|9| DET | The DET is used in order to report development errors. The DET can be replaced optionally by an equivalent component which is responsible for recognizing development errors, if no DET component is available.|In this use Case, Development error is enabled to detect all development errors.|

```{Note}
 For detailed information on each module and its features, please refer to the Technical Reference Manual provided by Vector.
```

```{Note}
 For importing MCAL configuration files to DaVinci refer [Importing TI MCAL modules from EB Tresos to Vector DaVinci Configurator](./Integration.md#importing-ti-mcal-modules-from-eb-tresos-to-vector-davinci-configurator).
```

#### Configuration of modules in CAN Integration

This chapter explains the basic configurations that are needed to realize CAN communication.

##### CAN Configuration

TI CAN driver is configured using EB Tresos tool. It is then imported to Vector DaVinci configurator for integration with CAN stack. Following containers and parameters shall be configured.

**CanController:**

The CanController container defines the configuration parameters for individual CAN controllers within hardware. It manages essential settings like baud rate, timing segments, and hardware addressing, ensuring proper communication between the CAN bus and the application layer. The following figure shows the configuration of MCAN4 with CAN Bus off and CAN Reception/Transmission in polling mode -

```{figure} Assets/images/Can_controller.png
:alt: CAN Controller configuration.
:align: center

CAN Controller configuration.
```

Configuration of CAN controller with 1000kbps of baudrate is shown below -

```{figure} Assets/images/Can_controllerBaudrate.png
:alt: Configuration of CANcontrollerBaudrate
:align: center

Configuration of CANcontrollerBaudrate
```

**CANHwObject:**

The CANHwObject container configures hardware objects (HOHs) used for transmitting and receiving CAN messages. It defines the type, direction, and identifier settings for each hardware object, ensuring proper handling of CAN message.

The configuration of a transmitting CAN signal with basic standard Id is shown below -

```{figure} Assets/images/Can_HwObjectType.png
:alt: CAN message configuration
:align: center

CAN message configuration
```

**CANHwFilter:**

The CANHwFilter container defines the hardware based message filtering mechanism for received CAN message. It ensures that only relevant messages matching a specified identifier pattern are accepted, reducing the load on the CPU.

The configuration of CAN signal Id filter which will be able to accept a CAN message of ID 0x9A(154) and mask code is shown below -

```{figure} Assets/images/Can_HwFilter.png
:alt: Configuration for CAN_HwFilter
:align: center

Configuration for CAN_HwFilter
```

```{Note}
CAN driver doesn't support Sleep / Wakeup modes and ICOM functionality, hence the related parameters like partial networking shall not be configured in BSW modules.
```

##### MCU Configuration

The CAN module has dependencies on MCU module to provide the CAN clock setting reference.
The MCU clock configuration for CAN controller is shown below -

```{figure} Assets/images/Mcu_ClockSettingConfig.png
:alt: Configuration of McuClockSettingconfig
:align: center
Configuration of McuClockSettingconfig
```

CAN clock should be derived from MCU clock reference point. The configuration for clock reference point is shown below -

```{figure} Assets/images/Mcu_ClockReferencePoint.png
:alt: Configuration for Mcu_ClockReferencePoint
:align: center

Configuration for Mcu_ClockReferencePoint
```

##### Port Configuration in CAN Module

CAN module has dependency on Port module to configure transmit, receive, standby and enable pins of hardware. Configuration of receive pin is as shown below -

```{figure} Assets/images/Port_Can.png
:alt: Port Pin Configuration for CAN module
:align: center

Port Pin Configuration for CAN module
```

##### EcuC Configuration in CAN Module

EcuC is a virtual module to collect ECU Configuration specific global configuration information. EcuCPduCollection container collects all the Pdus flowing through the COM Stack as shown below -

```{figure} Assets/images/CanEcuCPduCollection.png
:alt: EcuC Pdu Collection
:align: center

EcuC Pdu Collection
```

##### CanIf Configuration in CAN Module

CanIf module abstracts the CAN driver from the rest of the CAN stack. CAN driver and dependent MCAL modules must be imported to Vector DaVinci configurator before configuring Vector modules.

CanIf configures transmit and receive Pdus.

For a transmit message:

**CanIfHthCfgs:**

Hardware Transmit Handle shall be configured which is shown in below figure. It contains the reference to CAN controller and HTH object in the CAN driver module configuration -

```{figure} Assets/images/CANReferrence.png
:alt: Reference from TI's MCAL module imported in DaVinci
:align: center

Reference from TI's MCAL module imported in DaVinci
```

From the available reference, CAN Controller and HTH object shall be selected as shown below -

```{figure} Assets/images/CanIf_HthCfgs.png
:alt: Configuration for CanIfHthCfgs
:align: center

Configuration for CanIfHthCfgs
```

**CanIfTxPduCfgs:**

CanIf Tx Pdu container contains the configuration (parameters) of a transmit CAN L-Pdu. CanIf Tx Pdu configuration is shown below -

```{figure} Assets/images/CanIf_TxPduCfgs.png
:alt: Configuration for CanIfTxPduCfgs
:align: center

Configuration for CanIfTxPduCfgs
```

**CANIfBufferCfgs:**

CANIfBufferCfgs container contains the Tx-buffer configuration. Multiple buffers with different sizes could be configured. CANIfBufferCfgs configuration is shown below -

```{figure} Assets/images/CanIf_BufferCfgs.png
:alt: Configuration for CanIfBufferCfgs
:align: center

Configuration for CanIfBufferCfgs
```

For a Receive message:

**CanIfHrhCfgs:**

CanIfHrhCfgs container contains configuration parameters for each hardware receive object (HRH). CanIfHrhCfgs configuration is shown below. It contains the reference to CAN controller and HRH object in the CAN driver module configuration -

```{figure} Assets/images/CanIf_HrhCfgs.png
:alt: Configuration for CanIfHrhCfgs
:align: center

Configuration for CanIfHrhCfgs
```

**CanIfRxpduCfgs:**

CanIfRxpduCfgs container contains the configuration (parameters) of each receive CAN L-Pdu. Filters and delivers incoming messages to the upper layers. CanIfRxpduCfgs configuration is shown below -

```{figure} Assets/images/CanIf_RxPduCfgs.png
:alt: Configuration for CanIfRxPduCfgs
:align: center

Configuration for CanIfRxPduCfgs
```

##### PduR Configuration in CAN Module

The primary function of the Pdu Router module is to abstract the bus access type (Interface layer) and the bus type itself. The Pdu Router routing tables are configured with source and destination parameters. Pdu Router configuration to send and receive CAN message to and from CAN driver and Com module is shown below -

```{figure} Assets/images/PduR_Configuration.png
:alt: PduR configuration
:align: center

PduR configuration
```

##### Com Configuration in CAN Module

The Com provides a signal-based communication interface to the upper layer (Rte). Also it is responsible for Packing and unpacking of signals in I-Pdus. Com configuration with different I-Pdus are shown below -

```{figure} Assets/images/Com_Configuration.png
:alt: Com Configuration
:align: center

Com Configuration
```

##### CanSM Configuration in CAN Module

CanSM changes the communication modes of the configured CAN networks according to requests from the ComM module and and performs a bus-specific error handling (BusOff). CanSM configuration is shown below -

```{figure} Assets/images/CanSm_Configuration.png
:alt: CanSM Configuration
:align: center

CanSM Configuration
```

##### ComM Configuration in CAN Module

The ComM is a resource manager, which encapsulates the control of the underlying services. The main purpose is controlling of multiple communication requests by the application independent of the used bus system -

```{figure} Assets/images/ComM_Configuration.png
:alt: ComM configuration
:align: center

ComM configuration
```

##### Os Configuration in CAN Module

The OS module is responsible for task scheduling. Tasks such as 10ms and 1s are created to schedule different schedulable functions for CAN and respective BSW modules. The figure below illustrates the OS configuration -

```{figure} Assets/images/Os_Configuration.png
:alt: Os configuration
:align: center

Os configuration
```

##### Rte Configuration in CAN Module

Runtime Environment (RTE) manages communication between the software components (SWC), assures consistency of the overall information flow between basic software (BSW). It also maps a BswSchedulableEntity onto a OsTask.

The scheduling of the CAN_MainFunction Read is shown below -

```{figure} Assets/images/Can_Readfunction.png
:alt: Scheduling of Periodic Function - Read
:align: center
Scheduling of Periodic Function - Read
```

The scheduling of CAN_MainFunction Write is shown below -

```{figure} Assets/images/Can_writeFunction.png
:alt: Scheduling of Periodic Function - Write
:align: center
Scheduling of Periodic Functions - Write
```

All runnable in the 10ms task are shown below -

```{figure} Assets/images/Rte_All_task.png
:alt: All Runnable in 10ms task
:align: center

All Runnable in 10ms task
```

In the RTE (Runtime Environment), the corresponding port is created based on the configuration, and it can be used to communication between software components.

The port connection to software component is shown below -

```{figure} Assets/images/Can_PortConnection.png
:alt: Port connection to software component
:align: center

Port connection to software component
```

**Development Error Detection:**

This configuration enables development error detection in all BSW and MCAL modules. Please refer to this setup as a reference for configuring other modules -

```{figure} Assets/images/Det_Error.png
:alt: Configuration for Development Error Detection
:align: center

Configuration for Development Error Detection
```

### ADC Integration

#### Objective for ADC Integration

The purpose of ADC integration is to get digital voltage value from analog inputs by configuring TI MCAL modules along with Vector BSW Modules. Further details are explained in the subsequent chapter.

#### List Of Modules for ADC

##### MCAL Modules for ADC Integration

| Sl. No. | MCAL Modules | Description | Significance in use case |
|----|--------|----------|----|
|1| ADC | The ADC module handles analog-to-digital conversions for external monitoring channels and internal temperature sensors, allowing start, stop, and result reading for configurable channel groups.| In this use-case, this module is used to convert analog voltage value to digital value.|
|2| Mcu| The MCU module manages microcontroller features such as power modes, clock settings, and interrupts. |In this use case, this module is responsible for providing the clock for ADC communication. |

```{Note}
 For detailed information, please refer to the section [ADC Module](./Module_User_Guide_Adc.md#adc-module).
```

##### Vector Modules for ADC Integration

| Sl. No. | Vector Modules | Description | Significance in use case |
|----|--------|----------|----|
|1| IoHwAb | The aim of the IoHwAb is to provide ECU hardware-independent data transition from driver modules up to the Software Components.|In this use case, IoHwAb layer provides wrapper function for each of the underlying ADC API's, so that the application is independent on the hardware.|
|2| OS (MICROSAR Operating System)| The Operating System is mainly responsible for handling tasks and interrupts.| In this use case, OS module is used to define periodic tasks needed for ADC communication such as processing transmit and receive message. |
|3| RTE (MICROSAR Runtime Environment) | The Runtime Environment module manages the information flow between Software Components (SWCs), BSW and CDDs.|In this use case, Rte module is used to schedule the periodic tasks defined in the operating system (OS) and sender receiver ports created for sending receiving can messages from application. |
|4| DET | The DET is used in order to report development errors. The DET can be replaced optionally by an equivalent component which is responsible for recognizing development errors, if no DET component is available.|In this use Case, Development error is enabled to detect all development errors.|

```{Note}
For detailed information on each module and its features, please refer to the Technical Reference Manual provided by Vector.
```

```{Note}
 For importing MCAL configuration files to DaVinci refer [Importing TI MCAL modules from EB Tresos to Vector DaVinci Configurator](./Integration.md#importing-ti-mcal-modules-from-eb-tresos-to-vector-davinci-configurator).
```

#### Configuration of modules in ADC Integration

This chapter explains the basic configurations that are needed to realize ADC communication

##### ADC Configuration

TI ADC driver is configured using EB Tresos tool. It is then imported to Vector DaVinci configurator for integration with BSW stack. Following containers and parameters shall be configured.

**AdcGeneral:**

The AdcGeneral container defines the generic configuration parameters for ADC and provide provisions to enable disable API's. The following figure shows the configuration of parameters interrupt as ADC_ISR_CAT2 and result alignment as ADC_ALIGN_RIGHT -

```{figure} Assets/images/Adc_General.png
:alt: Configuration for Adc_General
:align: center

Configuration for Adc_General
```

**AdcHwUnit:**

The AdcHwUnit container defines the configuration of individual ADC hardware units. It defines hardware related settings such as hardware unit to be used and resolution. The following figure shows the ADCHwUnit configurations -

```{figure} Assets/images/Adc_HwUnit.png
:alt: Configuration for AdcHWUnit
:align: center

Configuration for AdcHWUnit
```

**AdcChannel:**

The AdcChannel container defines the channel configuration depending on the hardware capabilities. The following figure shows the configuration of AdcChannel high/low limit and channel ID and channel range -

```{figure} Assets/images/Adc_Channel.png
:alt: Configuration for ADC channel
:align: center

Configuration for ADC channel
```

**AdcChannelGroup:**

The AdcChannelGroup configures multiple channels together, and it defines group-specific settings such as conversion mode and trigger source. The following figure shows the configuration of ADC_CONV_MODE_ONESHOT mode -

```{figure} Assets/images/Adc_ChannelGroup.png
:alt: Configuration for AdcChannelGroup
:align: center

Configuration for AdcChannelGroup
```

**AdcGroupDefinition:**

The AdcChannelGroupDefinition configures AdcChannel reference. AdcChannel_0 reference provided in AdcGroup_0 is shown below -

```{figure} Assets/images/Adc_GroupDefinition.png
:alt: Configuration for AdcGroupDefinition
:align: center

Configuration for AdcGroupDefinition
```

##### Mcu Configuration in ADC Module

The McuInterruptChannelXbar configuration is set to 'MCU_INTRXBAR0_OUT_1' and mapped to 'MCU_INT_XBAR_ADC1_INT1. ADC interrupt is needed to be mapped through XBAR configuration. As shown in the figure, MCU_INTRXBAR0_OUT_1 an XBAR interrpt is being mapped to MCU_INT_XBAR_ADC1_INT1, which is the interrupt for ADC hardware unit 1.

The ADC interruption channel configuration is shown below -

```{figure} Assets/images/Adc_Mcuxbar.png
:alt: Configuration for AdcInterrupt
:align: center

Configuration for AdcInterrupt
```

ADC hardware unit reference in MCU module is shown below -

```{figure} Assets/images/Mcu_AdcHWUnitId.png
:alt: Configuration for McuAdcHWUnitId
:align: center

Configuration for McuAdcHWUnitId
```

##### IoHwAb Configuration in ADC Module

IoHwAb is a layer in the AUTOSAR architecture that abstracts hardware-level interfaces and provides a standardized API to the upper layers. It bridges the gap between hardware peripherals (like ADCs, GPIOs, etc.) and software components, ensuring hardware independence for application layers.

The configuration process for creating IoHwAb_AdcReadResultBuffer API in the IoHwAbCSPortInterfaces container is shown below -

```{figure} Assets/images/IoHwAb_AdcResultBuffer.png
:alt: Configuration for IoHwAb_AdcReadResultBuffer
:align: center

Configuration for IoHwAb_AdcReadResultBuffer
```

The configuration process for creating IoHwAbAdcReadResultBuffer API in the IoHwAbCSPortPrototypes container is shown below -

```{figure} Assets/images/IoHwAb_AdcResultBuffer1.png
:alt: Configuration for IoHwAbAdcReadResultBuffer
:align: center

Configuration for IoHwAb_AdcReadResultBuffer
```

The interface between IoHwAb module and Mcal module API is shown below -

```{figure} Assets/images/Adc_readbuffer.png
:alt: Function call between IoHwAb and ADC
:align: center

Function call between IoHwAb and ADC
```

In the RTE (Runtime Environment), the corresponding port is created based on the configuration, and it can be used to communication between software components.

The port connection to software component is shown below -

```{figure} Assets/images/Adc_PortConnection.png
:alt: Port connection to software component
:align: center

Port connection to software component
```

##### Os Configuration in ADC Module

The OS module is responsible for task scheduling. The mapping of ADC Mainfunction to the 10ms event is shown below -

```{figure} Assets/images/Os_AdcMainFunction.png
:alt: Os configuration
:align: center

Os configuration
```

##### Rte Configuration in ADC Module

The ADC main function is mapped to a 10ms task as shown in the below -

```{figure} Assets/images/ADC_Mainfunction.png
:alt: Mapping ADC main function to 10ms task
:align: center

Mapping ADC main function to 10ms task
```

### SPI Integration

#### Objective for SPI Integration

The intention of SPI integration is to establish successful SPI communication by configuring the SPI MCAL and dependent Vector modules. It will facilitate communication between the MCAL modules, transmitting and receiving data from the Vector module, which will be explained in the subsequent chapter.

#### List of Modules for SPI

##### MCAL Modules for SPI Integration

| Sl. No. | MCAL Modules | Description | Significance in use case |
|----|--------|----------|----|
|1| Mcu| The MCU module manages microcontroller features such as power modes, clock settings, and interrupts. | In this use case, this module is responsible for providing the clock for SPI communication. |
|2| SPI (Serial Peripheral Interface) | The main tasks of the SPI are Handle data transmission to the components connected via SPI, take care of the settings required by external components (baud rate etc.)| In this use case, this module is responsible for configuring spi channel, job and sequence.|
|3| Port | The PORT module provides an interface to configure and control microcontroller pins (e.g., GPIO, ADC, PWM). | In this use case, this module is responsible for configuring the hardware pins necessary for Spi communication. |

```{Note}
 For detailed information, please refer to the section [SPI Module](./Module_User_Guide_Spi.md#spi-module).
```

##### Vector Modules for SPI Integration

| Sl. No. | Vector Modules | Description | Significance in use case |
|----|--------|----------|----|
|1| IoHwAb | The aim of the IoHwAb is to provide ECU hardware-independent data transition from driver modules up to the Software Components. |In this use case, IoHwAb layer provides wrapper function for each of the underlying SPI API's, so that the application is independent on the hardware.|
|2| OS (MICROSAR Operating System)| The Operating System is mainly responsible for handling tasks and interrupts.| In this use case, OS module is used to define periodic tasks needed for SPI communication such as processing transmit and receive message. |
|3| RTE (MICROSAR Runtime Environment) | The Runtime Environment module manages the information flow between Software Components (SWCs), BSW and CDDs.|In this use case, Rte module is used to schedule the periodic tasks defined in the operating system (OS) and sender receiver ports created for sending receiving spi messages from application. |
|4| DET | The DET is used in order to report development errors. The DET can be replaced optionally by an equivalent component which is responsible for recognizing development errors, if no DET component is available.|In this use Case, Development error is enabled to detect all development errors.|

```{Note}
For detailed information on each module and its features, please refer to the Technical Reference Manual provided by Vector.
```

```{Note}
 For importing MCAL configuration files to DaVinci refer [Importing TI MCAL modules from EB Tresos to Vector DaVinci Configurator](./Integration.md#importing-ti-mcal-modules-from-eb-tresos-to-vector-davinci-configurator).
```

#### Configuration of modules in Spi Integration

This chapter explains the basic configurations that are needed to realize SPI communication.

##### Spi configuration

TI SPI driver is configured using EB Tresos tool. It is then imported to Vector DaVinci configurator for integration with SPI stack. Following containers and parameters shall be configured.

**SpiGeneral:**

The SpiGeneral container is used to configure SPI-related global settings that affect the SPI driver as a whole. It manages essential settings like enabling Apis and setting timeout duration, maxjobs and maxSequences etc. The following figure shows the configuration of SpiMainFunctionPeriod with 10ms -

```{figure} Assets/images/Spi_General.png
:alt: Configuration for SpiGeneral
:align: center

Configuration for SpiGeneral
```

**SpiMaxChannel:**

The SpiMaxChannel container Specifies the maximum number of SPI channels that can be configured and used by the SPI driver in the system. The configuration of max channels is shown below -

```{figure} Assets/images/Spi_MaxChannel.png
:alt: Configuration for spiMaxChannel
:align: center

Configuration for spiMaxChannel
```

**SpiJob:**

The SpiJob container specifies the Spi job priority, Device assignment and HW unit assignment. The configuration of Spijob is shown below -

```{figure} Assets/images/Spi_Job.png
:alt: Configuration for SpiJob
:align: center

Configuration for SpiJob
```

**SpiHwUnitSynchronous:**

The SpiHwUnitSynchronous container is set to "SYNCHRONOUS", the SpiJob uses its contained SpiDriver in a synchronous manner. If it is set to "ASYNCHRONOUS", it uses the driver in an asynchronous way. The configuration of SYNCHRONOUS is shown below -

```{figure} Assets/images/SpiJob_Sync.png
:alt: Configuration for SpiHwUnitsynchronous
:align: center

Configuration for SpiHwUnitsynchronous
```

**SpiJobEndNotification:**

The SpiJobEndNotification parameter is a reference to a notification function. The configuration of NULL_PTR is shown below -

```{figure} Assets/images/Spi_JobEndnotification.png
:alt: Configuration for SpiJobEndNotification
:align: center

Configuration for SpiJobEndNotification
```

**SpiChannelList:**

The SpiChannelList container references spi channels and their order within the job. The configuration of spi channel order is shown below -

```{figure} Assets/images/Spi_ChannelList.png
:alt: Configuration of SpiChannelList
:align: center

Configuration of SpiChannelList
```

**SpiMaxSequence:**

The SpiMaxSequence configures the maximum number of SPI sequences that the SPI driver can handle concurrently or sequentially in the system. The configuration of the Max sequence is shown below -

```{figure} Assets/images/Spi_MaxSequnce.png
:alt: Configuration for SpiMaxSequence
:align: center

Configuration for SpiMaxSequence
```

**SpiChannel:**

The SpiChannel configuration defines the parameters for a specific SPI channelId, channeltype, data width and transfer start, etc. The configuration of SpiChannel is shown below -

```{figure} Assets/images/Spi_Channel.png
:alt: Configuration of SpiChannel
:align: center

Configuration of SpiChannel
```

**SpiExternalDevice:**

The SpiExternalDevice container is used to define the properties and configuration settings for an SPI peripheral device that is external to the ECU. It specifies how the ECU (master) will communicate with an external device (slave) via the SPI interface. This configuration includes details about the device's requirements for communication, such as timing, data format, and the SPI mode -

```{figure} Assets/images/Spi_externalDevice.png
:alt: Configuration for SpiExternalDevice
:align: center

Configuration for SpiExternalDevice
```

**SpiSequence:**

The SpiSequence configuration defines a series of SpiJobs that are executed in a particular order to achieve a complete communication task. The configuration of spi sequence Id is shown below -

```{figure} Assets/images/Spi_Sequnce.png
:alt: Configuration of SpiSequence
:align: center

Configuration of SpiSequence
```

**SpiSeqEndNotification:**

The SpiSeqEndNotification contains a reference to a notification function. The following figure is shown below -

```{figure} Assets/images/Spi_Endjobnotification.png
:alt: Configuration for SpiSeqEndNotification
:align: center

Configuration for SpiSeqEndNotification
```

**SpiJobAssignment:**

The SpiJobAssignment container references several jobs, which are executed during a communication sequence. The following figure is show below -

```{figure} Assets/images/Spi_Assignment.png
:alt: Configuration for SpiJobAssignment
:align: center

Configuration for SpiJobAssignment
```

**SpiHwUnitConfig:**

The SpiHwUnitConfig is used to define the hardware settings to initialize and control the physical SPI hardware unit (such as SPI0, SPI1, etc.) on the microcontroller -

```{figure} Assets/images/Spi_Hwunit.png
:alt: Configuration of SpiHwUnitConfig
:align: center

Configuration of SpiHwUnitConfig
```

**SpiUserCallbackHeaderFile:**

The SpiUserCallbackHeaderFile specifies the header file that contains user-defined callback functions that the SPI driver can call at various stages of the SPI communication process -

```{figure} Assets/images/Spi_Usecallbackheader.png
:alt: Configuration for SpiUserCallbackHeaderFile
:align: center

Configuration for SpiUserCallbackHeaderFile
```

**SpiHwUnitEnabled:**

The SpiHwUnitEnabled is used for storing enabled SPI HW units -

```{figure} Assets/images/Spi_HwunitEnabled.png
:alt: Configuration for SpiHwUnitEnabled
:align: center

Configuration for SpiHwUnitEnabled
```

##### Port Configuration in SPI Module

In the configuration of the SPI module, the port pins are used to facilitate the transmission (Tx) and reception (Rx) of data. The pin configurations for both SPI0 and SPI1 are shown below -

```{figure} Assets/images/SPI_Port.png
:alt: Port pin configuration for spi
:align: center

Port pin configuration for spi
```

The SPI0 clock pin configuration is shown below -

```{figure} Assets/images/Spi_clockpin.png
:alt: Configuration for Spi clock pin
:align: center

Configuration for Spi clock pin
```

##### IoHwAb configuration in SPI Module

The configuration process for determining the IoHwAb_Async_Transmit API in the IoHwAbCSPortInterfaces container is shown below -

```{figure} Assets/images/Spi_AsyncTransmit.png
:alt: Configuration for IoHwAbCSPortInterface
:align: center

Configuration for IoHwAbCSPortInterface
```

The configuration process for determining IoHwAbCSAsyncTransmit API in the IoHwAbCSPortPrototypes container is shown below -

```{figure} Assets/images/Spi_AsyncTransmit1.png
:alt: Configuration for IoHwAbCSPortPrototypes
:align: center

Configuration for IoHwAbCSPortPrototypes
```

The function call interaction between the IoHwAb module and the Mcal module API is shown below -

```{figure} Assets/images/Spi_IohwAbApi.png
:alt: Function call between IoHwAb and SPI
:align: center

Function call between IoHwAb and SPI
```

In the RTE (Runtime Environment), the corresponding port is created based on the configuration, and it can be used to communication between software components.

The port connection to software component is shown below -

```{figure} Assets/images/Spi_PortConnection.png
:alt: Port connection to software component
:align: center

Port connection to software component
```

##### Rte Configuration in SPI Module

The SPI main function timing event handling is mapped to a 10ms task, and its position is specified as shown below. The importance of the position parameter comes into play when more than one function is mapped to the same task. The position parameter determines the execution order of the mapped functions within that particular task, with lower values executing first -

```{figure} Assets/images/Spi_RteMainfunction.png
:alt: Configuring 10ms task to spi_mainfunctionTimingEvent_Handling
:align: center

Configuring 10ms task to spi_mainfunctionTimingEvent_Handling
```

### PWM Integration

#### Objective for PWM Integration

The intention of PWM Integration is to enable successful PWM signal generation by configuring TI MCAL modules along with Vector BSW Modules. Further details are explained in the subsequent chapter.

#### List of Modules for PWM

##### MCAL Modules for PWM Integration

| Sl. No. | MCAL Modules | Description | Significance in use case |
|----|--------|----------|----|
|1| Mcu| The MCU module manages microcontroller features for PWM, such as power modes and clock settings.|In this use case, this module is responsible for providing the clock for PWM signal generation. |
|2| Port | The PORT module provides an interface to configure and control microcontroller pins (e.g., GPIO, ADC, PWM). | In this use case, this module is responsible for configuring the hardware pins necessary for PWM signal generation. |
|3| Pwm | The PWM module initializes and controls the internal PWM peripherals of the microcontroller. It provides services to configure, start, and stop PWM channels used for generating variable duty cycle signals|In this use case, PWM is used to generate PWM signal with different duty cycle.|

```{Note}
For detailed information, please refer to the section [PWM Module](./Module_User_Guide_Pwm.md#pwm-module).
```

##### Vector Modules for PWM Integration

| Sl. No. | Vector Modules | Description | Significance in use case |
|----|--------|----------|----|
|1| IoHwAb | The aim of the IoHwAb is to provide ECU hardware-independent data transition from driver modules up to the Software Components. |It provides an abstraction for the PWM driver and enables communication with the application layer.|
|2| OS | The Operating System is mainly responsible for handling tasks. | In this use case, it is used to initialize PWM. |
|3| RTE | The Runtime Environment module manages the information flow | In this use case, it is used to schedule the periodic task defined in OS. |
|4| DET | The DET is used in order to report development errors. The DET can be replaced optionally by an equivalent component which is responsible for recognizing development errors, if no DET component is available.|In this use Case, Development error is enabled to detect all development errors.|

```{Note}
 For detailed information on each module and its features, please refer to the Technical Reference Manual provided by Vector.
```

```{Note}
 For importing MCAL configuration files to DaVinci refer [Importing TI MCAL modules from EB Tresos to Vector DaVinci Configurator](./Integration.md#importing-ti-mcal-modules-from-eb-tresos-to-vector-davinci-configurator).
```

#### Configuration of modules in PWM Integration

This chapter explains the basic configurations that are needed to realize PWM functionality.

##### PWM Configuration

The PWM driver is configured using the EB Tresos tool and then imported into the Vector DaVinci Configurator for integration with the application software. The following containers and parameters should be configured.

**PwmGeneral:**

The PwmGeneral container provides general configuration settings for the PWM module.

In PWM general settings, PWMSetDutyCycle API is enabled as shown below -

```{figure} Assets/images/PWM_General_Settings.png
:alt: PWM General Settings
:align: center

PWM General Settings
```

**PwmChannel:**

The PwmChannel configuration container specifies the settings for a specific PWM channel.

In the PWM channel configuration, the channel ID is set to 3, the default duty cycle is configured as 16384, and the PWM polarity is set to high, as shown below -

```{figure} Assets/images/Configuration_of_PWM_Channel.png
:alt: Configuration for Pwm Channel
:align: center

Configuration of PWM Channel
```

##### Mcu Configuration in PWM Module

The PWM module has dependencies on MCU module to provide the PWM clock setting reference.

The MCU clock configuration for PWM controller is shown below -

```{figure} Assets/images/Configuration_of_McuClockSettingconfig.png
:alt: Configuration of McuClockSettingconfig
:align: center

Configuration of McuClockSettingconfig
```

PWM clock should be derived from MCU clock reference point.

The MCU clock reference point is shown below -

```{figure} Assets/images/Configuration_of_McuClockReferencePoint.png
:alt: Configuration of McuClockReferencePoint
:align: center
Configuration of McuClockReferencePoint
```

##### Port Configuration in PWM Module

The PWM module has a dependency on the Port module to configure the output pins used for generating PWM signals. Each PWM channel is mapped to a specific physical pin on the microcontroller, which must be configured as an output using the Port module.

In the port pin configuration, EPWM3 is configured as a PWM output, as shown below -

```{figure} Assets/images/Port_pin_configuration_for_Pwm.png
:alt: Port pin configuration for Pwm
:align: center
Port Pin configuration for Pwm
```

##### IoHwAb Configuration in PWM Module

 IoHwAb is a layer in the AUTOSAR architecture that abstracts hardware-level interfaces and provides a standardized API to the upper layers.

To configure a Client/Server Port Interface, the container IoHwAb_PWM_DutyCycle holds the configuration elements for a Client/Server template interface. This interface is instantiated by a Client/Server Port Prototype.

The container IoHwAbOperationArguments contains the configuration of Operation Elements, such as ChannelID and DutyCycle, for a Client/Server Operation. These Operation Elements will be generated as function parameters in the I/O Hardware Abstraction (IoHwAb) implementation.

Similarly, it is possible to enable communication between the I/O Client/Server interface and the MCAL APIs.

Configuration of pwm IoHwAbCS port interface as shown below -

```{figure} Assets/images/Configuration_of_PWM_IoHwAb_CS_Port_Interface.png
:alt: Configuration for Pwm IoHwAbCSPortInterface
:align: center
Configuration for Pwm IoHwAbCSPortInterface
```

The container IoHwAbPWMDutyCycle is used for configuring a Client/Server Port Prototype. This container represents an instantiation of a Client/Server Port Interface.

Configuration of pwm IoHwAbCS port prototype as shown below -

```{figure} Assets/images/Configuration_of_PWM_IoHwAb_CS_Port_Prototype.png
:alt: Configuration for Pwm IoHwAbCSPortPrototypes
:align: center
Configuration for Pwm IoHwAbCSPortPrototypes
```

The function IoHwAb_IoHwAbPWMDutyCycle_IoHwAbOperation is generated, and then the MCAL API function Pwm_SetDutyCycle is called -

```{figure} Assets/images/IOHWAB_set_Duty_Cycle.png
:alt: Invoking MCAL API SetDutyCycle
:align: center
 Invoking MCAL API SetDutyCycle
```

In the RTE (Runtime Environment), the corresponding port is created based on the configuration, and it can be used to communication between software components.

The port connection to software component is shown below -

```{figure} Assets/images/Pwm_PortConnection.png
:alt: Port connection to software component
:align: center

Port connection to software component
```

### LIN Integration

#### Objective for LIN Integration

The intention of LIN integration is to establish successful LIN communication by configuring the MCAL and Vector modules. To achieve effective communication between the LIN master and slave, proper configurations are implemented, which will be explained in the subsequent chapter.

#### List of Modules for LIN

##### MCAL Modules for LIN Integration

| Sl. No. | MCAL Modules | Description | Significance in use case |
|----|--------|----------|----|
|1| Mcu| Manages microcontroller features such as power modes, clock settings, and interrupts. | In this use case this module is used to provide clock for CAN communication. |
|2| Port | Provides an interface to configure and control microcontroller pins (e.g., GPIO, ADC, PWM). | In this use case allows application software to interact with hardware pins, making it transmit and receive LIN Message. |
|3| Lin | A communication protocol for low-speed communication between ECUs (Electronic Control Units) in automotive applications.|In this use case, it is used for communication between the MCAL layer and the Application layer to transmit and receive data.|

```{Note}
 For detailed information, please refer to the section [LIN Module](./Module_User_Guide_Lin.md#lin-module).
```

##### Vector Modules for LIN Integration

| Sl. No. | Vector Modules | Description | Significance in use case |
|----|--------|----------|----|
|1| EcuC | Virtual module to collect ECU Configuration specific / global configuration information.|In this use case, EcuC collects all Pdu objects flowing through the Com-Stack.|
|2| LinIf | Provides an interface for handling communication over the LIN (Local Interconnect Network) protocol.|In this use case, LinIf ensures communication between application software and the LIN hardware.|
|3| LinSM| Manages the state machine for the LIN communication stack.|In this use case, LinSM manages the state transitions of the Lin controller to error recovery and maintain reliable communication.|
|4| OS (MICROSAR Operating System)| The Operating System is mainly responsible for handling of tasks and interrupts.| In this use case, it used to define a periodic task. |
|5| RTE (MICROSAR Runtime Environment) | The Runtime Environment module manages the information flow between <br> Software Components (SWCs), BSW and CDDs.|In this use case, it is used to schedule the periodic task defined in OS. |
|6| Com | Com is responsible to provide a signal-based <br> interface to the upper layer. It handles signal <br> conversion, transmission and reception. |In this use case, Com module handles packing of AUTOSAR signals to I-Pdus to be transmitted <br> and unpacking of received I-Pdus. |
|7| ComM | The Communication Manager is a resource manager, which encapsulates the control of the underlying <br> communication services. It controls more than one communication bus channel of an ECU by implementing a channel state machine for every <br> channel.|In this use case, ComM provides a mechanism for users to request communication modes, coordinating requests from multiple <br> independent users. |
|8| EcuM | EcuM is responsible for initialization of BSW (Basic Software) modules that are needed to start <br> the operating system and preparation of the microcontroller for a sleep phase and the following wake up|In this use case, EcuM is used <br> to wake up the LIN channel by configuring the EcuM wakeup sources |
|9| PduR | PduR routes protocol data units between communication modules and ensures that the correct Pdus <br> are transmitted to the appropriate destination.|In this use case, PduR module handles the routing of Pdus to and from Com layer and <br> LIN driver. |
|10| DET | The DET is used in order to report development errors. The DET can be replaced optionally by an equivalent component which is responsible for recognizing development errors, if no DET component is available.|In this use Case, Development error is enabled to detect all development errors.|

```{Note}
 For detailed information on each module and its features, please refer to the Technical Reference Manual provided by Vector.
```

```{Note}
 For importing MCAL configuration files to DaVinci refer [Importing TI MCAL modules from EB Tresos to Vector DaVinci Configurator](./Integration.md#importing-ti-mcal-modules-from-eb-tresos-to-vector-davinci-configurator).
```

#### Configuration of modules in LIN Integration

This chapter explains the basic configurations that are needed to realize LIN communication.

##### Lin Configuration

**LinGeneral:**

The LinGeneral container is responsible for configuring the global settings of the LIN protocol in the system.

Follow the configuration of Lin General settings as shown below -

```{figure} Assets/images/Lin_General.png
:alt: Lin General configuration
:align: center

Lin General configuration
```

**LinChannel:**

This container holds the configuration parameters for the LIN Controller(s). It defines critical settings such as the baud rate, which is essential for enabling proper communication between the LIN bus and the application layer.

Select LIN1 hardware unit, with loopback mode disabled and baud rate configuration as shown below -

```{figure} Assets/images/Lin_Ch_Config.png
:alt: Lin Channel Configuration
:align: center

Lin Channel Configuration
```

##### MCU Configuration for LIN Module

The LIN module has dependence on MCU module. Hence, we need to provide clock setting reference in MCU module. Please refer to TechnicalReference_Mcu was used to configure this module.

Lin clock reference point is configured as shown below -

```{figure} Assets/images/LinMcuClockReferenceConfiguration.png
:alt: Lin Mcu Clock reference configuration
:align: center

Lin Mcu Clock reference configuration
```

##### Port Configuration in LIN Module

In the configuration of the port for the LIN module, the port pins are used to facilitate the transmission (Tx) and reception (Rx) of messages.

LIN1 Rx is configured on pin A9 and LIN1 Tx is configured on pin B9 as shown below -

```{figure} Assets/images/PortPin.png
:alt: Port pin configuration for Lin
:align: center

Port pin configuration for Lin
```

Similarly, port pin for LIN  RX can be configured.

##### EcuC Configuration in LIN Module

EcuC is a virtual module to collect ECU Configuration specific global configuration information. EcuCPduCollection container collects all the Pdus flowing through the COM Stack as shown below -

```{figure} Assets/images/LinEcuCPduCollection.png
:alt: EcuC Pdu Collection
:align: center

EcuC Pdu Collection
```

##### LinIf Configuration in LIN Module

LinIf is responsible for managing the interaction between the application layer and the underlying LIN driver.

**LinIfChannels:**

LinIfChannels define the communication channels for the LIN (Local Interconnect Network) protocol.

The configuration of the LinIf channel is done with the startup state set to NORMAL and the wake-up confirmation timeout period configured as 2 seconds as shown below -

```{figure} Assets/images/LinIfChannelConfiguration.png
:alt: LinIf channel configuration
:align: center

LinIf channel configuration
```

**LinIfFrames:**

LinIfFrames represent the actual message format used in LIN communication, specifying message IDs, data length, and content.

Both LINIf Tx and Rx frames are configured as Unconditional frames as shown below -

```{figure} Assets/images/LinIfTxRxframe.png
:alt: LinIf Tx and Rx frame configuration
:align: center

LinIf Tx and Rx frame configuration
```

The configuration of LinIf Tx Pdu frame is as shown below -

```{figure} Assets/images/LinIfTxFrame.png
:alt: LinIf Tx frame configuration
:align: center

LinIf Tx frame configuration
```

The configuration of LinIf Rx Pdu frame is as shown below -

```{figure} Assets/images/LinIfRxFrame.png
:alt: LinIf Rx frame configuration
:align: center

LinIf Rx frame configuration
```

**LinIfScheduleTables:**

The schedule table allows for time-based control of message exchanges, ensuring that messages are sent at the correct intervals, such as periodically requesting sensor data or controlling actuators.

The configuration of LinIfScheduleTable for both master and slave response where both are configured with runmode as RUN_ONCE as shown below -

```{figure} Assets/images/LinIfScheduleTables.png
:alt: Configuration for LinIfScheduleTables
:align: center

Configuration for LinIfScheduleTables
```

The configuration of LinIfEntry is shown below -

```{figure} Assets/images/LinIfEntry.png
:alt: Configuration for LinIfEntry
:align: center

Configuration for LinIfEntry
```

**LinIfNodeType:**

LinIfNodeType specifies the role of a LIN node (communication endpoint) in the network.
Master Node: Initiates communication controls the flow of data, and requests data from slave nodes.
Slave Node: Responds to requests from the master node, providing data or status information.

The configuration of LinIfNodeType is shown as below -

```{figure} Assets/images/LinIfNodeType.png
:alt: configuration for LinIfNodeType
:align: center

configuration for LinIfNodeType 
```

##### LinSM Configuration in LIN Module

The LinSM (LIN State Manager) is responsible for controlling the communication states of the LIN network, such as initialization, sleep, and wake-up.

**LinSMChannel:**

LinSMChannel configures the LIN State Manager channel, managing state transitions (e.g., from sleep to active) for LIN communication.

The configuration of LinSM channel is done as shown below by selecting appropriate node type -

```{figure} Assets/images/LinSMChannelConfiguration.png
:alt: LinSM Channel Configuration
:align: center

LinSM Channel Configuration
```

**LinSMSchedule:**

LinSMSchedule defines the schedule for the LIN State Manager (LinSM), specifying the timing and sequence for state transitions (such as wake-up and communication states).

Two LinSM Schedules are created with different schedule index as shown below -

```{figure} Assets/images/LinSMSchedulesConfiguration.png
:alt: LinSM Schedules Configuration
:align: center

LinSM Schedules Configuration
```

**LinSMGeneral:**

LinSMGeneral is used to configure general settings for the LIN State Manager (LinSM), which controls the state transitions of the LIN communication.

The configuration of LinSM is configured as shown below, by setting the main Processing period as 10ms -

```{figure} Assets/images/LinSMGeneralConfiguration.png
:alt: LinSM general configuration
:align: center

LinSM general configuration
```

##### EcuM Configuration in LIN Module

The EcuM is used to wake up the LIN channel by configuring the EcuM wakeup source ID and setting the parameters that reference the LinWakeupChannel parameter.

Follow the configuration of EcuM with EcuM wakeup source ID as 4 and EcuM wakeup source enabled in Polling mode as shown below -

```{figure} Assets/images/LinWakeupEcuM.png
:alt: Lin wakeup configuration in EcuM
:align: center

Lin wakeup configuration in EcuM
```

##### PduR Configuration in LIN Module

The primary function of the Pdu Router module is to abstract the bus access type (Interface layer) and the bus type itself. The Pdu Router routing tables are configured with source and destination parameters. Pdu Router configuration to send and receive LIN message to and from LIN driver and Com module, is shown below -

```{figure} Assets/images/PduRConfiguration.png
:alt: PduR configuration
:align: center

PduR Configuration
```

##### Com Configuration in LIN Module

Com module provides the configuration for ComIpdus and ComIpdugroups. It also provides Tx and Rx main function. Below figure illustrates the com configuration

To configure Lin in DaVinci Configurator the following containers need to be set up.

**ComSignal:**

The ComSignal container is used to define individual signals within a communication protocol (e.g., CAN, LIN) in the system.

The configuration of the Com Signal for the LIN master response is done with the transfer property set to TRIGGERED and the signal access set to ACCESS_NEEDED_BY_OTHER, as shown in the figure below -

```{figure} Assets/images/ConfigurationLinTx.png
:alt: Configuration for Lin Tx signal
:align: center

Configuration for Lin Tx signal
```

Configuration of Lin Slave signal is done with signal access set to ACCESS_NEEDED_BY_OTHER as shown below -

```{figure} Assets/images/ConfigurationLinRx.png
:alt: Configuration of Lin Rx signal
:align: center

Configuration of Lin Rx signal
```

**ComIPuds:**

The ComIPuds container simplifies the definition of data transfer mechanisms between ECUs, especially when communication involves multiple protocols or complex mappings of signals and messages.

Configuration of a Lin Master comIpdu is configured with Ipdu signal processing as IMMEDIATE as shown below -

```{figure} Assets/images/ConfigurationLinTxIpdu.png
:alt: configuration for Lin Tx Ipdu
:align: center

configuration for Lin Tx Ipdu
```

Configuration of a Lin Slave comIpdu is done with Ipdu signal processing as DEFERRED, as shown below -

```{figure} Assets/images/ConfigurationLinRxIpdu.png
:alt: Configuration for Lin Rx Ipdu
:align: center

Configuration for Lin Rx Ipdu
```

**ComIPduGroup:**

The ComIPduGroup container is used to group related IPdus together, which can represent different sets of data that need to be communicated within the same context or for the same functional block.

The configuration of ComIPduGroup associated with the LIN Master is shown below -

```{figure} Assets/images/ConfigurationLinTxIpduGroup.png
:alt: Configuration for Lin Tx IpduGroup
:align: center

Configuration for Lin Tx IpduGroup
```

The configuration of ComIPduGroup associated with the LIN Slave is shown below -

```{figure} Assets/images/ConfigurationLinRxIpduGroup.png
:alt: Configuration for Lin Rx IpduGroup
:align: center

Configuration for Lin Rx IpduGroup
```

##### ComM Configuration in LIN Module

The ComM module allows the system to operate in different communication modes. Lin Controller channel reference shall be given in the ComM module.

**ComMUser:**

The ComMUser configuration is used to specify user-defined settings related to Communication Management (ComM).

The configuration of ComMUser for LIN is shown below -

```{figure} Assets/images/ConfigurationLinRteSwComponentInstances.png
:alt: Configuration for Lin RteSwComponentInstances
:align: center

Configuration for Lin RteSwComponentInstances
```

**ComMChannel:**

The ComMChannel container is responsible for configuring communication channels within the ComM (Communication Management) module.

The Configuration of ComMChannels for LIN is as shown below -

```{figure} Assets/images/ConfigurationLinComMChannel.png
:alt: Configuration for Lin ComM channel
:align: center

Configuration for Lin ComM channel
```

The configuration of ComMUserPerChannels for Lin is as shown below -

```{figure} Assets/images/ConfigurationLinComMUserPerChannels.png
:alt: Configuration for lin ComMUserPerChannels
:align: center

Configuration for lin ComMUserPerChannels
```

##### OS Configuration in LIN Module

The OS module is responsible for task scheduling. Tasks such as 10ms and 1s are created to schedule different schedulable functions for LIN and respective BSW modules. The figure below illustrates the OS configuration -

```{figure} Assets/images/OSConfiguration.png
:alt: OS Configuration
:align: center

OS Configuration
```

##### Rte Configuration in LIN Module

Runtime Environment (RTE) manages communication between the software components (SWC), assures consistency of the overall information flow between basic software (BSW). It also maps a BswSchedulableEntity onto a OsTask.

The scheduling of the LinIf_MainFunction is shown below -

```{figure} Assets/images/SchedulingLinIfMainFunction.png
:alt: Scheduling of LinIf main function
:align: center

Scheduling of LinIf main function
```

All runnable in the 10ms task are shown below -

```{figure} Assets/images/LinRteAllTaskMapped.png
:alt: Rte all task mapped
:align: center

Rte all task mapped
```

In the RTE (Runtime Environment), the corresponding port is created based on the configuration, and it can be used to communication between software components.

The port connection to software component is shown below -

```{figure} Assets/images/Lin_PortConnection.png
:alt: Port connection to software component
:align: center

Port connection to software component
```

### CDD_IPC Integration

#### Objective for CDD_IPC Integration

The intention of CDD_IPC Integration is to enable reliable and efficient inter-core communication by configuring the TI MCAL IPC driver in conjunction with the Vector Basic Software (BSW) modules.Further details are explained in the subsequent chapter.

#### List of Modules for CDD_IPC Integration

##### MCAL Modules for CDD_IPC Integration

| Sl.No. | MCAL Modules | Description | Significance in use case |
|----|--------|----------|----|
|1| IPC | The IPC module initializes and manages the inter-core communication hardware of the microcontroller. It provides services to configure communication channels, send and receive messages, and handle inter-core synchronization.| In this use case,the module is used to enable and manage communication between master core and slave cores, ensuring reliable data exchange and synchronization.|

```{Note}
 For detailed information, please refer to the section [CDD_IPC Module](./Module_User_Guide_Cdd_Ipc.md#cdd_ipc-module).
```

##### Vector Modules for CDD_IPC Integration

| Sl.No. | Vector Modules | Description | Significance in use case |
|----|--------|----------|----|
|1| IoHwAb | This module provides an abstraction layer for handling hardware-related input/output operations. It facilitates interaction with  IPC hardware resources for data exchange between processor cores. |In this use case,it abstracts the IPC driver and facilitates interaction between the application layer and the underlying inter-core communication mechanism.|
|2| OS | The Operating System is mainly responsible for handling tasks. | In this use case, it is used to initialize,manage tasks and interrupts related to inter-core communication, |
|3| RTE | The Runtime Environment module manages the information flow  | In this use case, it is used to schedule the periodic task defined in OS. |
|4| DET | The DET is used in order to report development errors. The DET can be replaced optionally by an equivalent component which is responsible for recognizing development errors, if no DET component is available.|In this use Case, Development error is enabled to detect all development errors.|

```{Note}
 For detailed information on each module and its features, please refer to the Technical Reference Manual provided by Vector.
```

```{Note}
 For importing MCAL configuration files to DaVinci refer [Importing TI MCAL modules from EB Tresos to Vector DaVinci Configurator](./Integration.md#importing-ti-mcal-modules-from-eb-tresos-to-vector-davinci-configurator).
```

#### Configuration of modules in CDD_IPC Integration

This chapter explains the basic configurations that are needed to realize CDD IPC functionalities.

##### CDD_IPC Configuration

The TI IPC driver is configured using the EB Tresos tool. It is then imported into the Vector DaVinci Configurator for integration with the application software. Following containers and parameters shall be configured.

**CDD_IPC General:**

The IpcGeneral container provides general configuration settings for the IPC module.

In IPC general settings,IpcWriteApi and IpcReadApi is enabled as shown below -

```{figure} Assets/images/Configuration_of_IPC_general_settings.png
:alt: Configuration of IPC general settings
:align: center

Configuration of IPC general settings
```

**CddIpcDriver:**

This CddIpcDriver container contains the configuration parameters and sub containers of the AUTOSAR Complex device driver(CDD) module

In the Cdd_Ipc Driver configuration,Specifies the local core ID on which the IPC instance is running, as shown below -

```{figure} Assets/images/Configuration_of_IPC_driver_settings.png
:alt: Configuration of IPC driver settings
:align: center

Configuration of IPC driver settings
```

**CddIpcRemoteCoreList:**

This CddIpcRemoteCoreList container refers to the list of core IDs that are valid for the particular platform and can participate in inter-process communication,as shown below -

```{figure} Assets/images/Configuration_of_Cdd_Ipc_Remote_Core_List.png
:alt: Configuration of Cdd IPC Remote Core List
:align: center

Configuration of Cdd IPC Remote Core List
```

##### IoHwAb Configuration

IoHwAb is a layer in the AUTOSAR architecture that abstracts hardware-level interfaces and provides a standardized API to the upper layers.

To configure a Client/Server Port Interface,the container Cdd_Ipc_Notify_RegisterClient holds the configuration elements for a Client/Server template interface. This interface is instantiated by a Client/Server Port Prototype.

The container IoHwAbOperationArguments contains the configuration of Operation Elements, such as Cdd_Ipc_localClientId,Cdd_Ipc_notify_msgHandler and IoHwAbOperationArgument,for a Client/Server Operation. These Operation Elements will be generated as function parameters in the I/O Hardware Abstraction(IoHwAb) implementation.

Similarly, it is possible to enable communication between the I/O Client/Server interface and the MCAL APIs.

Configuration of Cdd_Ipc IoHwAbCS port interface as shown below -

```{figure} Assets/images/Configuration_of_Cdd_Ipc_IoHwAb_CS_Port_Interface.png
:alt: Configuration for Cdd_Ipc IoHwAbCSPortInterface
:align: center
Configuration for Cdd_Ipc IoHwAbCSPortInterface
```

The container RegisterClient is used for configuring a Client/Server Port Prototype. This container represents an instantiation of a Client/Server Port Interface.

Configuration of Cdd_Ipc IoHwAbCS port prototype as shown below -

```{figure} Assets/images/Configuration_of_Cdd_Ipc_IoHwAb_CS_Port_Prototype.png
:alt: Configuration for Cdd_Ipc IoHwAbCSPortPrototypes
:align: center
Configuration for Cdd_Ipc IoHwAbCSPortPrototypes
```

The function IoHwAb_RegisterClient_Wrapper is generated, and then the MCAL API function Cdd_Ipc_Notify_RegisterClient is called.

In the RTE (Runtime Environment), the corresponding port is created based on the configuration, and it can be used as a Sender-Receiver Port for communication between software components -

```{figure} Assets/images/IOHWAB_Cdd_Ipc_RegisterClient.png
:alt: Invoking MCAL API Cdd_Ipc RegisterClient
:align: center
Invoking MCAL API Cdd_Ipc RegisterClient
```

The port connection to software component for Ipc notify is shown below -

```{figure} Assets/images/IpcNotify_PortConnection.png
:alt: Port connection to software component for Ipc notify
:align: center

Port connection to software component for Ipc notify
```

The port connection to software component for Ipc rp is shown below -

```{figure} Assets/images/IpcRp_PortConnection.png
:alt: Port connection to software component for Ipc rp
:align: center

Port connection to software component for Ipc rp
```

### WDG Integration

#### Objective for WDG Integration

The WDG driver provides services for handling the watch dog timer on the microcontroller.

#### List of Modules for WDG Integration

##### MCAL Modules for WDG Integration

| Sl.No. | MCAL Modules | Description | Significance in use case |
|----|--------|----------|----|
|1| Mcu| Manages microcontroller features such as power modes, clock settings, and interrupts. | In this use case this module is used to provide clock for WDG operation. |
|2| WDG | The WDG provides services for handling the watch dog timer on the microcontroller |In this use case, WDG is configured to handle the watch dog timer|

```{Note}
 For detailed information, please refer to the section [WDG Module](./Module_User_Guide_Wdg.md#wdg-module).
```

##### Vector Modules for WDG Integration

| Sl.No. | Vector Modules | Description | Significance in use case |
|----|--------|----------|----|
|1| WDGIf | The main WdgIf functionality consists of linking the overlying Watchdog Manager module (WdgM) <br> to one or more underlying WDG drivers|In this use case, WdgIf ensures operation between application <br> software and the WDG driver.|
|2| WDGM| The Watchdog Manager (WdgM) is responsible for supervising the software components and ensuring <br> system health by monitoring the execution flow of supervised entities.|In this use case, WDGM supervises the software components and ensures system health.|
|3| OS (MICROSAR Operating System)| The Operating System is mainly responsible for handling of tasks and interrupts.| In this use case, it used to define a periodic task. |
|4| RTE (MICROSAR Runtime Environment) | The Runtime Environment module manages the information flow between <br> Software Components (SWCs), BSW and CDDs.|In this use case, it is used to schedule the periodic task defined in OS. |
|5| DET | The DET is used in order to report development errors. The DET can be replaced optionally by an equivalent component which is responsible for recognizing development errors, if no DET component is available.|In this use Case, Development error is enabled to detect all development errors.|

```{Note}
 For detailed information on each module and its features, please refer to the Technical Reference Manual provided by Vector.
```

```{Note}
 For importing MCAL configuration files to DaVinci refer [Importing TI MCAL modules from EB Tresos to Vector DaVinci Configurator](./Integration.md#importing-ti-mcal-modules-from-eb-tresos-to-vector-davinci-configurator).
```

#### Configuration modules in WDG Integration

This chapter explains the basic configurations that are needed to realize WDG functionalities.

##### Wdg Configuration

As part of WDG module integration, WDG module from TI MCAL stack shall be interconnected with vector modules. For that WDG along with its dependent WDG modules shall be configured and provide the reference to WdgIf module. As a first step following Containers and parameters shall be configured in WDG module.

**WdgGeneral:**
The WDGGeneral container is responsible for configuring the global settings of the WDG in the system. It ensures that the WDG operation module is properly set up for tasks such as WDG window size, WDG default mode.

WDG is configured with 100 percent window size as shown below -

```{figure} Assets/images/WdgGeneral.png
:alt: WDG General setting
:align: center

WDG General setting
```

The default mode of WDG is selected as WDGIF_SLOW_MODE and WDG reaction is set to WDG_GENERATE_RESET as shown below -

```{figure} Assets/images/WdgGeneralconfiguration.png
:alt: Wdg General configuration
:align: center

Wdg General configuration
```

##### MCU Configuration for WDG Integration

The Wdg module has dependence on MCU module. Hence, we need to provide clock setting reference in MCU module. Please refer to TechnicalReference_Mcu was used to configure this module.

The MCU clock configuration for WDG driver is shown below -

```{figure} Assets/images/MCUClockWdg.png
:alt: Wdg Mcu Clock reference configuration
:align: center

Wdg Mcu Clock reference configuration
```

##### WdgIf Configuration for WDG Integration

WdgIF is responsible for managing the interaction between the application layer and the underlying WDG driver. To configure WdgIF, the following containers and parameters need to be set up.

**WdgIfDevices:**

WDGIF is configured for WDG usecase realisation. We need to provide WDG driver reference as shown below -

```{figure} Assets/images/WdgIfDevicesconfiguration.png
:alt: WdgIf Devices configuration
:align: center

WdgIf Devices configuration
```

##### WdgM Configuration for WDG Integration

The WdgM monitors safety-relevant applications on the ECU. When the WdgM detects a violation of the preconfigured temporal or logical constraints in the program flow, it takes several configurable actions to log the fault and to go to a safe state after a configurable time delay.

Two WDG check points are created for entry and exit as shown below -

```{figure} Assets/images/Watchdogcheckpointcreation.png
:alt: WDG checkpoint creation
:align: center

WDG checkpoint creation
```

WDG deadline supervision is configured with maximum deadline of 5000 ms and minimum deadline of 10 ms, and the entry and exit references are given as shown below -

```{figure} Assets/images/WatchdogDeadlinesupervisionconfiguration.png
:alt: WDG Deadline supervision configuration
:align: center

WDG Deadline supervision configuration
```

Two different triggers are configured with different WDG modes. One trigger is configured with slow mode, while another with fast mode as shown below -

```{figure} Assets/images/WatchDogTriggers.png
:alt: WDG triggers
:align: center

WDG triggers
```

##### OS Configuration for WDG Integration

The OS module is responsible for task scheduling. Tasks such as 10ms and 1s are created to schedule different schedulable functions for WDG  and respective BSW modules.

The OS configuration is shown below -

```{figure} Assets/images/WatchDogOSConfiguration.png
:alt: OS Configuration
:align: center

OS Configuration
```

##### Rte Configuration for WDG Integration

Runtime Environment (RTE) manages communication between the software components (SWC), assures consistency of the overall information flow between basic software (BSW). It also maps a BswSchedulableEntity onto one OsTask.

The scheduling of the WdgM_MainFunction is shown below -

```{figure} Assets/images/SchedulingWdgM_MainFunction.png
:alt: Scheduling of periodic function - WdgM_MainFunction
:align: center

Scheduling of periodic function - WdgM_MainFunction
```

### DIO Integration

#### Objective for DIO Integration

The intention of DIO integration is to verify DIO functionality by configuring the DIO MCAL and dependent Vector modules. It will facilitate switching of digital signals, representing ON/OFF or HIGH/LOW states, which will be explained in the subsequent chapter.

#### List of Modules for DIO Integration

##### MCAL Modules for DIO

| Sl.No. | MCAL Modules | Description | Significance in use case |
|----|--------|----------|----|
|1| Mcu| The MCU module manages microcontroller features such as power modes, clock settings, and interrupts. |In this use case, this module is responsible for providing the clock for ADC communication. |
|2| DIO | The DIO driver provides port and channel based read and write access to the internal general purpose I/O ports. The read and write behaviour is unbuffered. The basic behaviour of this driver is synchronous. | In this use case, this module is responsible for providing read input from software and send output to controller.|
|3| Port | The PORT module provides an interface to configure and control microcontroller pins (e.g., GPIO, ADC, PWM).|In this use case, this module is responsible for configuring the hardware pins necessary for DIO output.|

```{Note}
 For detailed information, please refer to the section [DIO Module](./Module_User_Guide_Dio.md#dio-module).
```

##### Vector Modules for DIO

| Sl.No. | Vector Modules | Description | Significance in use case |
|----|--------|----------|----|
|1| IoHwAb | The IoHwAb module provides a layer between the ECU software and the hardware. It allows higher-level software to access I/O hardware (like ADCs or DIOs) in a standardized way. |In this use case, IoHwab layer provides wrapper function for each of the underlying ADC API's, so that the application is independent on the hardware.|
|2| OS (MICROSAR Operating System)| The Operating System is mainly responsible for handling tasks and interruptions.| In this use case, OS module is used to define periodic tasks needed for ADC communication such as processing transmit and receive message. |
|3| RTE (MICROSAR Runtime Environment) | The Runtime Environment module manages the information flow between Software Components (SWCs), BSW and CDDs.|In this use case, Rte module is used to schedule the periodic tasks defined in the operating system (OS) and sender receiver ports created for sending receiving can messages from application. |
|5| DET | The DET is used in order to report development errors. The DET can be replaced optionally by an equivalent component which is responsible for recognizing development errors, if no DET component is available.|In this use Case, Development error is enabled to detect all development errors.|

```{Note}
 For detailed information on each module and its features, please refer to the Technical Reference Manual provided by Vector.
```

```{Note}
 For importing MCAL configuration files to DaVinci refer [Importing TI MCAL modules from EB Tresos to Vector DaVinci Configurator](./Integration.md#importing-ti-mcal-modules-from-eb-tresos-to-vector-davinci-configurator).
```

#### Configuration of modules in DIO integration

This chapter explains the basic configurations that are needed to realize DIO functionality.

##### DIO Configuration

TI DIO driver is configured using EB Tresos tool. It is then imported to Vector DaVinci configurator for integration with upper layers like IoHwAb. Following containers and parameters shall be configured.

**DioGeneral:**

The DioGeneral contains the enabling and disabling of apis. The following figure shows the enabling DioFlipChannel api -

```{figure} Assets/images/Dio_General.png
:alt: configuration for DioGeneral
:align: center

configuration for DioGeneral
```

**DioPort:**

The DioPort container is used to configure groups of DIO channels (GPIO pins) under a logical port. Each port (e.g., GPIOAB, GPIOCD) is assigned a unique DioPortId for identification. This setup enables efficient handling of multiple pins together using AUTOSAR DIO APIs. The example shows five ports with IDs from 0 to 4 -

```{figure} Assets/images/Dio_port.png
:alt: configuration for DioPort
:align: center

configuration for DioPort
```

**DioChannel:**

The DioChannel container in the EB Tresos tool is used to configure individual DIO (Digital Input/Output) channels within a specified DIO port. In this example, the port being configured is named GPIOAB.
Under the DioChannel tab, each row represents a single DIO channel configuration. Each DIO channel is assigned a unique DioChannelId which acts as an identifier used in the application code for referencing the channel -

```{figure} Assets/images/Dio_channel.png
:alt: Configuration for DioChannel
:align: center

Configuration for DioChannel
```

The port pin 128 in DIO channel is configured as shown below -

```{figure} Assets/images/Dio_channel_port_pin.png
:alt: Configuration for Port pin 128
:align: center

Configuration for Port pin 128
```

**DioChannelGroup:**

The DioChannelGroup contains the configuration of DIO port mask and port offset value. The DioChannelGroup configuration is shown below -

```{figure} Assets/images/Dio_ChannelGroup.png
:alt: configuration for DioChannelGroup
:align: center

configuration for DioChannelGroup
```

##### Port Configuration for DIO Integration

The port pin configuration of DIO channel is shown below -

```{figure} Assets/images/Port_DIo.png
:alt: Configuration for Portpin
:align: center

Configuration for Portpin
```

The PortPinMode configuration of DIO channel is shown below -

```{figure} Assets/images/Dio_PortPinMode.png
:alt: Configuration for PortpinMode
:align: center

Configuration for PortpinMode
```

##### IoHwAb Configuration for DIO Integration

The configuration process for determining the IoHwAb_DioFlipChannel API in the IoHwAbCSPortInterfaces container is shown below -

```{figure} Assets/images/Dio_FlipChannelIoHwAb.png
:alt: Configuration for DIO IoHwAbCSPortInterface
:align: center

Configuration for DIO IoHwAbCSPortInterface
```

The configuration process for determining IoHwAbDioFlipChannel API in the IoHwAbCSPortPrototypes container is shown below -

```{figure} Assets/images/Dio_FlipChannelIoHwAb1.png
:alt: Configuration for DIO IoHwAbCSPortPrototypes
:align: center

Configuration for DIO IoHwAbCSPortPrototypes
```

The function call interaction between the IoHwAb module and the Mcal module API is shown below -

```{figure} Assets/images/Dio_FlipChannelIoHwAb2.png
:alt: Function call between IoHwAb and DIO
:align: center

Function call between IoHwAb and DIO
```

##### Os Configuration for DIO Integration

The OS module is responsible for task scheduling. Tasks such as 10ms are created to schedule TestApp_DioRunnable. The following figure is shown below -

```{figure} Assets/images/Dio_os.png
:alt: OsAlarms configuration for DIO
:align: center

OsAlarms configuration for DIO
```

##### Rte Configuration for DIO Integration

TestApp_DioRunnable is mapped to a 10ms task and will be called periodically every 10ms by the OS task to execute the runnable.The following figure is shown below -

```{figure} Assets/images/Dio_Rte.png
:alt: creating 10ms task for DIO runnable
:align: center

creating 10ms task for DIO runnable
```

### CDD_I2C Integration

#### Objective for CDD_I2C Integration

The intention of I2C Integration is to enable successful I2C communication by configuring TI MCAL modules along with Vector BSW Modules. Further details are explained in the subsequent chapter.

#### List of Modules for CDD_I2C Integration

##### MCAL Modules for CDD_I2C Integration

| Sl.No. | MCAL Modules | Description | Significance in use case |
|----|--------|----------|----|
|1| I2C | I2C (Inter-Integrated Circuit) is a two-wire serial communication protocol using SDA (data) and SCL (clock) lines. It allows a master to communicate with one or more slave devices using unique addresses. I2C is commonly used for connecting low-speed peripherals like sensors, EEPROMs, and displays in embedded systems.| In this use case, this module is responsible for configure I2C channel list and Sequence.|
|2| Mcu | Manages microcontroller features such as power modes, clock settings, and interrupts. | In this use case this module is used to provide clock for I2C operation. |
|3| Port | Provides an interface to configure and control microcontroller pins (e.g., GPIO, ADC, PWM). | In this use case, this module is responsible for configuring the hardware pins necessary for I2C communication. |

```{Note}
 For detailed information, please refer to the section [CDD_I2C Module](./Module_User_Guide_Cdd_I2c.md#cdd_i2c-module).
```

##### Vector Modules for CDD_I2C Integration

| Sl.No. | Vector Modules | Description | Significance in use case |
|----|--------|----------|----|
|1| IoHwAb | This module provides an abstraction layer for handling hardware-related input/output operations.<br> It facilitates interaction with  IPC hardware resources for data exchange between processor cores. |In this use case,it abstracts the IPC driver and facilitates interaction ,<br> between the application layer and the underlying inter-core communication mechanism.|
|2| DET | The DET is used in order to report development errors. The DET can be replaced optionally by an equivalent component which is responsible for recognizing development errors, if no DET component is available.|In this use Case, Development error is enabled to detect all development errors.|
|3| RTE (MICROSAR Runtime Environment) | The Runtime Environment module manages the information flow between Software Components (SWCs), BSW and CDDs.|In this use case, Rte module is used to schedule the periodic tasks defined in the operating system (OS) and sender receiver ports created for sending receiving can messages from application. |

```{Note}
For detailed information on each module and its features, please refer to the Technical Reference Manual provided by Vector.
```

```{Note}
For importing MCAL configuration files to DaVinci refer [Importing TI MCAL modules from EB Tresos to Vector DaVinci Configurator](./Integration.md#importing-ti-mcal-modules-from-eb-tresos-to-vector-davinci-configurator).
```

#### Configuration modules in CDD_I2C Integration

This chapter explains the basic configurations that are needed to realize CDD I2C communication.

##### CDD_I2C Configuration

As part of I2C module integration, I2C module from TI MCAL stack shall be interconnected with vector modules. For that I2C along with its dependent I2C modules shall be configured and provide the reference to other module. As a first step following Containers and parameters shall be configured in I2C module.

**I2cGeneral:**

General configuration settings for Complex Device Drivers are defined in the container, which includes options to enable or disable API and IRQ types, as shown below -

```{figure} Assets/images/I2c_General.png
:alt: Configuration for CddI2cGeneral
:align: center

Configuration for CddI2cGeneral
```

**CddI2cHwConfig:**

This container contains the HW unit initialization parameters. The HwUnitType and ChannelBitRate, HwUnitFrequency and ClkInputSrc are shown below -

```{figure} Assets/images/I2cHwConfig.png
:alt: Configuration for CddI2cHwConfig
:align: center

Configuration for CddI2cHwConfig
```

**CddI2cChannelConfig:**

This container includes the channel configurations. The I2C channel direction, ChannelSlaveAddress, and SlaveAddressScheme are shown below -

```{figure} Assets/images/I2cChannelConfig.png
:alt: Configuration for CddI2cChannelConfig
:align: center

Configuration for CddI2cChannelConfig
```

**CddI2cSequenceConfig:**

This container contains the Sequence configurations. The I2C Channel SequenceHwUnitType, NumberOfChannelsInSequence and SequenceCompleteNotify and SequenceErrorNotify are shown below -

```{figure} Assets/images/I2cSequenceConfig.png
:alt: Configuration for CddI2cSequenceConfig
:align: center

Configuration for CddI2cSequenceConfig
```

**I2cChannelList:**

References to I2C channels and their order within the Sequence shown below -

```{figure} Assets/images/I2cChannelList.png
:alt: Configuration for I2cChannelList
:align: center

Configuration for I2cChannelList
```

##### MCU Configuration for CDD_I2C Integration

The I2C module has dependence on MCU module. Hence, we need to provide clock setting reference in MCU module. Please refer to TechnicalReference_Mcu was used to configure this module.
The following figure illustrates the configuration process for determining I2C clock reference point configuration -

```{figure} Assets/images/I2cMcuClockReference.png
:alt: Configuration for McuClockSettingConfig_I2C
:align: center

Configuration for McuClockSettingConfig_I2C
```

##### Port Configuration for CDD_I2C Integration

In the configuration of the port for the I2C module, the port pins are used to facilitate the I2C data line as shown below -

```{figure} Assets/images/I2c_PortPin.png
:alt: Configuration for I2C Port pin
:align: center

Configuration for I2C Port pin
```

Similarly, port pin for I2C clock line can be configured.

##### IoHwAb Configuration for CDD_I2C Integration

IoHwAb is a layer in the AUTOSAR architecture that abstracts hardware-level interfaces and provides a standardized API to the upper layers.
To configure a Client/Server Port Interface, the container Cdd_I2c_AsyncTransmit holds the configuration elements for a Client/Server template interface. This interface is instantiated by a Client/Server Port Prototype.
The container IoHwAbOperationArguments contains the configuration of Operation Elements, such as Cdd_I2c_SetupEB, and IoHwAbOperationArgument, for a Client/Server Operation. These Operation Elements will be generated as function parameters in the I/O Hardware Abstraction (IoHwAb) implementation.
Similarly, it is possible to enable communication between the I/O Client/Server interface and the MCAL APIs.
Configuration of Cdd_I2c IoHwAbCS port interface as shown below -

```{figure} Assets/images/IoHwAb_I2c.png
:alt: Configuration for Cdd_I2C IoHwAbCSPortInterface
:align: center

Configuration for Cdd_I2C IoHwAbCSPortInterface
```

The container AsyncTransmit is used for configuring a Client/Server Port Prototype. This container represents an instantiation of a Client/Server Port Interface.
Configuration of Cdd_I2c IoHwAbCS port prototype as shown below -

```{figure} Assets/images/IoHwAb_I2c1.png
:alt: Configuration for Cdd_I2C IoHwAbCSPortPrototypes
:align: center

Configuration for Cdd_I2C IoHwAbCSPortPrototypes
```

The function IoHwAb_Construct_Wrapper is generated, and then the MCAL API function Cdd_I2c_AsyncTransmit is called. In the RTE (Runtime Environment), the corresponding port is created based on the configuration, and it can be used as a Sender-Receiver Port for communication between software components -

```{figure} Assets/images/IoHwab_to_I2c_Connection.png
:alt: Invoking MCAL API Cdd_I2c_AsyncTransmit
:align: center

Invoking MCAL API Cdd_I2c_AsyncTransmit
```

The port connection to software component for I2C is shown below -

```{figure} Assets/images/I2c_portconnection.png
:alt: Port connection to software component for CDD_I2C
:align: center

Port connection to software component for CDD_I2C
```

### ICU Integration

#### Objective for ICU Integration

The objective of ICU integration is to achieve accurate duty cycle measurement of the PWM signal by configuring TI MCAL modules in coordination with Vector BSW modules. Further implementation details are provided in the subsequent chapter.

#### List Of Modules for ICU

##### MCAL Modules for ICU Integration

| Sl. No. | MCAL Modules | Description | Significance in use case |
|----|--------|----------|----|
|1| Mcu| The MCU module manages microcontroller features for PWM, such as power modes and clock settings.|In this use case, this module is responsible for providing the clock for PWM signal generation. |
|2| Port | The PORT module provides an interface to configure and control microcontroller pins (e.g., GPIO, ADC, PWM). | In this use case, this module is responsible for configuring the hardware pins necessary for ICU signal capturing. |
|3| ICU | The Input Capture Unit (ICU) is a peripheral used to detect and timestamp signal edges (rising/falling) on an input pin. It enables measurement of signal characteristics such as frequency, period, and duty cycle, commonly used for PWM analysis.| In this use case, the ICU is used to measure the duty cycle and period of a signal.|

```{Note}
For detailed information, please refer to the section [ICU Module](./Module_User_Guide_Icu.md#icu-module).
```

##### Vector Modules for ICU Integration

| Sl. No. | Vector Modules | Description | Significance in use case |
|----|--------|----------|----|
|1| IoHwAb | The aim of the IoHwAb is to provide ECU hardware-independent data transition from driver modules up to the Software Components. |It provides an abstraction for the ICU driver and enables communication with the application layer.|
|2| DET | The DET is used in order to report development errors. The DET can be replaced optionally by an equivalent component which is responsible for recognizing development errors, if no DET component is available.|In this use Case, Development error is enabled to detect all development errors.|
|3| RTE (MICROSAR Runtime Environment) | The Runtime Environment module manages the information flow between Software Components (SWCs), BSW and CDDs.|In this use case, Rte module is used to schedule the periodic tasks defined in the operating system (OS) and sender receiver ports created for sending receiving can messages from application. |

```{Note}
 For detailed information on each module and its features, please refer to the Technical Reference Manual provided by Vector.
```

```{Note}
 For importing MCAL configuration files to DaVinci refer [Importing TI MCAL modules from EB Tresos to Vector DaVinci Configurator](./Integration.md#importing-ti-mcal-modules-from-eb-tresos-to-vector-davinci-configurator).
```

#### Configuration of modules in ICU Integration

This chapter explains the basic configurations that are needed to realize ICU functionalities.

##### ICU Configuration

The TI ICU driver is configured using the EB Tresos tool. It is then imported into the Vector DaVinci Configurator for integration with the application software. The following containers and parameters shall be configured.

**IcuGeneral:**

Configuration of general ICU parameters involves enabling or disabling the required macros, as shown below -

```{figure} Assets/images/Icu_General.png
:alt: Configuration for IcuGeneral
:align: center

Configuration for IcuGeneral
```

**IcuChannel:**

The configuration of an individual ICU channel involves assigning the IcuChannelId, selecting the appropriate mode (e.g., timestamp or edge detection), setting the XBAR (crossbar) references, and configuring the ICU functional clock. These settings define how the channel will operate and interface with hardware resources, as illustrated in the configuration below -

```{figure} Assets/images/Icu_Channel.png
:alt: Configuration for IcuChannel
:align: center

Configuration for IcuChannel
```

**IcuSignalMeasurement:**

This container holds the configuration parameters for the measurement mode set to IcuSignalMeasurement. In this configuration, the signal measurement property is set to ICU_PERIOD_TIME to enable period time measurement of the input signal -

```{figure} Assets/images/Icu_SignalMeasurementProperty.png
:alt: Configuration for IcuSignalMeasurementPropety
:align: center

Configuration for IcuSignalMeasurementPropety
```

##### MCU Configuration in ICU Module

The following figure demonstrates the configuration of the ECAP0 interrupt within the MCU module for AM263Px. In this setup, the ECAP0 interrupt is routed through the XBAR (Crossbar) configuration. Specifically, MCU_INTRXBAR0_OUT_2 is selected as the output line, which is then mapped to MCU_INT_XBAR_EPWM3_INT. This routing enables the ECAP0 event to be captured correctly by the desired interrupt source -

```{figure} Assets/images/Mcu_XbarChannelTriggerIcu.png
:alt: Configuration for McuXbarChannelTrigger Configuration
:align: center

Configuration for McuXbarChannelTrigger Configuration
```

The following configuration illustrates the setup of an input XBAR trigger channel within the MCU module. In this example, MCU_INPUT_XBAR0_OUT_2 is selected as the output XBAR line, and it is mapped to the input source MCU_INPUT_XBAR_GPIO49. This mapping allows an external signal on GPIO49 to be routed through XBAR0 output channel 2, enabling it to trigger peripherals such as ECAP, EPWM, or other interrupt-driven modules -

```{figure} Assets/images/Mcu_InputXbarChannelTriggerIcu.png
:alt: Configuration for McuInputXbarChannelTrigger Configuration
:align: center

Configuration for McuInputXbarChannelTrigger Configuration
```

##### Port Configuration in ICU Module

The PWM module has a dependency on the Port module to configure the output pins used for generating PWM signals. Each PWM channel is mapped to a specific physical pin on the microcontroller, which must be configured as an output using the Port module.

In the port pin configuration, EPWM3 is configured as a PWM output, as shown below -

```{figure} Assets/images/Icu_Port.png
:alt: Port pin configuration for Pwm
:align: center
Port Pin configuration for Pwm
```

##### IoHwAb Configuration in ICU Module

IoHwAb is a layer in the AUTOSAR architecture that abstracts hardware-level interfaces and provides a standardized API to the upper layers.
To configure a Client/Server Port Interface, the container IoHwAb_IcuStartSignalMeasurement holds the configuration elements for a Client/Server template interface. This interface is instantiated by a Client/Server Port Prototype.
The container IoHwAbOperationArguments contains the configuration of Operation Elements, such as Channel for a Client/Server Operation. These Operation Elements will be generated as function parameters in the I/O Hardware Abstraction (IoHwAb) implementation.
Similarly, it is possible to enable communication between the I/O Client/Server interface and the MCAL APIs.
Configuration of ICU IoHwAbCS port interface as shown below -

```{figure} Assets/images/IoHwAb_Icu.png
:alt: Configuration of ICU CSPortinterface
:align: center
Configuration of ICU CSPortinterface
```

The container IoHwAbIcuStartSignalMeasurement is used for configuring a Client/Server Port Prototype. This container represents an instantiation of a Client/Server Port Interface.
Configuration of cddIcu IoHwAbCS port prototype as shown below -

```{figure} Assets/images/IoHwAb_Icu1.png
:alt: Configuration of ICU PortPrototype
:align: center
Configuration of ICU PortPrototype
```

The function IoHwAb_IcuStartSignalMeasurement Operation is generated, and then the MCAL API function Icu_StartSignalMeasurement is called. In the RTE (Runtime Environment), the corresponding port is created based on the configuration, and it can be used as a Sender-Receiver Port for communication between software components -

```{figure} Assets/images/IoHwAb_IcuFun.png
:alt: Invoking MCAL API for Icu_StartSignalMeasurement
:align: center
Invoking MCAL API for Icu_StartSignalMeasurement
```

### GPT Integration

#### Objective for GPT Integration

The intention of GPT Integration is to verify successful GPT functionalities by configuring TI MCAL modules along with Vector BSW Modules. Further details are explained in the subsequent chapter.

#### List of Modules for GPT Integration

##### MCAL Modules for GPT Integration

| Sl. No. | MCAL Modules | Description | Significance in use case |
|----|--------|----------|----|
|1| Mcu| The MCU module manages microcontroller features for PWM, such as power modes and clock settings.|In this use case, this module is responsible for providing the clock for GPT module. |
|2| GPT |The GPT module initializes and manages hardware timers, enabling start/stop control, time value reading, and interrupt notifications. It operates in timer ticks, and conversion to real-time units must be handled by the application using clock and prescaler settings. | In this use case, this module responsible for providing 1ms toggling of DIO port pin in continuous mode. |

```{Note}
For detailed information, please refer to the section [GPT Module](./Module_User_Guide_Gpt.md#gpt-module).
```

##### Vector Modules for GPT Integration

| Sl. No. | Vector Modules | Description | Significance in use case |
|----|--------|----------|----|
|1| IoHwAb | The aim of the IoHwAb is to provide ECU hardware-independent data transition from driver modules up to the Software Components. |It provides an abstraction for the ICU driver and enables communication with the application layer.|
|2| DET | The DET is used in order to report development errors. The DET can be replaced optionally by an equivalent component which is responsible for recognizing development errors, if no DET component is available.|In this use Case, Development error is enabled to detect all development errors.|
|3| RTE (MICROSAR Runtime Environment) | The Runtime Environment module manages the information flow between Software Components (SWCs), BSW and CDDs.|In this use case, Rte module is used to schedule the periodic tasks defined in the operating system (OS) and sender receiver ports created for sending receiving can messages from application. |

```{Note}
 For detailed information on each module and its features, please refer to the Technical Reference Manual provided by Vector.
```

```{Note}
 For importing MCAL configuration files to DaVinci refer [Importing TI MCAL modules from EB Tresos to Vector DaVinci Configurator](./Integration.md#importing-ti-mcal-modules-from-eb-tresos-to-vector-davinci-configurator).
```

#### Configuration of modules in GPT Integration

This chapter explains the basic configurations that are needed to realize GPT functionalities.

##### GPT Configuration

**GptConfigurationOfOptApiServices:**

This container contains all configuration switches for configuring the optional API services of the GPT driver. The following figure shows the enabling of Apiâ€™s -

```{figure} Assets/images/Gpt_OptApiServices.png
:alt: Configuration for GptConfigurationOfOptApiServices
:align: center
Configuration for GptConfigurationOfOptApiServices
```

**GptDriverConfiguration:**

This container contains the module-wide configuration (parameters) of the GPT Driver. The following figure shows the configuration of interrupt function and prescaler value and Gpt timeout duration -

```{figure} Assets/images/Gpt_DriverConfiguration.png
:alt: Configuration for GptDriverConfiguration
:align: center
Configuration for GptDriverConfiguration
```

**GptChannelConfiguration:**

This container serves as the base of a Configuration Set, holding the configured GPT channels. It allows definition of multiple configuration sets for post-build usage, where each GPT channel is assigned a channel ID, mode, and optional notification function -

```{figure} Assets/images/Gpt_ChannelConfiguration.png
:alt: Configuration for GptChannelConfiguration
:align: center
Configuration for GptChannelConfiguration
```

##### Mcu Configuration in GPT Integration

The GPT module relies on the MCU module to supply the necessary clock configurations.
The MCU clock configuration for GPT driver is shown below -

```{figure} Assets/images/McuClockSetting_Gpt.png
:alt: Configuration for McuClockSettingConfig
:align: center
Configuration for McuClockSettingConfig
```

GPT clock should be derived from MCU clock reference point.
The MCU clock reference point is shown below -

```{figure} Assets/images/McuClockRef_Gpt.png
:alt: Configuration for McuClockReferencePoint
:align: center
Configuration for McuClockReferencePoint
```

##### IoHwAb Configuration in GPT Integration

IoHwAb is a layer in the AUTOSAR architecture that abstracts hardware-level interfaces and provides a standardized API to the upper layers.
To configure a Client/Server Port Interface, the container IoHwAb_GptStartTimer holds the configuration elements for a Client/Server template interface. This interface is instantiated by a Client/Server Port Prototype.
The container IoHwAbOperationArguments contains the configuration of Operation Elements, such as Channel for a Client/Server Operation. These Operation Elements will be generated as function parameters in the I/O Hardware Abstraction (IoHwAb) implementation.
Similarly, it is possible to enable communication between the I/O Client/Server interface and the MCAL APIs.
Configuration of ICU IoHwAbCS port interface as shown below -

```{figure} Assets/images/Gpt_IoHwAb_GptStartTimer.png
:alt: Configuration of GPT CSPortinterface
:align: center

Configuration of GPT CSPortinterface
```

The container IoHwAbGptStartTimer is used for configuring a Client/Server Port Prototype. This container represents an instantiation of a Client/Server Port Interface.
Configuration of Gpt IoHwAbCS port prototype as shown below -

```{figure} Assets/images/Gpt_IoHwAbGptStartTimer.png
:alt: Configuration of GPT PortPrototype
:align: center

Configuration of GPT PortPrototype
```

The function IoHwAb_GptStartTimer Operation is generated, and then the MCAL API function Icu_StartSignalMeasurement is called. In the RTE (Runtime Environment), the corresponding port is created based on the configuration, and it can be used as a Sender-Receiver Port for communication between software components -

```{figure} Assets/images/IoHwAb_Gpt.png
:alt: Invoking MCAL API for Gpt_StartTimer
:align: center

Invoking MCAL API for Gpt_StartTimer
```

### CDD FSI Integration

#### Objective for CDD FSI Integration

The intention of CDD FSI Integration is to enable successful CDD FSI communication by configuring TI MCAL modules along with Vector BSW Modules. Further details are explained in the subsequent chapter.

#### List of Modules for CDD FSI Integration

##### MCAL Modules for CDD FSI Integration

| Sl. No. | MCAL Modules | Description | Significance in use case |
|----|--------|----------|----|
|1| FsiRx | The Fast Serial Interface (FSI) is a high-speed serial communication module designed for reliable data transfer, especially across isolation barriers without needing extra components. It includes two separate parts: the CDD FSI Transmitter (CDD FSI TX) and the CDD FSI Receiver (CDD FSI RX). These are implemented as Complex Device Drivers (CDD) in AUTOSAR and work independently from each other.|In this use case, this module is responsible for reception of transmitted data. |
|2| FsiTx | The Fast Serial Interface (FSI) is a high-speed serial communication module designed for reliable data transfer, especially across isolation barriers without needing extra components. It includes two separate parts: the CDD FSI Transmitter (CDD FSI TX) and the CDD FSI Receiver (CDD FSI RX). These are implemented as Complex Device Drivers (CDD) in AUTOSAR and work independently from each other.|In this use case, this module is responsible for transmitting data frames. |
|3| Mcu| The MCU module manages microcontroller features for PWM, such as power modes and clock settings.|In this use case, this module is responsible for providing the clock for FSI clock generation. |

```{Note}
For detailed information, please refer to the section [FSIRX Module](./Module_User_Guide_Cdd_FsiRx.md#cdd_fsirx-module).
For detailed information, please refer to the section [FSITX Module](./Module_User_Guide_Cdd_FsiTx.md#cdd_fsitx-module).
```

##### Vector Modules for CDD FSI Integration

| Sl. No. | Vector Modules | Description | Significance in use case |
|----|--------|----------|----|
|1| IoHwAb | The aim of the IoHwAb is to provide ECU hardware-independent data transition from driver modules up to the Software Components. |It provides an abstraction for the CDD FSI driver and enables communication with the application layer.|
|2| DET | The DET is used in order to report development errors. The DET can be replaced optionally by an equivalent component which is responsible for recognizing development errors, if no DET component is available.|In this use Case, Development error is enabled to detect all development errors.|
|3| RTE (MICROSAR Runtime Environment) | The Runtime Environment module manages the information flow between Software Components (SWCs), BSW and CDDs.|In this use case, Rte module is used to schedule the periodic tasks defined in the operating system (OS) and sender receiver ports created for sending receiving can messages from application. |

```{Note}
 For detailed information on each module and its features, please refer to the Technical Reference Manual provided by Vector.
```

```{Note}
 For importing MCAL configuration files to DaVinci refer [Importing TI MCAL modules from EB Tresos to Vector DaVinci Configurator](./Integration.md#importing-ti-mcal-modules-from-eb-tresos-to-vector-davinci-configurator).
```

#### Configuration of modules in CDD FSI Integration

This chapter explains the basic configurations that are needed to realize CDD FSI communication.

##### FsiRx Configuration

**CddFsiRxConfigSet:**

This container contains the configuration parameters and sub containers of the AUTOSAR CDD FSI Rx module. The configuration below shows the configuration of callback functions configuration -

```{figure} Assets/images/CddFsiRxConfigSet.png
:alt: Configuration for CddFsiRxConfigSet
:align: center

Configuration for CddFsiRxConfigSet
```

**CddFsiRxGeneral:**

The CDDFsiRxGeneral contains the enabling and disabling required apis and gives interrupt function type, interrupt vector, number of DMA channelIds and MaxHwUnitCount as shown below -

```{figure} Assets/images/CddFsiRxGeneral.png
:alt: Configuration for CddFsiRxGeneral
:align: center

Configuration for CddFsiRxGeneral
```

**CddFsiRxHwUnit:**

This container holds the driver configuration parameters used to set up the CDD FSI Rx hardware unit. The configuration includes the HwUnitId, RxPingWdgTimerTimeout, RxFrameWdgTimerTimeout, and the CDD FSI Rx reception method, which can be set to Interrupt mode, Polling mode, or DMA mode. The figure below illustrates a configuration where the reception method is set to Interrupt mode -

```{figure} Assets/images/CddFsiRxHwUnit.png
:alt: Configuration for CddFsiRxHwUnit
:align: center

Configuration for CddFsiRxHwUnit
```

##### FsiTx Configuration

**CddFsiTxConfigSet:**

This container contains the configuration parameters and sub containers of the AUTOSAR CDD FSI Tx module. The configuration below shows the configuration of callback functions configuration -

```{figure} Assets/images/CddFsiTxConfigSet.png
:alt: Configuration for CddFsiTxConfigSet
:align: center

Configuration for CddFsiTxConfigSet
```

**CddFsiTxGeneral:**

The CDDFsiTxGeneral contains the enabling and disabling required apis and gives interrupt function type, interrupt vector, number of DMA channelIds and MaxHwUnitCount as shown below -

```{figure} Assets/images/CddFsiTxGeneral.png
:alt: Configuration for CddFsiTxGeneral
:align: center

Configuration for CddFsiTxGeneral
```

**CddFsiTxHwUnit:**

This container holds the driver configuration parameters used to set up the CDD FSI Tx hardware unit. The configuration includes the HwUnitId, TxPingTimerTimeout, TxPrescale, and the CDD FSI Tx transmission method, which can be set to Interrupt mode, Polling mode, or DMA mode. The figure below illustrates a configuration where the reception method is set to Interrupt mode.

```{figure} Assets/images/CddFsiTxHwUnit.png
:alt: Configuration for CddFsiTxHwUnit
:align: center

Configuration for CddFsiTxHwUnit
```

##### port configuration for CDD FSI Integration

The CDD FSI Rx module has a dependency on the Port module to configure the output pins used. Each CDD FSI Rx channel is mapped to a specific physical pin on the microcontroller, which must be configured as an output using the Port module. Configuration of a CDD FSI Rx CLK pin is as shown below.
The following figure shows port pin configuration of CDD FSI Rx where PIN_E1 is configured as FSIRX1_CLK -

```{figure} Assets/images/CddFsiRx_PortCfg.png
:alt: configuration for FsiRx1_CLK
:align: center

configuration for FsiRx1_CLK
```

The CDD FSI Tx module has a dependency on the Port module to configure the output pins used. Each CDD FSI Tx channel is mapped to a specific physical pin on the microcontroller, which must be configured as an output using the Port module. Configuration of a CDD FSI Tx CLK pin is as shown below.
The following figure shows port pin configuration of CDD FSI Tx where PIN_E4 is configured as FSITX1_CLK -

```{figure} Assets/images/CddFsiTx_PortCfg.png
:alt: configuration for FsiTx1_CLK
:align: center

configuration for FsiTx1_CLK
```

##### IoHwAb configuration for CDD FSI Integration

IoHwAb is a layer in the AUTOSAR architecture that abstracts hardware-level interfaces and provides a standardized API to the upper layers.
To configure a Client/Server Port Interface, the container IoHwAb_Cdd_FsiRx_GetStatus holds the configuration elements for a Client/Server template interface. This interface is instantiated by a Client/Server Port Prototype.
The container IoHwAbOperationArguments contains the configuration of Operation Elements, such as Channel for a Client/Server Operation. These Operation Elements will be generated as function parameters in the I/O Hardware Abstraction (IoHwAb) implementation.
Similarly, it is possible to enable communication between the I/O Client/Server interface and the MCAL APIs.
Configuration of ICU IoHwAbCS port interface as shown below -

```{figure} Assets/images/IoHwAb_FsiRx_getstatus.png
:alt: Configuration of CDD FSI CSPortinterface
:align: center

Configuration of CDD FSI CSPortinterface
```

The container IoHwAbCddFsiRxGetStatus is used for configuring a Client/Server Port Prototype. This container represents an instantiation of a Client/Server Port Interface.
Configuration of cddFsi IoHwAbCS port prototype as shown below -

```{figure} Assets/images/IoHwAb_FsiRx_getstatus1.png
:alt: Configuration of CDD FSI PortPrototype
:align: center

Configuration of CDD FSI PortPrototype
```

The function IoHwAb_CddFsiRxGetStatus Operation is generated, and then the MCAL API function CddFsiRx_GetStatus is called. In the RTE (Runtime Environment), the corresponding port is created based on the configuration, and it can be used as a Sender-Receiver Port for communication between software components -

```{figure} Assets/images/CddFsiRx_GetStatus.png
:alt: Invoking MCAL API for CddFsiRx_GetStatus
:align: center

Invoking MCAL API for CddFsiRx_GetStatus
```

### CDD_UART Integration

#### Objective for CDD_UART Integration

The intention of UART Integration is to enable successful UART communication by configuring TI MCAL modules along with Vector BSW Modules. Further details are explained in the subsequent chapter.

#### List of Modules for CDD_UART Integration

##### MCAL Modules for CDD_UART Integration

| Sl.No. | MCAL Modules | Description | Significance in use case |
|----|--------|----------|----|
|1| UART | The UART module initializes and controls the internal UART peripherals of the microcontroller. It provides services to configure baud rate, frame format, and to transmit and receive data over serial communication channels.| In this use case UART module is responsible for enabling serial communication between the microcontroller and external devices. Moreover it facilitates reliable data transmission and reception through asynchronous communication.|
|2| Mcu| The MCU module manages microcontroller features for UART, such as clock configuration, power modes, and interrupt settings required for UART communication.|In this use case, this module is responsible for providing the clock and initialization required for UART-based serial communication between the microcontroller and external devices. |
|3| Port | The PORT module provides an interface to configure and control the microcontroller pins used for UART communication, such as setting the TX and RX pins to the appropriate functions. | In this use case, this module is responsible for configuring the hardware pins necessary for UART communication, such as setting the TX and RX pins to their correct functions. |

```{Note}
For detailed information, please refer to the section [CDD_UART Module](./Module_User_Guide_Cdd_uart.md#cdd-uart-module).
```

##### Vector Modules for CDD_UART Integration

| Sl.No. | Vector Modules | Description | Significance in use case |
|----|--------|----------|----|
|1| IoHwAb |  This module provides an abstraction layer for handling UART operations, enabling seamless interaction with UART hardware channels. |It provides an abstraction for the UART driver and enables communication with the application layer.|
|2| OS |  The Operating System is mainly responsible for handling tasks. | In this use case, it is used to initialize UART and manage UART-related task scheduling.|
|3| Rte | The Runtime Environment module manages the information flow between software components and the ECU abstraction layers.  | In this use case, it is used to schedule and route UART communication tasks between the application and lower layers. |

```{Note}
 For detailed information on each module and its features, please refer to the Technical Reference Manual provided by Vector.
```

```{Note}
 For importing MCAL configuration files to DaVinci refer [Importing TI MCAL modules from EB Tresos to Vector DaVinci Configurator](./Integration.md#importing-ti-mcal-modules-from-eb-tresos-to-vector-davinci-configurator).
```

#### Configuration of modules in CDD_UART Integration

This chapter explains the basic configurations that are needed to realize CDD UART functionalities.

##### CDD_UART Configuration

The UART driver is configured using the EB Tresos tool and then imported into the Vector DaVinci Configurator for integration with the application software. The following containers and parameters should be configured.

**CDD_UART General:**

The UART General container provides general configuration settings for the UART module.

In UART general settings, CddUartReadApi, CddUartWriteApi and CddUartirq Type is enabled as shown below -

```{figure} Assets/images/Configuration_for_CDD_UART_General_settings.png
:alt: Configuration for CDD_UART General settings
:align: center

Configuration for CDD_UART General settings
```

**CDD_UART Channel:**

The CddUartChannel configuration container defines the configuration parameters for an individual UART channel.

In CddUartChannel configuration, The user needs to specify the CddUartHwID and CddUartIOMode as shown below -

```{figure} Assets/images/Configuration_of_cdduart_channel.png
:alt: Configuration of CddUarChannel settings
:align: center

Configuration of CddUarChannel settings
```

##### Mcu Configuration for CDD_UART Integration

The UART module relies on the MCU module to supply the necessary clock configurations.

The MCU clock configuration for UART driver is shown below -

```{figure} Assets/images/General_Configuration_of_MCU_Clock.png
:alt: General Configuration of MCU Clock
:align: center

General Configuration of MCU Clock
```

UART clock should be derived from MCU clock reference point.

The MCU clock reference point is shown below -

```{figure} Assets/images/Configuration_of_Uartmcu_clock_reference_pt.png
:alt: Configuration of McuClockReferencePoint
:align: center
Configuration of McuClockReferencePoint
```

##### Port Configuration for CDD_UART Integration

The UART module has a dependency on the Port module to configure the pins used for UART communication. Each UART channel is mapped to specific physical pins on the microcontroller, which must be configured as the appropriate alternate functions (TX/RX) using the Port module.

In the port pin configuration, select PortPinPeripheral, PortPinPeripheralSignal, and PortPinDirection as shown below -

```{figure} Assets/images/Port_Pin_Configuration.png
:alt: Configuration of Port Pin 
:align: center
Configuration of Port Pin 
```

Similarly, port pin for UART RX can be configured.

##### IoHwAb Configuration for CDD_UART Integration

 IoHwAb is a layer in the AUTOSAR architecture that abstracts hardware-level interfaces and provides a standardized API to the upper layers.

To configure a Client/Server Port Interface, the container IoHwAbCS_Uart_read holds the configuration elements for a Client/Server template interface. This interface is instantiated by a Client/Server Port Prototype.

The container IoHwAbOperationArguments contains the configuration of Operation Elements, such as ChannelID, Length, Timeout, UartDestBufferptr for a Client/Server Operation. These Operation Elements will be generated as function parameters in the I/O Hardware Abstraction (IoHwAb) implementation.

Similarly, it is possible to enable communication between the I/O Client/Server interface and the MCAL APIs.

Configuration of UART IoHwAbCS port interface as shown below -

```{figure} Assets/images/Configuration_of_CDDUART_CS_Portinterface.png
:alt: Configuration of cdduart CSPortinterface
:align: center
Configuration of cdduart CSPortinterface
```

The container IoHwAbCSUar_read is used for configuring a Client/Server Port Prototype. This container represents an instantiation of a Client/Server Port Interface.

Configuration of cdduart IoHwAbCS port prototype as shown below -

```{figure} Assets/images/Configuration_of_CDDUART_PortPrototype.png
:alt: Configuration of cdduart PortPrototype
:align: center
Configuration of cdduart PortPrototypes
```

The function IoHwAb_IoHwAbCSUart_read_IoHwAbOperation is generated, and then the MCAL API function Cdd_Uart_Read is called.

In the RTE (Runtime Environment), the corresponding port is created based on the configuration, and it can be used as a Sender-Receiver Port for communication between software components -

```{figure} Assets/images/Invocking_MCAL_API_for_Cdd_Uart_Read.png
:alt: Invocking MCAL API for Cdd Uart Read
:align: center
 Invocking MCAL API for Cdd Uart Read
```
