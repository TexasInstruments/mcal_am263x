<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>7. AUTOSAR Integration Guide &mdash; Documentation for AM263x</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js?v=5d32c60e"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../_static/documentation_options.js?v=4a3566fb"></script>
        <script src="../_static/doctools.js?v=9a2dae69"></script>
        <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/js/theme.js"></script>

    <script src="https://www.ti.com/assets/js/headerfooter/analytics.js" type="text/javascript" charset="utf-8"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="prev" title="6. Key Performance and Memory Consumption Data" href="Key_Performance_and_Memory_Consumption_Data.html" /> 
</head>

<body class="wy-body-for-nav"><!---- extra body elements for TI beyond RTD Sphinx Theme --->
<div class="DocSite-globalNav tiNav">
    <ul>
    </ul>
</div>

<a class="DocSite-nav" href="https://www.ti.com" style="padding-bottom: 85px;">
  <img class="DocSiteNav-logo"
    src="../_static/img/ti_logo.png"
    alt="TI Logo">
  <div class="DocSiteNav-title"></div>
</a>
  

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> AM263x MCAL User Guide
          </a>
              <div class="version">
                11.01.00
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Table of Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Overview_of_MCAL.html">1. Overview of MCAL</a></li>
<li class="toctree-l1"><a class="reference internal" href="MCAL_Configuration_and_EB_Tresos.html">2. MCAL Configurator And EB Tresos User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="Getting_started.html">3. Getting Started With AM263x MCAL</a></li>
<li class="toctree-l1"><a class="reference internal" href="ModuleUserGuide_list.html">4. Module User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="api_guide.html">5. API guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="Key_Performance_and_Memory_Consumption_Data.html">6. Key Performance and Memory Consumption Data</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">7. AUTOSAR Integration Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#introduction">7.1. Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#how-to-use-ti-mcal-with-vector-stack">7.2. How to use TI MCAL with Vector Stack</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#board-bring-up-with-vector-s-startup-code">7.2.1. Board Bring-up with Vector’s startup code</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#objective-for-board-bring-up">7.2.1.1. Objective for Board Bring-up</a></li>
<li class="toctree-l4"><a class="reference internal" href="#list-of-modules">7.2.1.2. List of Modules</a></li>
<li class="toctree-l4"><a class="reference internal" href="#configuration-of-modules-in-board-bring-up">7.2.1.3. Configuration of modules in Board Bring-up</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#importing-ti-mcal-modules-from-eb-tresos-to-vector-davinci-configurator">7.2.2. Importing TI MCAL modules from EB Tresos to Vector DaVinci Configurator</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#objective">7.2.2.1. Objective</a></li>
<li class="toctree-l4"><a class="reference internal" href="#files-required-for-import">7.2.2.2. Files required for import</a></li>
<li class="toctree-l4"><a class="reference internal" href="#steps-to-import">7.2.2.3. Steps to import</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#can-integration">7.2.3. CAN Integration</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#objective-for-can-integration">7.2.3.1. Objective for CAN Integration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#list-of-modules-for-can">7.2.3.2. List Of Modules for CAN</a></li>
<li class="toctree-l4"><a class="reference internal" href="#configuration-of-modules-in-can-integration">7.2.3.3. Configuration of modules in CAN Integration</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#adc-integration">7.2.4. ADC Integration</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#objective-for-adc-integration">7.2.4.1. Objective for ADC Integration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#list-of-modules-for-adc">7.2.4.2. List Of Modules for ADC</a></li>
<li class="toctree-l4"><a class="reference internal" href="#configuration-of-modules-in-adc-integration">7.2.4.3. Configuration of modules in ADC Integration</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#spi-integration">7.2.5. SPI Integration</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#objective-for-spi-integration">7.2.5.1. Objective for SPI Integration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#list-of-modules-for-spi">7.2.5.2. List of Modules for SPI</a></li>
<li class="toctree-l4"><a class="reference internal" href="#configuration-of-modules-in-spi-integration">7.2.5.3. Configuration of modules in Spi Integration</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#pwm-integration">7.2.6. PWM Integration</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#objective-for-pwm-integration">7.2.6.1. Objective for PWM Integration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#list-of-modules-for-pwm">7.2.6.2. List of Modules for PWM</a></li>
<li class="toctree-l4"><a class="reference internal" href="#configuration-of-modules-in-pwm-integration">7.2.6.3. Configuration of modules in PWM Integration</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#lin-integration">7.2.7. LIN Integration</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#objective-for-lin-integration">7.2.7.1. Objective for LIN Integration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#list-of-modules-for-lin">7.2.7.2. List of Modules for LIN</a></li>
<li class="toctree-l4"><a class="reference internal" href="#configuration-of-modules-in-lin-integration">7.2.7.3. Configuration of modules in LIN Integration</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#cdd-ipc-integration">7.2.8. CDD_IPC Integration</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#objective-for-cdd-ipc-integration">7.2.8.1. Objective for CDD_IPC Integration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#list-of-modules-for-cdd-ipc-integration">7.2.8.2. List of Modules for CDD_IPC Integration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#configuration-of-modules-in-cdd-ipc-integration">7.2.8.3. Configuration of modules in CDD_IPC Integration</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#wdg-integration">7.2.9. WDG Integration</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#objective-for-wdg-integration">7.2.9.1. Objective for WDG Integration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#list-of-modules-for-wdg-integration">7.2.9.2. List of Modules for WDG Integration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#configuration-modules-in-wdg-integration">7.2.9.3. Configuration modules in WDG Integration</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#dio-integration">7.2.10. DIO Integration</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#objective-for-dio-integration">7.2.10.1. Objective for DIO Integration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#list-of-modules-for-dio-integration">7.2.10.2. List of Modules for DIO Integration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#configuration-of-modules-in-dio-integration">7.2.10.3. Configuration of modules in DIO integration</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#cdd-i2c-integration">7.2.11. CDD_I2C Integration</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#objective-for-cdd-i2c-integration">7.2.11.1. Objective for CDD_I2C Integration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#list-of-modules-for-cdd-i2c-integration">7.2.11.2. List of Modules for CDD_I2C Integration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#configuration-modules-in-cdd-i2c-integration">7.2.11.3. Configuration modules in CDD_I2C Integration</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#icu-integration">7.2.12. ICU Integration</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#objective-for-icu-integration">7.2.12.1. Objective for ICU Integration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#list-of-modules-for-icu">7.2.12.2. List Of Modules for ICU</a></li>
<li class="toctree-l4"><a class="reference internal" href="#configuration-of-modules-in-icu-integration">7.2.12.3. Configuration of modules in ICU Integration</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#gpt-integration">7.2.13. GPT Integration</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#objective-for-gpt-integration">7.2.13.1. Objective for GPT Integration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#list-of-modules-for-gpt-integration">7.2.13.2. List of Modules for GPT Integration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#configuration-of-modules-in-gpt-integration">7.2.13.3. Configuration of modules in GPT Integration</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#cdd-fsi-integration">7.2.14. CDD FSI Integration</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#objective-for-cdd-fsi-integration">7.2.14.1. Objective for CDD FSI Integration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#list-of-modules-for-cdd-fsi-integration">7.2.14.2. List of Modules for CDD FSI Integration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#configuration-of-modules-in-cdd-fsi-integration">7.2.14.3. Configuration of modules in CDD FSI Integration</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#cdd-uart-integration">7.2.15. CDD_UART Integration</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#objective-for-cdd-uart-integration">7.2.15.1. Objective for CDD_UART Integration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#list-of-modules-for-cdd-uart-integration">7.2.15.2. List of Modules for CDD_UART Integration</a></li>
<li class="toctree-l4"><a class="reference internal" href="#configuration-of-modules-in-cdd-uart-integration">7.2.15.3. Configuration of modules in CDD_UART Integration</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">AM263x MCAL User Guide</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
      <li><span class="section-number">7. </span>AUTOSAR Integration Guide</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="autosar-integration-guide">
<h1><span class="section-number">7. </span>AUTOSAR Integration Guide<a class="headerlink" href="#autosar-integration-guide" title="Link to this heading"></a></h1>
<section id="introduction">
<h2><span class="section-number">7.1. </span>Introduction<a class="headerlink" href="#introduction" title="Link to this heading"></a></h2>
<p>MCAL and CDD drivers offered by TI are compatible with AUTOSAR basic software provided by different AUTOSAR vendors.
These drivers are specific to MCU hardware and work as abstraction layer which makes rest of BSW independent of MCAL.
The intention of this document is to provide information on integrating TI MCALs/CDDs to AUTOSAR BSW provided by different vendors to ensure smooth interfacing.</p>
</section>
<section id="how-to-use-ti-mcal-with-vector-stack">
<h2><span class="section-number">7.2. </span>How to use TI MCAL with Vector Stack<a class="headerlink" href="#how-to-use-ti-mcal-with-vector-stack" title="Link to this heading"></a></h2>
<p>This chapter explains how TI MCAL can be integrated into Vector stack with respect to different use cases.</p>
<section id="board-bring-up-with-vector-s-startup-code">
<h3><span class="section-number">7.2.1. </span>Board Bring-up with Vector’s startup code<a class="headerlink" href="#board-bring-up-with-vector-s-startup-code" title="Link to this heading"></a></h3>
<section id="objective-for-board-bring-up">
<h4><span class="section-number">7.2.1.1. </span>Objective for Board Bring-up<a class="headerlink" href="#objective-for-board-bring-up" title="Link to this heading"></a></h4>
<p>The intention of this use case is to bring the program flow at the start of application, perform the startup activities such as but not limited to initialization of Interrupt Vector Table, Exception Vector Table, initialization of data, initialization of default clocks etc. This is achieved by integrating Vector startup code and Vector stack. Vector startup code has some dependencies on TI SDK which are explained in detail in subsequent chapter.
Further, the required BSW modules are initialized and periodic scheduling is started via OS and RTE.</p>
</section>
<section id="list-of-modules">
<h4><span class="section-number">7.2.1.2. </span>List of Modules<a class="headerlink" href="#list-of-modules" title="Link to this heading"></a></h4>
<section id="vector-modules">
<h5><span class="section-number">7.2.1.2.1. </span>Vector Modules<a class="headerlink" href="#vector-modules" title="Link to this heading"></a></h5>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Sl. No.</p></th>
<th class="head"><p>Vector Modules</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>Significance in use case</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>EcuC (Autosar EcuC module), <br> vSet (Vector Common Settings module)</p></td>
<td><p>EcuC and vSet are virtual modules that collect the global and ECU specific configuration information.</p></td>
<td><p>In this use case, this module is necessary to provide the partition and core information <br> along with default global configurations for ECU.</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>vBaseEnv (Vector Base Environment), <br> vBRS (Vector Basic Runtime System)</p></td>
<td><p>These modules together constitute Vector startup code that provide basic hardware setup options <br> such as memory init, PLL init, Port init and Watchdog init etc. in order to set up the environment <br> for cyclic runtime behavior. These modules can be configured to select which of its features shall <br> be enabled and executed during startup to setup the environment based on use case.</p></td>
<td><p>In this use case, these modules are used to initialize memory, interrupt vector tables, exception vector tables. <br> It initializes OS and EcuM and hands over control to EcuM for further processing</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>vLinkGen (Vector Linkers-script Generator)</p></td>
<td><p>The MICROSAR linker script generator provides a way to create a linker file in order to place the <br> code, constants and data in intended memory location.</p></td>
<td><p>In this use case, this module is used to setup the application entry point, IVT etc.</p></td>
</tr>
<tr class="row-odd"><td><p>4</p></td>
<td><p>OS (MICROSAR Operating System)</p></td>
<td><p>The Operating System is mainly responsible for handling of tasks and interrupts.</p></td>
<td><p>In this use case, it used to define a periodic task.</p></td>
</tr>
<tr class="row-even"><td><p>5</p></td>
<td><p>Rte (MICROSAR Runtime Environment)</p></td>
<td><p>The Runtime Environment module manages the information flow between <br> Software Components (SWCs), BSW and CDDs.</p></td>
<td><p>In this use case, it is used to schedule the periodic task defined in OS.</p></td>
</tr>
<tr class="row-odd"><td><p>6</p></td>
<td><p>EcuM (MICROSAR Ecu State Manager)</p></td>
<td><p>The Ecu State Manager starts/stops OS, SchM, BswM and other BSW modules. <br> It is responsible for startup, shutdown, sleep modes and wakeup sources of the ECU.</p></td>
<td><p>In this use case, it used to start/stop OS and scheduler.</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For detailed information on each module and its features, please refer to the Technical Reference Manual provided by Vector for each of these modules</p>
</div>
</section>
<section id="ti-sdk">
<h5><span class="section-number">7.2.1.2.2. </span>TI SDK<a class="headerlink" href="#ti-sdk" title="Link to this heading"></a></h5>
<p>Vector startup code requires some low level functions that can interact directly with hardware e.g. to setup the interrupt vector table and interrupt controller, to set the clock etc. These kind of low level functions can be take from TI Software Development Kit (SDK).</p>
<p>SDK : <a class="reference external" href="https://www.ti.com/tool/MCU-PLUS-SDK-AM263X">MCU-PLUS-SDK-AM263</a></p>
<p>From downloaded SDK package copy following to your workspace -</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Sl. No.</p></th>
<th class="head"><p>TI Modules</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1.</p></td>
<td><p>kernel</p></td>
<td><p>Include all the headers files from path {sdk_installation_dir}/source/kernel</p></td>
</tr>
<tr class="row-odd"><td><p>2.</p></td>
<td><p>drivers</p></td>
<td><p>Include all the headers files from path {sdk_installation_dir}/source/drivers</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="configuration-of-modules-in-board-bring-up">
<h4><span class="section-number">7.2.1.3. </span>Configuration of modules in Board Bring-up<a class="headerlink" href="#configuration-of-modules-in-board-bring-up" title="Link to this heading"></a></h4>
<p>This chapter explains the minimum configurations that must be applied on top of the default configuration for each module, to realize this use case:</p>
<section id="ecuc">
<h5><span class="section-number">7.2.1.3.1. </span>EcuC<a class="headerlink" href="#ecuc" title="Link to this heading"></a></h5>
<p>This module contains the information of different partitions on each core. For this use case, we only require one partition on one core to run the OS. This partition is configured as below -</p>
<figure class="align-center" id="id1">
<img alt="Microcontroller mentioned in the vBaseEnvDerivativeInformation" src="../_images/fig19MicroMentionInEcuc.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.1 </span><span class="caption-text">EcuC Module Configuration</span><a class="headerlink" href="#id1" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>Configure the ASIL level as per the requirement. For this use case, ASIL Level is configured as QM.</p>
</section>
<section id="vbaseenv-and-vbrs">
<h5><span class="section-number">7.2.1.3.2. </span>vBaseEnv and vBRS<a class="headerlink" href="#vbaseenv-and-vbrs" title="Link to this heading"></a></h5>
<p>In vBaseEnv module the derivative of MCU being used is selected as shown below. Once this derivative is selected all MCU specific information is automatically set -</p>
<figure class="align-center" id="id2">
<img alt="Microcontroller mentioned in the vBaseEnvDerivativeInformation" src="../_images/fig19MicroMentionInVbaseEnv1.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.2 </span><span class="caption-text">Microcontroller mentioned in the vBaseEnvDerivativeInformation</span><a class="headerlink" href="#id2" title="Link to this image"></a></p>
</figcaption>
</figure>
<figure class="align-center" id="id3">
<img alt="Microcontroller mentioned in the vBaseEnvDerivativeInformation" src="../_images/fig19MicroMentionInVbaseEnv.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.3 </span><span class="caption-text">Microcontroller mentioned in the vBaseEnvDerivativeInformation</span><a class="headerlink" href="#id3" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>vBRS module is configured to enable features offered by startup code that are needed for this use case.
The default configuration settings offered by vBRS are enough to achieve this use case.
In this use case, we configure the vBRS to set the application entry point, clock frequencies, define the user code for make support, define the initialization pattern for data etc.
Please ensure that configurations shown in below screenshots are intact:</p>
<p>As this use case is an application category, execution instance is selected as Application -</p>
<figure class="align-center" id="id4">
<img alt="vBRSGeneral Configuration" src="../_images/fig20vBrsGen.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.4 </span><span class="caption-text">vBRSGeneral Configuration</span><a class="headerlink" href="#id4" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="vlinkgen">
<h5><span class="section-number">7.2.1.3.3. </span>vLinkGen<a class="headerlink" href="#vlinkgen" title="Link to this heading"></a></h5>
<p>vLinkGen configurations are done to generate a linker script that will store data/code/constants in desired memory location.
By default vLinkGen will populate some variable/constant groups and memory regions based on other configured modules.
The mandatory parameters in the default configurations shall be updated with the help of TechnicalReference_vLinkGen.
To define the entry point to vector startup code, you add the entry point in generated linker file as shown below:</p>
<p>–entry_point=intvect_CoreExceptions             /<em>ENTRY POINT</em>/</p>
<p>The entry point can be defined in multiple ways:
The option –entry_point can be set to either intvect_CoreException OR _start in linker file. When entry point is set to intvect_CoreExceptions, the program counter points to the start of interrupt vector table after reset vector. Entry point is set to _start only when using debugger to preset the start address. In this use case we use the entry_point as intvect_CoreExceptions.</p>
<p>If the entry point is not set in linker file, then the default entry point (_cinit) is used, which uses a compiler based startup code instead of vector startup code -</p>
<figure class="align-center" id="id5">
<img alt="CINIT memory section configuration" src="../_images/fig25CINT.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.5 </span><span class="caption-text">CINIT memory section configuration</span><a class="headerlink" href="#id5" title="Link to this image"></a></p>
</figcaption>
</figure>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>entry_point generation is not supported in the current Vector package. Hence, the –entry_point needs to be set to intvect_CoreExceptions in the linker file manually.</p>
</div>
<p>For details about vLinkGen configuration please refer Vector document TechnicalReference_vLinkGen.</p>
</section>
<section id="os">
<h5><span class="section-number">7.2.1.3.4. </span>OS<a class="headerlink" href="#os" title="Link to this heading"></a></h5>
<p>To achieve an OS task with 10 ms as the period. The following are the main parameters to be configured in OS module. Task Period should be 0.01s in OS tasks container. Which is shown in the below figure -</p>
<figure class="align-center" id="id6">
<img alt="Os_Task_10ms configuration" src="../_images/fig27OsCounter.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.6 </span><span class="caption-text">Counter configuration</span><a class="headerlink" href="#id6" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>Default auto-start tasks are created as shown below. These tasks participate in startup process. The default definition of task is present in startup code. For this use case, it is used as-is, however it can be modified as need be -</p>
<figure class="align-center" id="id7">
<img alt="Auto-start task configuration" src="../_images/fig27OsAutoStart.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.7 </span><span class="caption-text">Auto start task configuration1</span><a class="headerlink" href="#id7" title="Link to this image"></a></p>
</figcaption>
</figure>
<figure class="align-center" id="id8">
<img alt="Auto-start task configuration" src="../_images/fig27OsAutoStart1.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.8 </span><span class="caption-text">Auto start task configuration2</span><a class="headerlink" href="#id8" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>Then we can configure a periodic task (10 ms) as shown below. This task is used to schedule the periodic runnable. In this use case, there is only one BSW module with a schedulable periodic runnable, which is EcuM -</p>
<figure class="align-center" id="id9">
<img alt="Auto-start task configuration" src="../_images/fig27OsTask10ms.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.9 </span><span class="caption-text">10 ms task configuration</span><a class="headerlink" href="#id9" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="rte">
<h5><span class="section-number">7.2.1.3.5. </span>Rte<a class="headerlink" href="#rte" title="Link to this heading"></a></h5>
<p>ECUM main function is mapped to 10ms task and position is given as shown. Importance of position parameter come into picture if more than more function is mapped in the TASK. Position parameter determines which mapped function will execute first within the particular task -</p>
<figure class="align-center" id="id10">
<img alt="Mapping of EcuM main function" src="../_images/fig28MappingECUm.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.10 </span><span class="caption-text">Mapping of EcuM main function</span><a class="headerlink" href="#id10" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>Thus, the Rte generates the mapping of the runnable to the task.</p>
</section>
<section id="ecum">
<h5><span class="section-number">7.2.1.3.6. </span>EcuM<a class="headerlink" href="#ecum" title="Link to this heading"></a></h5>
<p>In this use case, EcuM is used to start the OS and scheduler via EcuM_Init and EcuM_StartupTwo function calls in startup code. It also manages all the wakeup events associated with ECU. The mandatory configurations related to wakeup/sleep can be updated as shown below, however wakeup scenario is not part of this use case -</p>
<figure class="align-center" id="id11">
<img alt="MCU mode setting of EcuM" src="../_images/fig29MCUmode.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.11 </span><span class="caption-text">MCU mode setting of EcuM</span><a class="headerlink" href="#id11" title="Link to this image"></a></p>
</figcaption>
</figure>
<figure class="align-center" id="id12">
<img alt="OsResource added in the OS module is mapped in EcuM." src="../_images/fig30OsResourceAddedin.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.12 </span><span class="caption-text">OsResource added in the OS module is mapped in EcuM.</span><a class="headerlink" href="#id12" title="Link to this image"></a></p>
</figcaption>
</figure>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Reference to Mcu Mode Setting Configuration is provided as placeholder because it is a mandatory parameter. This configuration is not used in this use case. Any MCU module definition can be used as reference. (e.g. Autosar standard definition of MCU already available in Vector Modules list).</p>
</div>
</section>
</section>
</section>
<section id="importing-ti-mcal-modules-from-eb-tresos-to-vector-davinci-configurator">
<h3><span class="section-number">7.2.2. </span>Importing TI MCAL modules from EB Tresos to Vector DaVinci Configurator<a class="headerlink" href="#importing-ti-mcal-modules-from-eb-tresos-to-vector-davinci-configurator" title="Link to this heading"></a></h3>
<section id="objective">
<h4><span class="section-number">7.2.2.1. </span>Objective<a class="headerlink" href="#objective" title="Link to this heading"></a></h4>
<p>The TI MCAL modules are configured using EB Tresos tool. When Vector DaVinci Configurator is used for BSW stack configuration, we may require to import the MCAL modules to DaVinci Configurator so that Vector modules can have reference to MCAL modules e.g. The clock references from MCU module may be required by other module to derive their own clock. This chapter explains how TI MCAL modules can be imported to Vector DaVinci Configurator.</p>
</section>
<section id="files-required-for-import">
<h4><span class="section-number">7.2.2.2. </span>Files required for import<a class="headerlink" href="#files-required-for-import" title="Link to this heading"></a></h4>
<p>1.Export of MCAL from EB Tresos (ARXML): The MCAL modules can be exported from EB Tresos into an ARXML file as instructed in <a class="reference internal" href="MCAL_Configuration_and_EB_Tresos.html#run-export"><span class="std std-ref">Run Export</span></a>. This ARXML contains ECU configuration of MCAL modules.
2.Vendor Specific Module Definition (ARXML): TI defines Vendor Specific Module Definition for each MCAL module based on AUTOSAR Standard Module definition. This file is needed by Vector DaVinci Configurator to understand the parameters in MCAL modules. This ARXML file can be found as given in <a class="reference internal" href="MCAL_Configuration_and_EB_Tresos.html#module-plugin-directory-structure"><span class="std std-ref">Module Plugin Directory Structure</span></a>.
3.BSW Module Description File (ARXML): The BSWMD is a formal notation of all information belonging to a certain BSW module in addition to the implementation of the artifact. Each MCAL module generates it’s BSWMD file. Please refer <a class="reference internal" href="MCAL_Configuration_and_EB_Tresos.html#generate-bswmd"><span class="std std-ref">Generate BSWMD</span></a> for details.</p>
</section>
<section id="steps-to-import">
<h4><span class="section-number">7.2.2.3. </span>Steps to import<a class="headerlink" href="#steps-to-import" title="Link to this heading"></a></h4>
<p>1.Provide the path of Vendor Specific Module Definition (ARXML) and BSW Module Description File (ARXML) in Additional Definitions settings in DaVinci project settings as shown below -</p>
<figure class="align-center" id="id13">
<img alt="Additional Definition Settings" src="../_images/Davinci_Project_Setting.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.13 </span><span class="caption-text">Additional Definition Settings</span><a class="headerlink" href="#id13" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>2.Import the MCAL Module Export from EB Tresos, e.g. -</p>
<figure class="align-center" id="id14">
<img alt="Importing MCAL module from EB Tresos" src="../_images/Importing_the_MCAL_Module.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.14 </span><span class="caption-text">Importing MCAL module from EB Tresos</span><a class="headerlink" href="#id14" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>3.Provide the path of ARXML export of MCAL modules from EB Tresos, e.g. -</p>
<figure class="align-center" id="id15">
<img alt="Import File Selection" src="../_images/Path_ARXML_MCAL_module.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.15 </span><span class="caption-text">Import File Selection</span><a class="headerlink" href="#id15" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>4.Select the MCAL modules to be imported. If there are any stubs/unwanted modules in export, they can be deselected -</p>
<figure class="align-center" id="id16">
<img alt="Import MCAL module Selection" src="../_images/Module_Selection.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.16 </span><span class="caption-text">Import MCAL module Selection</span><a class="headerlink" href="#id16" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>5.The imported modules can be seen in DaVinci Configurator as shown below -</p>
<figure class="align-center" id="id17">
<img alt="DaVinci Basic Editor View" src="../_images/Imported_Modules.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.17 </span><span class="caption-text">DaVinci Basic Editor View</span><a class="headerlink" href="#id17" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>6.As shown in below image, the TI MCAL driver and it’s vendor specific module definition file are mapped to the respective driver -</p>
<figure class="align-center" id="id18">
<img alt="DaVinci Basic Editor View" src="../_images/Import_final.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.18 </span><span class="caption-text">DaVinci Basic Editor View</span><a class="headerlink" href="#id18" title="Link to this image"></a></p>
</figcaption>
</figure>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This import of MCAL modules to DaVinci configurator is only for reference to other modules. The MCAL modules can’t be updated/generated from DaVinci configurator.</p>
</div>
</section>
</section>
<section id="can-integration">
<h3><span class="section-number">7.2.3. </span>CAN Integration<a class="headerlink" href="#can-integration" title="Link to this heading"></a></h3>
<section id="objective-for-can-integration">
<h4><span class="section-number">7.2.3.1. </span>Objective for CAN Integration<a class="headerlink" href="#objective-for-can-integration" title="Link to this heading"></a></h4>
<p>The intention of CAN Integration is to have successful CAN communication by configuring TI MCAL modules along with Vector BSW Modules. Further details are explained in the subsequent chapter.</p>
</section>
<section id="list-of-modules-for-can">
<h4><span class="section-number">7.2.3.2. </span>List Of Modules for CAN<a class="headerlink" href="#list-of-modules-for-can" title="Link to this heading"></a></h4>
<section id="mcal-modules-for-can-integration">
<h5><span class="section-number">7.2.3.2.1. </span>MCAL Modules for CAN Integration<a class="headerlink" href="#mcal-modules-for-can-integration" title="Link to this heading"></a></h5>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Sl. No.</p></th>
<th class="head"><p>MCAL Modules</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>Significance in use case</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>CAN Driver</p></td>
<td><p>The CAN module initializes and controls the internal CAN Controllers of the microcontroller. It provides services to write, read, and configure mailboxes of the CAN controllers.</p></td>
<td><p>In this use case , this module is responsible for configuring the CAN hardware unit, hardware mailboxes, scheduled functions etc.</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>Mcu</p></td>
<td><p>The MCU module manages microcontroller features such as power modes, clock settings, and interrupts.</p></td>
<td><p>In this use case, this module is responsible for providing the clock for CAN communication.</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>Port</p></td>
<td><p>The PORT module provides an interface to configure and control microcontroller pins (e.g., GPIO, ADC, PWM).</p></td>
<td><p>In this use case, this module is responsible for configuring the hardware pins necessary for CAN communication.</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For detailed information, please refer to the section <a class="reference internal" href="Module_User_Guide_Can.html#can-module"><span class="std std-ref">CAN Module</span></a>.</p>
</div>
</section>
<section id="vector-modules-for-can-integration">
<h5><span class="section-number">7.2.3.2.2. </span>Vector Modules for CAN Integration<a class="headerlink" href="#vector-modules-for-can-integration" title="Link to this heading"></a></h5>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Sl. No.</p></th>
<th class="head"><p>Vector Modules</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>Significance in use case</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>EcuC (Autosar EcuC module)</p></td>
<td><p>EcuC is a virtual module that collect the global and ECU specific configuration information.</p></td>
<td><p>In this use case, this module is necessary to provide the partition and core information <br> along with default global configurations for ECU.</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>CanIf</p></td>
<td><p>The CanIf module provides an interface between the CAN driver and upper layers. It handles message transmission and reception, manages hardware object, and offers error handling.</p></td>
<td><p>In this use case, CanIf module mainly acts as interface between CAN driver and upper layers of communication stack, configures transmit/receive hardware objects etc.</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>PduR</p></td>
<td><p>PduR routes protocol data units between communication modules and ensures that the correct Pdus are transmitted to the appropriate destination.</p></td>
<td><p>In this use case, PduR module handles the routing of Pdus to and from Com layer and CAN driver.</p></td>
</tr>
<tr class="row-odd"><td><p>4</p></td>
<td><p>Com</p></td>
<td><p>Com is responsible to provide a signal-based interface to the upper layer. It handles signal conversion, transmission and reception.</p></td>
<td><p>In this use case, Com module handles packing of AUTOSAR signals to I-Pdus to be transmitted and unpacking of received I-Pdus.</p></td>
</tr>
<tr class="row-even"><td><p>5</p></td>
<td><p>CanSM</p></td>
<td><p>The CAN State Manager (CanSM) realizes a software layer between the Communication Manager (ComM) and the CAN Interface (CanIf). The CanSM handles the startup and shutdown of the communication of a CAN network. The CAN State Manager maps the CAN State Manager states to the states of the ComM and causes the necessary actions to change the CAN State Manager state to those requested by the ComM.</p></td>
<td><p>In this use case, CanSM module manages the state transitions of the CAN controller, mainly from NO COMMUNICATION to FULL COMMUNICATION.</p></td>
</tr>
<tr class="row-odd"><td><p>6</p></td>
<td><p>ComM</p></td>
<td><p>The Communication Manager is a resource manager, which encapsulates the control of the underlying communication services. It controls more than one communication bus channel of an ECU by implementing a channel state machine for every channel.</p></td>
<td><p>In this use case, ComM provides a mechanism for users to request communication modes, coordinating requests from multiple independent users.</p></td>
</tr>
<tr class="row-even"><td><p>7</p></td>
<td><p>OS (MICROSAR Operating System)</p></td>
<td><p>The Operating System is mainly responsible for handling tasks and interrupts.</p></td>
<td><p>In this use case, OS module is used to define periodic tasks needed for CAN communication such as processing transmit and receive message.</p></td>
</tr>
<tr class="row-odd"><td><p>8</p></td>
<td><p>RTE (MICROSAR Runtime Environment)</p></td>
<td><p>The Runtime Environment module manages the information flow between Software Components (SWCs), BSW and CDDs.</p></td>
<td><p>In this use case, Rte module is used to schedule the periodic tasks defined in the operating system (OS) and sender receiver ports created for sending receiving CAN messages from application.</p></td>
</tr>
<tr class="row-even"><td><p>9</p></td>
<td><p>DET</p></td>
<td><p>The DET is used in order to report development errors. The DET can be replaced optionally by an equivalent component which is responsible for recognizing development errors, if no DET component is available.</p></td>
<td><p>In this use Case, Development error is enabled to detect all development errors.</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For detailed information on each module and its features, please refer to the Technical Reference Manual provided by Vector.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For importing MCAL configuration files to DaVinci refer <a class="reference internal" href="#importing-ti-mcal-modules-from-eb-tresos-to-vector-davinci-configurator"><span class="std std-ref">Importing TI MCAL modules from EB Tresos to Vector DaVinci Configurator</span></a>.</p>
</div>
</section>
</section>
<section id="configuration-of-modules-in-can-integration">
<h4><span class="section-number">7.2.3.3. </span>Configuration of modules in CAN Integration<a class="headerlink" href="#configuration-of-modules-in-can-integration" title="Link to this heading"></a></h4>
<p>This chapter explains the basic configurations that are needed to realize CAN communication.</p>
<section id="can-configuration">
<h5><span class="section-number">7.2.3.3.1. </span>CAN Configuration<a class="headerlink" href="#can-configuration" title="Link to this heading"></a></h5>
<p>TI CAN driver is configured using EB Tresos tool. It is then imported to Vector DaVinci configurator for integration with CAN stack. Following containers and parameters shall be configured.</p>
<p><strong>CanController:</strong></p>
<p>The CanController container defines the configuration parameters for individual CAN controllers within hardware. It manages essential settings like baud rate, timing segments, and hardware addressing, ensuring proper communication between the CAN bus and the application layer. The following figure shows the configuration of MCAN4 with CAN Bus off and CAN Reception/Transmission in polling mode -</p>
<figure class="align-center" id="id19">
<img alt="CAN Controller configuration." src="../_images/Can_controller.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.19 </span><span class="caption-text">CAN Controller configuration.</span><a class="headerlink" href="#id19" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>Configuration of CAN controller with 1000kbps of baudrate is shown below -</p>
<figure class="align-center" id="id20">
<img alt="Configuration of CANcontrollerBaudrate" src="../_images/Can_controllerBaudrate.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.20 </span><span class="caption-text">Configuration of CANcontrollerBaudrate</span><a class="headerlink" href="#id20" title="Link to this image"></a></p>
</figcaption>
</figure>
<p><strong>CANHwObject:</strong></p>
<p>The CANHwObject container configures hardware objects (HOHs) used for transmitting and receiving CAN messages. It defines the type, direction, and identifier settings for each hardware object, ensuring proper handling of CAN message.</p>
<p>The configuration of a transmitting CAN signal with basic standard Id is shown below -</p>
<figure class="align-center" id="id21">
<img alt="CAN message configuration" src="../_images/Can_HwObjectType.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.21 </span><span class="caption-text">CAN message configuration</span><a class="headerlink" href="#id21" title="Link to this image"></a></p>
</figcaption>
</figure>
<p><strong>CANHwFilter:</strong></p>
<p>The CANHwFilter container defines the hardware based message filtering mechanism for received CAN message. It ensures that only relevant messages matching a specified identifier pattern are accepted, reducing the load on the CPU.</p>
<p>The configuration of CAN signal Id filter which will be able to accept a CAN message of ID 0x9A(154) and mask code is shown below -</p>
<figure class="align-center" id="id22">
<img alt="Configuration for CAN_HwFilter" src="../_images/Can_HwFilter.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.22 </span><span class="caption-text">Configuration for CAN_HwFilter</span><a class="headerlink" href="#id22" title="Link to this image"></a></p>
</figcaption>
</figure>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>CAN driver doesn’t support Sleep / Wakeup modes and ICOM functionality, hence the related parameters like partial networking shall not be configured in BSW modules.</p>
</div>
</section>
<section id="mcu-configuration">
<h5><span class="section-number">7.2.3.3.2. </span>MCU Configuration<a class="headerlink" href="#mcu-configuration" title="Link to this heading"></a></h5>
<p>The CAN module has dependencies on MCU module to provide the CAN clock setting reference.
The MCU clock configuration for CAN controller is shown below -</p>
<figure class="align-center" id="id23">
<img alt="Configuration of McuClockSettingconfig" src="../_images/Mcu_ClockSettingConfig.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.23 </span><span class="caption-text">Configuration of McuClockSettingconfig</span><a class="headerlink" href="#id23" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>CAN clock should be derived from MCU clock reference point. The configuration for clock reference point is shown below -</p>
<figure class="align-center" id="id24">
<img alt="Configuration for Mcu_ClockReferencePoint" src="../_images/Mcu_ClockReferencePoint.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.24 </span><span class="caption-text">Configuration for Mcu_ClockReferencePoint</span><a class="headerlink" href="#id24" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="port-configuration-in-can-module">
<h5><span class="section-number">7.2.3.3.3. </span>Port Configuration in CAN Module<a class="headerlink" href="#port-configuration-in-can-module" title="Link to this heading"></a></h5>
<p>CAN module has dependency on Port module to configure transmit, receive, standby and enable pins of hardware. Configuration of receive pin is as shown below -</p>
<figure class="align-center" id="id25">
<img alt="Port Pin Configuration for CAN module" src="../_images/Port_Can.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.25 </span><span class="caption-text">Port Pin Configuration for CAN module</span><a class="headerlink" href="#id25" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="ecuc-configuration-in-can-module">
<h5><span class="section-number">7.2.3.3.4. </span>EcuC Configuration in CAN Module<a class="headerlink" href="#ecuc-configuration-in-can-module" title="Link to this heading"></a></h5>
<p>EcuC is a virtual module to collect ECU Configuration specific global configuration information. EcuCPduCollection container collects all the Pdus flowing through the COM Stack as shown below -</p>
<figure class="align-center" id="id26">
<img alt="EcuC Pdu Collection" src="../_images/CanEcuCPduCollection.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.26 </span><span class="caption-text">EcuC Pdu Collection</span><a class="headerlink" href="#id26" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="canif-configuration-in-can-module">
<h5><span class="section-number">7.2.3.3.5. </span>CanIf Configuration in CAN Module<a class="headerlink" href="#canif-configuration-in-can-module" title="Link to this heading"></a></h5>
<p>CanIf module abstracts the CAN driver from the rest of the CAN stack. CAN driver and dependent MCAL modules must be imported to Vector DaVinci configurator before configuring Vector modules.</p>
<p>CanIf configures transmit and receive Pdus.</p>
<p>For a transmit message:</p>
<p><strong>CanIfHthCfgs:</strong></p>
<p>Hardware Transmit Handle shall be configured which is shown in below figure. It contains the reference to CAN controller and HTH object in the CAN driver module configuration -</p>
<figure class="align-center" id="id27">
<img alt="Reference from TI's MCAL module imported in DaVinci" src="../_images/CANReferrence.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.27 </span><span class="caption-text">Reference from TI’s MCAL module imported in DaVinci</span><a class="headerlink" href="#id27" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>From the available reference, CAN Controller and HTH object shall be selected as shown below -</p>
<figure class="align-center" id="id28">
<img alt="Configuration for CanIfHthCfgs" src="../_images/CanIf_HthCfgs.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.28 </span><span class="caption-text">Configuration for CanIfHthCfgs</span><a class="headerlink" href="#id28" title="Link to this image"></a></p>
</figcaption>
</figure>
<p><strong>CanIfTxPduCfgs:</strong></p>
<p>CanIf Tx Pdu container contains the configuration (parameters) of a transmit CAN L-Pdu. CanIf Tx Pdu configuration is shown below -</p>
<figure class="align-center" id="id29">
<img alt="Configuration for CanIfTxPduCfgs" src="../_images/CanIf_TxPduCfgs.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.29 </span><span class="caption-text">Configuration for CanIfTxPduCfgs</span><a class="headerlink" href="#id29" title="Link to this image"></a></p>
</figcaption>
</figure>
<p><strong>CANIfBufferCfgs:</strong></p>
<p>CANIfBufferCfgs container contains the Tx-buffer configuration. Multiple buffers with different sizes could be configured. CANIfBufferCfgs configuration is shown below -</p>
<figure class="align-center" id="id30">
<img alt="Configuration for CanIfBufferCfgs" src="../_images/CanIf_BufferCfgs.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.30 </span><span class="caption-text">Configuration for CanIfBufferCfgs</span><a class="headerlink" href="#id30" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>For a Receive message:</p>
<p><strong>CanIfHrhCfgs:</strong></p>
<p>CanIfHrhCfgs container contains configuration parameters for each hardware receive object (HRH). CanIfHrhCfgs configuration is shown below. It contains the reference to CAN controller and HRH object in the CAN driver module configuration -</p>
<figure class="align-center" id="id31">
<img alt="Configuration for CanIfHrhCfgs" src="../_images/CanIf_HrhCfgs.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.31 </span><span class="caption-text">Configuration for CanIfHrhCfgs</span><a class="headerlink" href="#id31" title="Link to this image"></a></p>
</figcaption>
</figure>
<p><strong>CanIfRxpduCfgs:</strong></p>
<p>CanIfRxpduCfgs container contains the configuration (parameters) of each receive CAN L-Pdu. Filters and delivers incoming messages to the upper layers. CanIfRxpduCfgs configuration is shown below -</p>
<figure class="align-center" id="id32">
<img alt="Configuration for CanIfRxPduCfgs" src="../_images/CanIf_RxPduCfgs.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.32 </span><span class="caption-text">Configuration for CanIfRxPduCfgs</span><a class="headerlink" href="#id32" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="pdur-configuration-in-can-module">
<h5><span class="section-number">7.2.3.3.6. </span>PduR Configuration in CAN Module<a class="headerlink" href="#pdur-configuration-in-can-module" title="Link to this heading"></a></h5>
<p>The primary function of the Pdu Router module is to abstract the bus access type (Interface layer) and the bus type itself. The Pdu Router routing tables are configured with source and destination parameters. Pdu Router configuration to send and receive CAN message to and from CAN driver and Com module is shown below -</p>
<figure class="align-center" id="id33">
<img alt="PduR configuration" src="../_images/PduR_Configuration.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.33 </span><span class="caption-text">PduR configuration</span><a class="headerlink" href="#id33" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="com-configuration-in-can-module">
<h5><span class="section-number">7.2.3.3.7. </span>Com Configuration in CAN Module<a class="headerlink" href="#com-configuration-in-can-module" title="Link to this heading"></a></h5>
<p>The Com provides a signal-based communication interface to the upper layer (Rte). Also it is responsible for Packing and unpacking of signals in I-Pdus. Com configuration with different I-Pdus are shown below -</p>
<figure class="align-center" id="id34">
<img alt="Com Configuration" src="../_images/Com_Configuration.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.34 </span><span class="caption-text">Com Configuration</span><a class="headerlink" href="#id34" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="cansm-configuration-in-can-module">
<h5><span class="section-number">7.2.3.3.8. </span>CanSM Configuration in CAN Module<a class="headerlink" href="#cansm-configuration-in-can-module" title="Link to this heading"></a></h5>
<p>CanSM changes the communication modes of the configured CAN networks according to requests from the ComM module and and performs a bus-specific error handling (BusOff). CanSM configuration is shown below -</p>
<figure class="align-center" id="id35">
<img alt="CanSM Configuration" src="../_images/CanSm_Configuration.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.35 </span><span class="caption-text">CanSM Configuration</span><a class="headerlink" href="#id35" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="comm-configuration-in-can-module">
<h5><span class="section-number">7.2.3.3.9. </span>ComM Configuration in CAN Module<a class="headerlink" href="#comm-configuration-in-can-module" title="Link to this heading"></a></h5>
<p>The ComM is a resource manager, which encapsulates the control of the underlying services. The main purpose is controlling of multiple communication requests by the application independent of the used bus system -</p>
<figure class="align-center" id="id36">
<img alt="ComM configuration" src="../_images/ComM_Configuration.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.36 </span><span class="caption-text">ComM configuration</span><a class="headerlink" href="#id36" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="os-configuration-in-can-module">
<h5><span class="section-number">7.2.3.3.10. </span>Os Configuration in CAN Module<a class="headerlink" href="#os-configuration-in-can-module" title="Link to this heading"></a></h5>
<p>The OS module is responsible for task scheduling. Tasks such as 10ms and 1s are created to schedule different schedulable functions for CAN and respective BSW modules. The figure below illustrates the OS configuration -</p>
<figure class="align-center" id="id37">
<img alt="Os configuration" src="../_images/Os_Configuration.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.37 </span><span class="caption-text">Os configuration</span><a class="headerlink" href="#id37" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="rte-configuration-in-can-module">
<h5><span class="section-number">7.2.3.3.11. </span>Rte Configuration in CAN Module<a class="headerlink" href="#rte-configuration-in-can-module" title="Link to this heading"></a></h5>
<p>Runtime Environment (RTE) manages communication between the software components (SWC), assures consistency of the overall information flow between basic software (BSW). It also maps a BswSchedulableEntity onto a OsTask.</p>
<p>The scheduling of the CAN_MainFunction Read is shown below -</p>
<figure class="align-center" id="id38">
<img alt="Scheduling of Periodic Function - Read" src="../_images/Can_Readfunction.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.38 </span><span class="caption-text">Scheduling of Periodic Function - Read</span><a class="headerlink" href="#id38" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>The scheduling of CAN_MainFunction Write is shown below -</p>
<figure class="align-center" id="id39">
<img alt="Scheduling of Periodic Function - Write" src="../_images/Can_writeFunction.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.39 </span><span class="caption-text">Scheduling of Periodic Functions - Write</span><a class="headerlink" href="#id39" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>All runnable in the 10ms task are shown below -</p>
<figure class="align-center" id="id40">
<img alt="All Runnable in 10ms task" src="../_images/Rte_All_task.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.40 </span><span class="caption-text">All Runnable in 10ms task</span><a class="headerlink" href="#id40" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>In the RTE (Runtime Environment), the corresponding port is created based on the configuration, and it can be used to communication between software components.</p>
<p>The port connection to software component is shown below -</p>
<figure class="align-center" id="id41">
<img alt="Port connection to software component" src="../_images/Can_PortConnection.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.41 </span><span class="caption-text">Port connection to software component</span><a class="headerlink" href="#id41" title="Link to this image"></a></p>
</figcaption>
</figure>
<p><strong>Development Error Detection:</strong></p>
<p>This configuration enables development error detection in all BSW and MCAL modules. Please refer to this setup as a reference for configuring other modules -</p>
<figure class="align-center" id="id42">
<img alt="Configuration for Development Error Detection" src="../_images/Det_Error.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.42 </span><span class="caption-text">Configuration for Development Error Detection</span><a class="headerlink" href="#id42" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
</section>
</section>
<section id="adc-integration">
<h3><span class="section-number">7.2.4. </span>ADC Integration<a class="headerlink" href="#adc-integration" title="Link to this heading"></a></h3>
<section id="objective-for-adc-integration">
<h4><span class="section-number">7.2.4.1. </span>Objective for ADC Integration<a class="headerlink" href="#objective-for-adc-integration" title="Link to this heading"></a></h4>
<p>The purpose of ADC integration is to get digital voltage value from analog inputs by configuring TI MCAL modules along with Vector BSW Modules. Further details are explained in the subsequent chapter.</p>
</section>
<section id="list-of-modules-for-adc">
<h4><span class="section-number">7.2.4.2. </span>List Of Modules for ADC<a class="headerlink" href="#list-of-modules-for-adc" title="Link to this heading"></a></h4>
<section id="mcal-modules-for-adc-integration">
<h5><span class="section-number">7.2.4.2.1. </span>MCAL Modules for ADC Integration<a class="headerlink" href="#mcal-modules-for-adc-integration" title="Link to this heading"></a></h5>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Sl. No.</p></th>
<th class="head"><p>MCAL Modules</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>Significance in use case</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>ADC</p></td>
<td><p>The ADC module handles analog-to-digital conversions for external monitoring channels and internal temperature sensors, allowing start, stop, and result reading for configurable channel groups.</p></td>
<td><p>In this use-case, this module is used to convert analog voltage value to digital value.</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>Mcu</p></td>
<td><p>The MCU module manages microcontroller features such as power modes, clock settings, and interrupts.</p></td>
<td><p>In this use case, this module is responsible for providing the clock for ADC communication.</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For detailed information, please refer to the section <a class="reference internal" href="Module_User_Guide_Adc.html#adc-module"><span class="std std-ref">ADC Module</span></a>.</p>
</div>
</section>
<section id="vector-modules-for-adc-integration">
<h5><span class="section-number">7.2.4.2.2. </span>Vector Modules for ADC Integration<a class="headerlink" href="#vector-modules-for-adc-integration" title="Link to this heading"></a></h5>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Sl. No.</p></th>
<th class="head"><p>Vector Modules</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>Significance in use case</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>IoHwAb</p></td>
<td><p>The aim of the IoHwAb is to provide ECU hardware-independent data transition from driver modules up to the Software Components.</p></td>
<td><p>In this use case, IoHwAb layer provides wrapper function for each of the underlying ADC API’s, so that the application is independent on the hardware.</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>OS (MICROSAR Operating System)</p></td>
<td><p>The Operating System is mainly responsible for handling tasks and interrupts.</p></td>
<td><p>In this use case, OS module is used to define periodic tasks needed for ADC communication such as processing transmit and receive message.</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>RTE (MICROSAR Runtime Environment)</p></td>
<td><p>The Runtime Environment module manages the information flow between Software Components (SWCs), BSW and CDDs.</p></td>
<td><p>In this use case, Rte module is used to schedule the periodic tasks defined in the operating system (OS) and sender receiver ports created for sending receiving can messages from application.</p></td>
</tr>
<tr class="row-odd"><td><p>4</p></td>
<td><p>DET</p></td>
<td><p>The DET is used in order to report development errors. The DET can be replaced optionally by an equivalent component which is responsible for recognizing development errors, if no DET component is available.</p></td>
<td><p>In this use Case, Development error is enabled to detect all development errors.</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For detailed information on each module and its features, please refer to the Technical Reference Manual provided by Vector.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For importing MCAL configuration files to DaVinci refer <a class="reference internal" href="#importing-ti-mcal-modules-from-eb-tresos-to-vector-davinci-configurator"><span class="std std-ref">Importing TI MCAL modules from EB Tresos to Vector DaVinci Configurator</span></a>.</p>
</div>
</section>
</section>
<section id="configuration-of-modules-in-adc-integration">
<h4><span class="section-number">7.2.4.3. </span>Configuration of modules in ADC Integration<a class="headerlink" href="#configuration-of-modules-in-adc-integration" title="Link to this heading"></a></h4>
<p>This chapter explains the basic configurations that are needed to realize ADC communication</p>
<section id="adc-configuration">
<h5><span class="section-number">7.2.4.3.1. </span>ADC Configuration<a class="headerlink" href="#adc-configuration" title="Link to this heading"></a></h5>
<p>TI ADC driver is configured using EB Tresos tool. It is then imported to Vector DaVinci configurator for integration with BSW stack. Following containers and parameters shall be configured.</p>
<p><strong>AdcGeneral:</strong></p>
<p>The AdcGeneral container defines the generic configuration parameters for ADC and provide provisions to enable disable API’s. The following figure shows the configuration of parameters interrupt as ADC_ISR_CAT2 and result alignment as ADC_ALIGN_RIGHT -</p>
<figure class="align-center" id="id43">
<img alt="Configuration for Adc_General" src="../_images/Adc_General.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.43 </span><span class="caption-text">Configuration for Adc_General</span><a class="headerlink" href="#id43" title="Link to this image"></a></p>
</figcaption>
</figure>
<p><strong>AdcHwUnit:</strong></p>
<p>The AdcHwUnit container defines the configuration of individual ADC hardware units. It defines hardware related settings such as hardware unit to be used and resolution. The following figure shows the ADCHwUnit configurations -</p>
<figure class="align-center" id="id44">
<img alt="Configuration for AdcHWUnit" src="../_images/Adc_HwUnit.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.44 </span><span class="caption-text">Configuration for AdcHWUnit</span><a class="headerlink" href="#id44" title="Link to this image"></a></p>
</figcaption>
</figure>
<p><strong>AdcChannel:</strong></p>
<p>The AdcChannel container defines the channel configuration depending on the hardware capabilities. The following figure shows the configuration of AdcChannel high/low limit and channel ID and channel range -</p>
<figure class="align-center" id="id45">
<img alt="Configuration for ADC channel" src="../_images/Adc_Channel.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.45 </span><span class="caption-text">Configuration for ADC channel</span><a class="headerlink" href="#id45" title="Link to this image"></a></p>
</figcaption>
</figure>
<p><strong>AdcChannelGroup:</strong></p>
<p>The AdcChannelGroup configures multiple channels together, and it defines group-specific settings such as conversion mode and trigger source. The following figure shows the configuration of ADC_CONV_MODE_ONESHOT mode -</p>
<figure class="align-center" id="id46">
<img alt="Configuration for AdcChannelGroup" src="../_images/Adc_ChannelGroup.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.46 </span><span class="caption-text">Configuration for AdcChannelGroup</span><a class="headerlink" href="#id46" title="Link to this image"></a></p>
</figcaption>
</figure>
<p><strong>AdcGroupDefinition:</strong></p>
<p>The AdcChannelGroupDefinition configures AdcChannel reference. AdcChannel_0 reference provided in AdcGroup_0 is shown below -</p>
<figure class="align-center" id="id47">
<img alt="Configuration for AdcGroupDefinition" src="../_images/Adc_GroupDefinition.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.47 </span><span class="caption-text">Configuration for AdcGroupDefinition</span><a class="headerlink" href="#id47" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="mcu-configuration-in-adc-module">
<h5><span class="section-number">7.2.4.3.2. </span>Mcu Configuration in ADC Module<a class="headerlink" href="#mcu-configuration-in-adc-module" title="Link to this heading"></a></h5>
<p>The McuInterruptChannelXbar configuration is set to ‘MCU_INTRXBAR0_OUT_1’ and mapped to ‘MCU_INT_XBAR_ADC1_INT1. ADC interrupt is needed to be mapped through XBAR configuration. As shown in the figure, MCU_INTRXBAR0_OUT_1 an XBAR interrpt is being mapped to MCU_INT_XBAR_ADC1_INT1, which is the interrupt for ADC hardware unit 1.</p>
<p>The ADC interruption channel configuration is shown below -</p>
<figure class="align-center" id="id48">
<img alt="Configuration for AdcInterrupt" src="../_images/Adc_Mcuxbar.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.48 </span><span class="caption-text">Configuration for AdcInterrupt</span><a class="headerlink" href="#id48" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>ADC hardware unit reference in MCU module is shown below -</p>
<figure class="align-center" id="id49">
<img alt="Configuration for McuAdcHWUnitId" src="../_images/Mcu_AdcHWUnitId.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.49 </span><span class="caption-text">Configuration for McuAdcHWUnitId</span><a class="headerlink" href="#id49" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="iohwab-configuration-in-adc-module">
<h5><span class="section-number">7.2.4.3.3. </span>IoHwAb Configuration in ADC Module<a class="headerlink" href="#iohwab-configuration-in-adc-module" title="Link to this heading"></a></h5>
<p>IoHwAb is a layer in the AUTOSAR architecture that abstracts hardware-level interfaces and provides a standardized API to the upper layers. It bridges the gap between hardware peripherals (like ADCs, GPIOs, etc.) and software components, ensuring hardware independence for application layers.</p>
<p>The configuration process for creating IoHwAb_AdcReadResultBuffer API in the IoHwAbCSPortInterfaces container is shown below -</p>
<figure class="align-center" id="id50">
<img alt="Configuration for IoHwAb_AdcReadResultBuffer" src="../_images/IoHwAb_AdcResultBuffer.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.50 </span><span class="caption-text">Configuration for IoHwAb_AdcReadResultBuffer</span><a class="headerlink" href="#id50" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>The configuration process for creating IoHwAbAdcReadResultBuffer API in the IoHwAbCSPortPrototypes container is shown below -</p>
<figure class="align-center" id="id51">
<img alt="Configuration for IoHwAbAdcReadResultBuffer" src="../_images/IoHwAb_AdcResultBuffer1.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.51 </span><span class="caption-text">Configuration for IoHwAb_AdcReadResultBuffer</span><a class="headerlink" href="#id51" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>The interface between IoHwAb module and Mcal module API is shown below -</p>
<figure class="align-center" id="id52">
<img alt="Function call between IoHwAb and ADC" src="../_images/Adc_readbuffer.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.52 </span><span class="caption-text">Function call between IoHwAb and ADC</span><a class="headerlink" href="#id52" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>In the RTE (Runtime Environment), the corresponding port is created based on the configuration, and it can be used to communication between software components.</p>
<p>The port connection to software component is shown below -</p>
<figure class="align-center" id="id53">
<img alt="Port connection to software component" src="../_images/Adc_PortConnection.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.53 </span><span class="caption-text">Port connection to software component</span><a class="headerlink" href="#id53" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="os-configuration-in-adc-module">
<h5><span class="section-number">7.2.4.3.4. </span>Os Configuration in ADC Module<a class="headerlink" href="#os-configuration-in-adc-module" title="Link to this heading"></a></h5>
<p>The OS module is responsible for task scheduling. The mapping of ADC Mainfunction to the 10ms event is shown below -</p>
<figure class="align-center" id="id54">
<img alt="Os configuration" src="../_images/Os_AdcMainFunction.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.54 </span><span class="caption-text">Os configuration</span><a class="headerlink" href="#id54" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="rte-configuration-in-adc-module">
<h5><span class="section-number">7.2.4.3.5. </span>Rte Configuration in ADC Module<a class="headerlink" href="#rte-configuration-in-adc-module" title="Link to this heading"></a></h5>
<p>The ADC main function is mapped to a 10ms task as shown in the below -</p>
<figure class="align-center" id="id55">
<img alt="Mapping ADC main function to 10ms task" src="../_images/ADC_Mainfunction.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.55 </span><span class="caption-text">Mapping ADC main function to 10ms task</span><a class="headerlink" href="#id55" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
</section>
</section>
<section id="spi-integration">
<h3><span class="section-number">7.2.5. </span>SPI Integration<a class="headerlink" href="#spi-integration" title="Link to this heading"></a></h3>
<section id="objective-for-spi-integration">
<h4><span class="section-number">7.2.5.1. </span>Objective for SPI Integration<a class="headerlink" href="#objective-for-spi-integration" title="Link to this heading"></a></h4>
<p>The intention of SPI integration is to establish successful SPI communication by configuring the SPI MCAL and dependent Vector modules. It will facilitate communication between the MCAL modules, transmitting and receiving data from the Vector module, which will be explained in the subsequent chapter.</p>
</section>
<section id="list-of-modules-for-spi">
<h4><span class="section-number">7.2.5.2. </span>List of Modules for SPI<a class="headerlink" href="#list-of-modules-for-spi" title="Link to this heading"></a></h4>
<section id="mcal-modules-for-spi-integration">
<h5><span class="section-number">7.2.5.2.1. </span>MCAL Modules for SPI Integration<a class="headerlink" href="#mcal-modules-for-spi-integration" title="Link to this heading"></a></h5>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Sl. No.</p></th>
<th class="head"><p>MCAL Modules</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>Significance in use case</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>Mcu</p></td>
<td><p>The MCU module manages microcontroller features such as power modes, clock settings, and interrupts.</p></td>
<td><p>In this use case, this module is responsible for providing the clock for SPI communication.</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>SPI (Serial Peripheral Interface)</p></td>
<td><p>The main tasks of the SPI are Handle data transmission to the components connected via SPI, take care of the settings required by external components (baud rate etc.)</p></td>
<td><p>In this use case, this module is responsible for configuring spi channel, job and sequence.</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>Port</p></td>
<td><p>The PORT module provides an interface to configure and control microcontroller pins (e.g., GPIO, ADC, PWM).</p></td>
<td><p>In this use case, this module is responsible for configuring the hardware pins necessary for Spi communication.</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For detailed information, please refer to the section <a class="reference internal" href="Module_User_Guide_Spi.html#spi-module"><span class="std std-ref">SPI Module</span></a>.</p>
</div>
</section>
<section id="vector-modules-for-spi-integration">
<h5><span class="section-number">7.2.5.2.2. </span>Vector Modules for SPI Integration<a class="headerlink" href="#vector-modules-for-spi-integration" title="Link to this heading"></a></h5>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Sl. No.</p></th>
<th class="head"><p>Vector Modules</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>Significance in use case</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>IoHwAb</p></td>
<td><p>The aim of the IoHwAb is to provide ECU hardware-independent data transition from driver modules up to the Software Components.</p></td>
<td><p>In this use case, IoHwAb layer provides wrapper function for each of the underlying SPI API’s, so that the application is independent on the hardware.</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>OS (MICROSAR Operating System)</p></td>
<td><p>The Operating System is mainly responsible for handling tasks and interrupts.</p></td>
<td><p>In this use case, OS module is used to define periodic tasks needed for SPI communication such as processing transmit and receive message.</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>RTE (MICROSAR Runtime Environment)</p></td>
<td><p>The Runtime Environment module manages the information flow between Software Components (SWCs), BSW and CDDs.</p></td>
<td><p>In this use case, Rte module is used to schedule the periodic tasks defined in the operating system (OS) and sender receiver ports created for sending receiving spi messages from application.</p></td>
</tr>
<tr class="row-odd"><td><p>4</p></td>
<td><p>DET</p></td>
<td><p>The DET is used in order to report development errors. The DET can be replaced optionally by an equivalent component which is responsible for recognizing development errors, if no DET component is available.</p></td>
<td><p>In this use Case, Development error is enabled to detect all development errors.</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For detailed information on each module and its features, please refer to the Technical Reference Manual provided by Vector.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For importing MCAL configuration files to DaVinci refer <a class="reference internal" href="#importing-ti-mcal-modules-from-eb-tresos-to-vector-davinci-configurator"><span class="std std-ref">Importing TI MCAL modules from EB Tresos to Vector DaVinci Configurator</span></a>.</p>
</div>
</section>
</section>
<section id="configuration-of-modules-in-spi-integration">
<h4><span class="section-number">7.2.5.3. </span>Configuration of modules in Spi Integration<a class="headerlink" href="#configuration-of-modules-in-spi-integration" title="Link to this heading"></a></h4>
<p>This chapter explains the basic configurations that are needed to realize SPI communication.</p>
<section id="spi-configuration">
<h5><span class="section-number">7.2.5.3.1. </span>Spi configuration<a class="headerlink" href="#spi-configuration" title="Link to this heading"></a></h5>
<p>TI SPI driver is configured using EB Tresos tool. It is then imported to Vector DaVinci configurator for integration with SPI stack. Following containers and parameters shall be configured.</p>
<p><strong>SpiGeneral:</strong></p>
<p>The SpiGeneral container is used to configure SPI-related global settings that affect the SPI driver as a whole. It manages essential settings like enabling Apis and setting timeout duration, maxjobs and maxSequences etc. The following figure shows the configuration of SpiMainFunctionPeriod with 10ms -</p>
<figure class="align-center" id="id56">
<img alt="Configuration for SpiGeneral" src="../_images/Spi_General.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.56 </span><span class="caption-text">Configuration for SpiGeneral</span><a class="headerlink" href="#id56" title="Link to this image"></a></p>
</figcaption>
</figure>
<p><strong>SpiMaxChannel:</strong></p>
<p>The SpiMaxChannel container Specifies the maximum number of SPI channels that can be configured and used by the SPI driver in the system. The configuration of max channels is shown below -</p>
<figure class="align-center" id="id57">
<img alt="Configuration for spiMaxChannel" src="../_images/Spi_MaxChannel.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.57 </span><span class="caption-text">Configuration for spiMaxChannel</span><a class="headerlink" href="#id57" title="Link to this image"></a></p>
</figcaption>
</figure>
<p><strong>SpiJob:</strong></p>
<p>The SpiJob container specifies the Spi job priority, Device assignment and HW unit assignment. The configuration of Spijob is shown below -</p>
<figure class="align-center" id="id58">
<img alt="Configuration for SpiJob" src="../_images/Spi_Job.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.58 </span><span class="caption-text">Configuration for SpiJob</span><a class="headerlink" href="#id58" title="Link to this image"></a></p>
</figcaption>
</figure>
<p><strong>SpiHwUnitSynchronous:</strong></p>
<p>The SpiHwUnitSynchronous container is set to “SYNCHRONOUS”, the SpiJob uses its contained SpiDriver in a synchronous manner. If it is set to “ASYNCHRONOUS”, it uses the driver in an asynchronous way. The configuration of SYNCHRONOUS is shown below -</p>
<figure class="align-center" id="id59">
<img alt="Configuration for SpiHwUnitsynchronous" src="../_images/SpiJob_Sync.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.59 </span><span class="caption-text">Configuration for SpiHwUnitsynchronous</span><a class="headerlink" href="#id59" title="Link to this image"></a></p>
</figcaption>
</figure>
<p><strong>SpiJobEndNotification:</strong></p>
<p>The SpiJobEndNotification parameter is a reference to a notification function. The configuration of NULL_PTR is shown below -</p>
<figure class="align-center" id="id60">
<img alt="Configuration for SpiJobEndNotification" src="../_images/Spi_JobEndnotification.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.60 </span><span class="caption-text">Configuration for SpiJobEndNotification</span><a class="headerlink" href="#id60" title="Link to this image"></a></p>
</figcaption>
</figure>
<p><strong>SpiChannelList:</strong></p>
<p>The SpiChannelList container references spi channels and their order within the job. The configuration of spi channel order is shown below -</p>
<figure class="align-center" id="id61">
<img alt="Configuration of SpiChannelList" src="../_images/Spi_ChannelList.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.61 </span><span class="caption-text">Configuration of SpiChannelList</span><a class="headerlink" href="#id61" title="Link to this image"></a></p>
</figcaption>
</figure>
<p><strong>SpiMaxSequence:</strong></p>
<p>The SpiMaxSequence configures the maximum number of SPI sequences that the SPI driver can handle concurrently or sequentially in the system. The configuration of the Max sequence is shown below -</p>
<figure class="align-center" id="id62">
<img alt="Configuration for SpiMaxSequence" src="../_images/Spi_MaxSequnce.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.62 </span><span class="caption-text">Configuration for SpiMaxSequence</span><a class="headerlink" href="#id62" title="Link to this image"></a></p>
</figcaption>
</figure>
<p><strong>SpiChannel:</strong></p>
<p>The SpiChannel configuration defines the parameters for a specific SPI channelId, channeltype, data width and transfer start, etc. The configuration of SpiChannel is shown below -</p>
<figure class="align-center" id="id63">
<img alt="Configuration of SpiChannel" src="../_images/Spi_Channel.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.63 </span><span class="caption-text">Configuration of SpiChannel</span><a class="headerlink" href="#id63" title="Link to this image"></a></p>
</figcaption>
</figure>
<p><strong>SpiExternalDevice:</strong></p>
<p>The SpiExternalDevice container is used to define the properties and configuration settings for an SPI peripheral device that is external to the ECU. It specifies how the ECU (master) will communicate with an external device (slave) via the SPI interface. This configuration includes details about the device’s requirements for communication, such as timing, data format, and the SPI mode -</p>
<figure class="align-center" id="id64">
<img alt="Configuration for SpiExternalDevice" src="../_images/Spi_externalDevice.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.64 </span><span class="caption-text">Configuration for SpiExternalDevice</span><a class="headerlink" href="#id64" title="Link to this image"></a></p>
</figcaption>
</figure>
<p><strong>SpiSequence:</strong></p>
<p>The SpiSequence configuration defines a series of SpiJobs that are executed in a particular order to achieve a complete communication task. The configuration of spi sequence Id is shown below -</p>
<figure class="align-center" id="id65">
<img alt="Configuration of SpiSequence" src="../_images/Spi_Sequnce.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.65 </span><span class="caption-text">Configuration of SpiSequence</span><a class="headerlink" href="#id65" title="Link to this image"></a></p>
</figcaption>
</figure>
<p><strong>SpiSeqEndNotification:</strong></p>
<p>The SpiSeqEndNotification contains a reference to a notification function. The following figure is shown below -</p>
<figure class="align-center" id="id66">
<img alt="Configuration for SpiSeqEndNotification" src="../_images/Spi_Endjobnotification.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.66 </span><span class="caption-text">Configuration for SpiSeqEndNotification</span><a class="headerlink" href="#id66" title="Link to this image"></a></p>
</figcaption>
</figure>
<p><strong>SpiJobAssignment:</strong></p>
<p>The SpiJobAssignment container references several jobs, which are executed during a communication sequence. The following figure is show below -</p>
<figure class="align-center" id="id67">
<img alt="Configuration for SpiJobAssignment" src="../_images/Spi_Assignment.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.67 </span><span class="caption-text">Configuration for SpiJobAssignment</span><a class="headerlink" href="#id67" title="Link to this image"></a></p>
</figcaption>
</figure>
<p><strong>SpiHwUnitConfig:</strong></p>
<p>The SpiHwUnitConfig is used to define the hardware settings to initialize and control the physical SPI hardware unit (such as SPI0, SPI1, etc.) on the microcontroller -</p>
<figure class="align-center" id="id68">
<img alt="Configuration of SpiHwUnitConfig" src="../_images/Spi_Hwunit.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.68 </span><span class="caption-text">Configuration of SpiHwUnitConfig</span><a class="headerlink" href="#id68" title="Link to this image"></a></p>
</figcaption>
</figure>
<p><strong>SpiUserCallbackHeaderFile:</strong></p>
<p>The SpiUserCallbackHeaderFile specifies the header file that contains user-defined callback functions that the SPI driver can call at various stages of the SPI communication process -</p>
<figure class="align-center" id="id69">
<img alt="Configuration for SpiUserCallbackHeaderFile" src="../_images/Spi_Usecallbackheader.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.69 </span><span class="caption-text">Configuration for SpiUserCallbackHeaderFile</span><a class="headerlink" href="#id69" title="Link to this image"></a></p>
</figcaption>
</figure>
<p><strong>SpiHwUnitEnabled:</strong></p>
<p>The SpiHwUnitEnabled is used for storing enabled SPI HW units -</p>
<figure class="align-center" id="id70">
<img alt="Configuration for SpiHwUnitEnabled" src="../_images/Spi_HwunitEnabled.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.70 </span><span class="caption-text">Configuration for SpiHwUnitEnabled</span><a class="headerlink" href="#id70" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="port-configuration-in-spi-module">
<h5><span class="section-number">7.2.5.3.2. </span>Port Configuration in SPI Module<a class="headerlink" href="#port-configuration-in-spi-module" title="Link to this heading"></a></h5>
<p>In the configuration of the SPI module, the port pins are used to facilitate the transmission (Tx) and reception (Rx) of data. The pin configurations for both SPI0 and SPI1 are shown below -</p>
<figure class="align-center" id="id71">
<img alt="Port pin configuration for spi" src="../_images/SPI_Port.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.71 </span><span class="caption-text">Port pin configuration for spi</span><a class="headerlink" href="#id71" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>The SPI0 clock pin configuration is shown below -</p>
<figure class="align-center" id="id72">
<img alt="Configuration for Spi clock pin" src="../_images/Spi_clockpin.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.72 </span><span class="caption-text">Configuration for Spi clock pin</span><a class="headerlink" href="#id72" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="iohwab-configuration-in-spi-module">
<h5><span class="section-number">7.2.5.3.3. </span>IoHwAb configuration in SPI Module<a class="headerlink" href="#iohwab-configuration-in-spi-module" title="Link to this heading"></a></h5>
<p>The configuration process for determining the IoHwAb_Async_Transmit API in the IoHwAbCSPortInterfaces container is shown below -</p>
<figure class="align-center" id="id73">
<img alt="Configuration for IoHwAbCSPortInterface" src="../_images/Spi_AsyncTransmit.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.73 </span><span class="caption-text">Configuration for IoHwAbCSPortInterface</span><a class="headerlink" href="#id73" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>The configuration process for determining IoHwAbCSAsyncTransmit API in the IoHwAbCSPortPrototypes container is shown below -</p>
<figure class="align-center" id="id74">
<img alt="Configuration for IoHwAbCSPortPrototypes" src="../_images/Spi_AsyncTransmit1.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.74 </span><span class="caption-text">Configuration for IoHwAbCSPortPrototypes</span><a class="headerlink" href="#id74" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>The function call interaction between the IoHwAb module and the Mcal module API is shown below -</p>
<figure class="align-center" id="id75">
<img alt="Function call between IoHwAb and SPI" src="../_images/Spi_IohwAbApi.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.75 </span><span class="caption-text">Function call between IoHwAb and SPI</span><a class="headerlink" href="#id75" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>In the RTE (Runtime Environment), the corresponding port is created based on the configuration, and it can be used to communication between software components.</p>
<p>The port connection to software component is shown below -</p>
<figure class="align-center" id="id76">
<img alt="Port connection to software component" src="../_images/Spi_PortConnection.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.76 </span><span class="caption-text">Port connection to software component</span><a class="headerlink" href="#id76" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="rte-configuration-in-spi-module">
<h5><span class="section-number">7.2.5.3.4. </span>Rte Configuration in SPI Module<a class="headerlink" href="#rte-configuration-in-spi-module" title="Link to this heading"></a></h5>
<p>The SPI main function timing event handling is mapped to a 10ms task, and its position is specified as shown below. The importance of the position parameter comes into play when more than one function is mapped to the same task. The position parameter determines the execution order of the mapped functions within that particular task, with lower values executing first -</p>
<figure class="align-center" id="id77">
<img alt="Configuring 10ms task to spi_mainfunctionTimingEvent_Handling" src="../_images/Spi_RteMainfunction.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.77 </span><span class="caption-text">Configuring 10ms task to spi_mainfunctionTimingEvent_Handling</span><a class="headerlink" href="#id77" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
</section>
</section>
<section id="pwm-integration">
<h3><span class="section-number">7.2.6. </span>PWM Integration<a class="headerlink" href="#pwm-integration" title="Link to this heading"></a></h3>
<section id="objective-for-pwm-integration">
<h4><span class="section-number">7.2.6.1. </span>Objective for PWM Integration<a class="headerlink" href="#objective-for-pwm-integration" title="Link to this heading"></a></h4>
<p>The intention of PWM Integration is to enable successful PWM signal generation by configuring TI MCAL modules along with Vector BSW Modules. Further details are explained in the subsequent chapter.</p>
</section>
<section id="list-of-modules-for-pwm">
<h4><span class="section-number">7.2.6.2. </span>List of Modules for PWM<a class="headerlink" href="#list-of-modules-for-pwm" title="Link to this heading"></a></h4>
<section id="mcal-modules-for-pwm-integration">
<h5><span class="section-number">7.2.6.2.1. </span>MCAL Modules for PWM Integration<a class="headerlink" href="#mcal-modules-for-pwm-integration" title="Link to this heading"></a></h5>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Sl. No.</p></th>
<th class="head"><p>MCAL Modules</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>Significance in use case</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>Mcu</p></td>
<td><p>The MCU module manages microcontroller features for PWM, such as power modes and clock settings.</p></td>
<td><p>In this use case, this module is responsible for providing the clock for PWM signal generation.</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>Port</p></td>
<td><p>The PORT module provides an interface to configure and control microcontroller pins (e.g., GPIO, ADC, PWM).</p></td>
<td><p>In this use case, this module is responsible for configuring the hardware pins necessary for PWM signal generation.</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>Pwm</p></td>
<td><p>The PWM module initializes and controls the internal PWM peripherals of the microcontroller. It provides services to configure, start, and stop PWM channels used for generating variable duty cycle signals</p></td>
<td><p>In this use case, PWM is used to generate PWM signal with different duty cycle.</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For detailed information, please refer to the section <a class="reference internal" href="Module_User_Guide_Pwm.html#pwm-module"><span class="std std-ref">PWM Module</span></a>.</p>
</div>
</section>
<section id="vector-modules-for-pwm-integration">
<h5><span class="section-number">7.2.6.2.2. </span>Vector Modules for PWM Integration<a class="headerlink" href="#vector-modules-for-pwm-integration" title="Link to this heading"></a></h5>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Sl. No.</p></th>
<th class="head"><p>Vector Modules</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>Significance in use case</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>IoHwAb</p></td>
<td><p>The aim of the IoHwAb is to provide ECU hardware-independent data transition from driver modules up to the Software Components.</p></td>
<td><p>It provides an abstraction for the PWM driver and enables communication with the application layer.</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>OS</p></td>
<td><p>The Operating System is mainly responsible for handling tasks.</p></td>
<td><p>In this use case, it is used to initialize PWM.</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>RTE</p></td>
<td><p>The Runtime Environment module manages the information flow</p></td>
<td><p>In this use case, it is used to schedule the periodic task defined in OS.</p></td>
</tr>
<tr class="row-odd"><td><p>4</p></td>
<td><p>DET</p></td>
<td><p>The DET is used in order to report development errors. The DET can be replaced optionally by an equivalent component which is responsible for recognizing development errors, if no DET component is available.</p></td>
<td><p>In this use Case, Development error is enabled to detect all development errors.</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For detailed information on each module and its features, please refer to the Technical Reference Manual provided by Vector.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For importing MCAL configuration files to DaVinci refer <a class="reference internal" href="#importing-ti-mcal-modules-from-eb-tresos-to-vector-davinci-configurator"><span class="std std-ref">Importing TI MCAL modules from EB Tresos to Vector DaVinci Configurator</span></a>.</p>
</div>
</section>
</section>
<section id="configuration-of-modules-in-pwm-integration">
<h4><span class="section-number">7.2.6.3. </span>Configuration of modules in PWM Integration<a class="headerlink" href="#configuration-of-modules-in-pwm-integration" title="Link to this heading"></a></h4>
<p>This chapter explains the basic configurations that are needed to realize PWM functionality.</p>
<section id="pwm-configuration">
<h5><span class="section-number">7.2.6.3.1. </span>PWM Configuration<a class="headerlink" href="#pwm-configuration" title="Link to this heading"></a></h5>
<p>The PWM driver is configured using the EB Tresos tool and then imported into the Vector DaVinci Configurator for integration with the application software. The following containers and parameters should be configured.</p>
<p><strong>PwmGeneral:</strong></p>
<p>The PwmGeneral container provides general configuration settings for the PWM module.</p>
<p>In PWM general settings, PWMSetDutyCycle API is enabled as shown below -</p>
<figure class="align-center" id="id78">
<img alt="PWM General Settings" src="../_images/PWM_General_Settings.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.78 </span><span class="caption-text">PWM General Settings</span><a class="headerlink" href="#id78" title="Link to this image"></a></p>
</figcaption>
</figure>
<p><strong>PwmChannel:</strong></p>
<p>The PwmChannel configuration container specifies the settings for a specific PWM channel.</p>
<p>In the PWM channel configuration, the channel ID is set to 3, the default duty cycle is configured as 16384, and the PWM polarity is set to high, as shown below -</p>
<figure class="align-center" id="id79">
<img alt="Configuration for Pwm Channel" src="../_images/Configuration_of_PWM_Channel.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.79 </span><span class="caption-text">Configuration of PWM Channel</span><a class="headerlink" href="#id79" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="mcu-configuration-in-pwm-module">
<h5><span class="section-number">7.2.6.3.2. </span>Mcu Configuration in PWM Module<a class="headerlink" href="#mcu-configuration-in-pwm-module" title="Link to this heading"></a></h5>
<p>The PWM module has dependencies on MCU module to provide the PWM clock setting reference.</p>
<p>The MCU clock configuration for PWM controller is shown below -</p>
<figure class="align-center" id="id80">
<img alt="Configuration of McuClockSettingconfig" src="../_images/Configuration_of_McuClockSettingconfig.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.80 </span><span class="caption-text">Configuration of McuClockSettingconfig</span><a class="headerlink" href="#id80" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>PWM clock should be derived from MCU clock reference point.</p>
<p>The MCU clock reference point is shown below -</p>
<figure class="align-center" id="id81">
<img alt="Configuration of McuClockReferencePoint" src="../_images/Configuration_of_McuClockReferencePoint.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.81 </span><span class="caption-text">Configuration of McuClockReferencePoint</span><a class="headerlink" href="#id81" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="port-configuration-in-pwm-module">
<h5><span class="section-number">7.2.6.3.3. </span>Port Configuration in PWM Module<a class="headerlink" href="#port-configuration-in-pwm-module" title="Link to this heading"></a></h5>
<p>The PWM module has a dependency on the Port module to configure the output pins used for generating PWM signals. Each PWM channel is mapped to a specific physical pin on the microcontroller, which must be configured as an output using the Port module.</p>
<p>In the port pin configuration, EPWM3 is configured as a PWM output, as shown below -</p>
<figure class="align-center" id="id82">
<img alt="Port pin configuration for Pwm" src="../_images/Port_pin_configuration_for_Pwm.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.82 </span><span class="caption-text">Port Pin configuration for Pwm</span><a class="headerlink" href="#id82" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="iohwab-configuration-in-pwm-module">
<h5><span class="section-number">7.2.6.3.4. </span>IoHwAb Configuration in PWM Module<a class="headerlink" href="#iohwab-configuration-in-pwm-module" title="Link to this heading"></a></h5>
<p>IoHwAb is a layer in the AUTOSAR architecture that abstracts hardware-level interfaces and provides a standardized API to the upper layers.</p>
<p>To configure a Client/Server Port Interface, the container IoHwAb_PWM_DutyCycle holds the configuration elements for a Client/Server template interface. This interface is instantiated by a Client/Server Port Prototype.</p>
<p>The container IoHwAbOperationArguments contains the configuration of Operation Elements, such as ChannelID and DutyCycle, for a Client/Server Operation. These Operation Elements will be generated as function parameters in the I/O Hardware Abstraction (IoHwAb) implementation.</p>
<p>Similarly, it is possible to enable communication between the I/O Client/Server interface and the MCAL APIs.</p>
<p>Configuration of pwm IoHwAbCS port interface as shown below -</p>
<figure class="align-center" id="id83">
<img alt="Configuration for Pwm IoHwAbCSPortInterface" src="../_images/Configuration_of_PWM_IoHwAb_CS_Port_Interface.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.83 </span><span class="caption-text">Configuration for Pwm IoHwAbCSPortInterface</span><a class="headerlink" href="#id83" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>The container IoHwAbPWMDutyCycle is used for configuring a Client/Server Port Prototype. This container represents an instantiation of a Client/Server Port Interface.</p>
<p>Configuration of pwm IoHwAbCS port prototype as shown below -</p>
<figure class="align-center" id="id84">
<img alt="Configuration for Pwm IoHwAbCSPortPrototypes" src="../_images/Configuration_of_PWM_IoHwAb_CS_Port_Prototype.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.84 </span><span class="caption-text">Configuration for Pwm IoHwAbCSPortPrototypes</span><a class="headerlink" href="#id84" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>The function IoHwAb_IoHwAbPWMDutyCycle_IoHwAbOperation is generated, and then the MCAL API function Pwm_SetDutyCycle is called -</p>
<figure class="align-center" id="id85">
<img alt="Invoking MCAL API SetDutyCycle" src="../_images/IOHWAB_set_Duty_Cycle.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.85 </span><span class="caption-text">Invoking MCAL API SetDutyCycle</span><a class="headerlink" href="#id85" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>In the RTE (Runtime Environment), the corresponding port is created based on the configuration, and it can be used to communication between software components.</p>
<p>The port connection to software component is shown below -</p>
<figure class="align-center" id="id86">
<img alt="Port connection to software component" src="../_images/Pwm_PortConnection.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.86 </span><span class="caption-text">Port connection to software component</span><a class="headerlink" href="#id86" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
</section>
</section>
<section id="lin-integration">
<h3><span class="section-number">7.2.7. </span>LIN Integration<a class="headerlink" href="#lin-integration" title="Link to this heading"></a></h3>
<section id="objective-for-lin-integration">
<h4><span class="section-number">7.2.7.1. </span>Objective for LIN Integration<a class="headerlink" href="#objective-for-lin-integration" title="Link to this heading"></a></h4>
<p>The intention of LIN integration is to establish successful LIN communication by configuring the MCAL and Vector modules. To achieve effective communication between the LIN master and slave, proper configurations are implemented, which will be explained in the subsequent chapter.</p>
</section>
<section id="list-of-modules-for-lin">
<h4><span class="section-number">7.2.7.2. </span>List of Modules for LIN<a class="headerlink" href="#list-of-modules-for-lin" title="Link to this heading"></a></h4>
<section id="mcal-modules-for-lin-integration">
<h5><span class="section-number">7.2.7.2.1. </span>MCAL Modules for LIN Integration<a class="headerlink" href="#mcal-modules-for-lin-integration" title="Link to this heading"></a></h5>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Sl. No.</p></th>
<th class="head"><p>MCAL Modules</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>Significance in use case</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>Mcu</p></td>
<td><p>Manages microcontroller features such as power modes, clock settings, and interrupts.</p></td>
<td><p>In this use case this module is used to provide clock for CAN communication.</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>Port</p></td>
<td><p>Provides an interface to configure and control microcontroller pins (e.g., GPIO, ADC, PWM).</p></td>
<td><p>In this use case allows application software to interact with hardware pins, making it transmit and receive LIN Message.</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>Lin</p></td>
<td><p>A communication protocol for low-speed communication between ECUs (Electronic Control Units) in automotive applications.</p></td>
<td><p>In this use case, it is used for communication between the MCAL layer and the Application layer to transmit and receive data.</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For detailed information, please refer to the section <a class="reference internal" href="Module_User_Guide_Lin.html#lin-module"><span class="std std-ref">LIN Module</span></a>.</p>
</div>
</section>
<section id="vector-modules-for-lin-integration">
<h5><span class="section-number">7.2.7.2.2. </span>Vector Modules for LIN Integration<a class="headerlink" href="#vector-modules-for-lin-integration" title="Link to this heading"></a></h5>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Sl. No.</p></th>
<th class="head"><p>Vector Modules</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>Significance in use case</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>EcuC</p></td>
<td><p>Virtual module to collect ECU Configuration specific / global configuration information.</p></td>
<td><p>In this use case, EcuC collects all Pdu objects flowing through the Com-Stack.</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>LinIf</p></td>
<td><p>Provides an interface for handling communication over the LIN (Local Interconnect Network) protocol.</p></td>
<td><p>In this use case, LinIf ensures communication between application software and the LIN hardware.</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>LinSM</p></td>
<td><p>Manages the state machine for the LIN communication stack.</p></td>
<td><p>In this use case, LinSM manages the state transitions of the Lin controller to error recovery and maintain reliable communication.</p></td>
</tr>
<tr class="row-odd"><td><p>4</p></td>
<td><p>OS (MICROSAR Operating System)</p></td>
<td><p>The Operating System is mainly responsible for handling of tasks and interrupts.</p></td>
<td><p>In this use case, it used to define a periodic task.</p></td>
</tr>
<tr class="row-even"><td><p>5</p></td>
<td><p>RTE (MICROSAR Runtime Environment)</p></td>
<td><p>The Runtime Environment module manages the information flow between <br> Software Components (SWCs), BSW and CDDs.</p></td>
<td><p>In this use case, it is used to schedule the periodic task defined in OS.</p></td>
</tr>
<tr class="row-odd"><td><p>6</p></td>
<td><p>Com</p></td>
<td><p>Com is responsible to provide a signal-based <br> interface to the upper layer. It handles signal <br> conversion, transmission and reception.</p></td>
<td><p>In this use case, Com module handles packing of AUTOSAR signals to I-Pdus to be transmitted <br> and unpacking of received I-Pdus.</p></td>
</tr>
<tr class="row-even"><td><p>7</p></td>
<td><p>ComM</p></td>
<td><p>The Communication Manager is a resource manager, which encapsulates the control of the underlying <br> communication services. It controls more than one communication bus channel of an ECU by implementing a channel state machine for every <br> channel.</p></td>
<td><p>In this use case, ComM provides a mechanism for users to request communication modes, coordinating requests from multiple <br> independent users.</p></td>
</tr>
<tr class="row-odd"><td><p>8</p></td>
<td><p>EcuM</p></td>
<td><p>EcuM is responsible for initialization of BSW (Basic Software) modules that are needed to start <br> the operating system and preparation of the microcontroller for a sleep phase and the following wake up</p></td>
<td><p>In this use case, EcuM is used <br> to wake up the LIN channel by configuring the EcuM wakeup sources</p></td>
</tr>
<tr class="row-even"><td><p>9</p></td>
<td><p>PduR</p></td>
<td><p>PduR routes protocol data units between communication modules and ensures that the correct Pdus <br> are transmitted to the appropriate destination.</p></td>
<td><p>In this use case, PduR module handles the routing of Pdus to and from Com layer and <br> LIN driver.</p></td>
</tr>
<tr class="row-odd"><td><p>10</p></td>
<td><p>DET</p></td>
<td><p>The DET is used in order to report development errors. The DET can be replaced optionally by an equivalent component which is responsible for recognizing development errors, if no DET component is available.</p></td>
<td><p>In this use Case, Development error is enabled to detect all development errors.</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For detailed information on each module and its features, please refer to the Technical Reference Manual provided by Vector.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For importing MCAL configuration files to DaVinci refer <a class="reference internal" href="#importing-ti-mcal-modules-from-eb-tresos-to-vector-davinci-configurator"><span class="std std-ref">Importing TI MCAL modules from EB Tresos to Vector DaVinci Configurator</span></a>.</p>
</div>
</section>
</section>
<section id="configuration-of-modules-in-lin-integration">
<h4><span class="section-number">7.2.7.3. </span>Configuration of modules in LIN Integration<a class="headerlink" href="#configuration-of-modules-in-lin-integration" title="Link to this heading"></a></h4>
<p>This chapter explains the basic configurations that are needed to realize LIN communication.</p>
<section id="lin-configuration">
<h5><span class="section-number">7.2.7.3.1. </span>Lin Configuration<a class="headerlink" href="#lin-configuration" title="Link to this heading"></a></h5>
<p><strong>LinGeneral:</strong></p>
<p>The LinGeneral container is responsible for configuring the global settings of the LIN protocol in the system.</p>
<p>Follow the configuration of Lin General settings as shown below -</p>
<figure class="align-center" id="id87">
<img alt="Lin General configuration" src="../_images/Lin_General.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.87 </span><span class="caption-text">Lin General configuration</span><a class="headerlink" href="#id87" title="Link to this image"></a></p>
</figcaption>
</figure>
<p><strong>LinChannel:</strong></p>
<p>This container holds the configuration parameters for the LIN Controller(s). It defines critical settings such as the baud rate, which is essential for enabling proper communication between the LIN bus and the application layer.</p>
<p>Select LIN1 hardware unit, with loopback mode disabled and baud rate configuration as shown below -</p>
<figure class="align-center" id="id88">
<img alt="Lin Channel Configuration" src="../_images/Lin_Ch_Config.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.88 </span><span class="caption-text">Lin Channel Configuration</span><a class="headerlink" href="#id88" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="mcu-configuration-for-lin-module">
<h5><span class="section-number">7.2.7.3.2. </span>MCU Configuration for LIN Module<a class="headerlink" href="#mcu-configuration-for-lin-module" title="Link to this heading"></a></h5>
<p>The LIN module has dependence on MCU module. Hence, we need to provide clock setting reference in MCU module. Please refer to TechnicalReference_Mcu was used to configure this module.</p>
<p>Lin clock reference point is configured as shown below -</p>
<figure class="align-center" id="id89">
<img alt="Lin Mcu Clock reference configuration" src="../_images/LinMcuClockReferenceConfiguration.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.89 </span><span class="caption-text">Lin Mcu Clock reference configuration</span><a class="headerlink" href="#id89" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="port-configuration-in-lin-module">
<h5><span class="section-number">7.2.7.3.3. </span>Port Configuration in LIN Module<a class="headerlink" href="#port-configuration-in-lin-module" title="Link to this heading"></a></h5>
<p>In the configuration of the port for the LIN module, the port pins are used to facilitate the transmission (Tx) and reception (Rx) of messages.</p>
<p>LIN1 Rx is configured on pin A9 and LIN1 Tx is configured on pin B9 as shown below -</p>
<figure class="align-center" id="id90">
<img alt="Port pin configuration for Lin" src="../_images/PortPin.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.90 </span><span class="caption-text">Port pin configuration for Lin</span><a class="headerlink" href="#id90" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>Similarly, port pin for LIN  RX can be configured.</p>
</section>
<section id="ecuc-configuration-in-lin-module">
<h5><span class="section-number">7.2.7.3.4. </span>EcuC Configuration in LIN Module<a class="headerlink" href="#ecuc-configuration-in-lin-module" title="Link to this heading"></a></h5>
<p>EcuC is a virtual module to collect ECU Configuration specific global configuration information. EcuCPduCollection container collects all the Pdus flowing through the COM Stack as shown below -</p>
<figure class="align-center" id="id91">
<img alt="EcuC Pdu Collection" src="../_images/LinEcuCPduCollection.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.91 </span><span class="caption-text">EcuC Pdu Collection</span><a class="headerlink" href="#id91" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="linif-configuration-in-lin-module">
<h5><span class="section-number">7.2.7.3.5. </span>LinIf Configuration in LIN Module<a class="headerlink" href="#linif-configuration-in-lin-module" title="Link to this heading"></a></h5>
<p>LinIf is responsible for managing the interaction between the application layer and the underlying LIN driver.</p>
<p><strong>LinIfChannels:</strong></p>
<p>LinIfChannels define the communication channels for the LIN (Local Interconnect Network) protocol.</p>
<p>The configuration of the LinIf channel is done with the startup state set to NORMAL and the wake-up confirmation timeout period configured as 2 seconds as shown below -</p>
<figure class="align-center" id="id92">
<img alt="LinIf channel configuration" src="../_images/LinIfChannelConfiguration.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.92 </span><span class="caption-text">LinIf channel configuration</span><a class="headerlink" href="#id92" title="Link to this image"></a></p>
</figcaption>
</figure>
<p><strong>LinIfFrames:</strong></p>
<p>LinIfFrames represent the actual message format used in LIN communication, specifying message IDs, data length, and content.</p>
<p>Both LINIf Tx and Rx frames are configured as Unconditional frames as shown below -</p>
<figure class="align-center" id="id93">
<img alt="LinIf Tx and Rx frame configuration" src="../_images/LinIfTxRxframe.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.93 </span><span class="caption-text">LinIf Tx and Rx frame configuration</span><a class="headerlink" href="#id93" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>The configuration of LinIf Tx Pdu frame is as shown below -</p>
<figure class="align-center" id="id94">
<img alt="LinIf Tx frame configuration" src="../_images/LinIfTxFrame.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.94 </span><span class="caption-text">LinIf Tx frame configuration</span><a class="headerlink" href="#id94" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>The configuration of LinIf Rx Pdu frame is as shown below -</p>
<figure class="align-center" id="id95">
<img alt="LinIf Rx frame configuration" src="../_images/LinIfRxFrame.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.95 </span><span class="caption-text">LinIf Rx frame configuration</span><a class="headerlink" href="#id95" title="Link to this image"></a></p>
</figcaption>
</figure>
<p><strong>LinIfScheduleTables:</strong></p>
<p>The schedule table allows for time-based control of message exchanges, ensuring that messages are sent at the correct intervals, such as periodically requesting sensor data or controlling actuators.</p>
<p>The configuration of LinIfScheduleTable for both master and slave response where both are configured with runmode as RUN_ONCE as shown below -</p>
<figure class="align-center" id="id96">
<img alt="Configuration for LinIfScheduleTables" src="../_images/LinIfScheduleTables.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.96 </span><span class="caption-text">Configuration for LinIfScheduleTables</span><a class="headerlink" href="#id96" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>The configuration of LinIfEntry is shown below -</p>
<figure class="align-center" id="id97">
<img alt="Configuration for LinIfEntry" src="../_images/LinIfEntry.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.97 </span><span class="caption-text">Configuration for LinIfEntry</span><a class="headerlink" href="#id97" title="Link to this image"></a></p>
</figcaption>
</figure>
<p><strong>LinIfNodeType:</strong></p>
<p>LinIfNodeType specifies the role of a LIN node (communication endpoint) in the network.
Master Node: Initiates communication controls the flow of data, and requests data from slave nodes.
Slave Node: Responds to requests from the master node, providing data or status information.</p>
<p>The configuration of LinIfNodeType is shown as below -</p>
<figure class="align-center" id="id98">
<img alt="configuration for LinIfNodeType" src="../_images/LinIfNodeType.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.98 </span><span class="caption-text">configuration for LinIfNodeType</span><a class="headerlink" href="#id98" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="linsm-configuration-in-lin-module">
<h5><span class="section-number">7.2.7.3.6. </span>LinSM Configuration in LIN Module<a class="headerlink" href="#linsm-configuration-in-lin-module" title="Link to this heading"></a></h5>
<p>The LinSM (LIN State Manager) is responsible for controlling the communication states of the LIN network, such as initialization, sleep, and wake-up.</p>
<p><strong>LinSMChannel:</strong></p>
<p>LinSMChannel configures the LIN State Manager channel, managing state transitions (e.g., from sleep to active) for LIN communication.</p>
<p>The configuration of LinSM channel is done as shown below by selecting appropriate node type -</p>
<figure class="align-center" id="id99">
<img alt="LinSM Channel Configuration" src="../_images/LinSMChannelConfiguration.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.99 </span><span class="caption-text">LinSM Channel Configuration</span><a class="headerlink" href="#id99" title="Link to this image"></a></p>
</figcaption>
</figure>
<p><strong>LinSMSchedule:</strong></p>
<p>LinSMSchedule defines the schedule for the LIN State Manager (LinSM), specifying the timing and sequence for state transitions (such as wake-up and communication states).</p>
<p>Two LinSM Schedules are created with different schedule index as shown below -</p>
<figure class="align-center" id="id100">
<img alt="LinSM Schedules Configuration" src="../_images/LinSMSchedulesConfiguration.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.100 </span><span class="caption-text">LinSM Schedules Configuration</span><a class="headerlink" href="#id100" title="Link to this image"></a></p>
</figcaption>
</figure>
<p><strong>LinSMGeneral:</strong></p>
<p>LinSMGeneral is used to configure general settings for the LIN State Manager (LinSM), which controls the state transitions of the LIN communication.</p>
<p>The configuration of LinSM is configured as shown below, by setting the main Processing period as 10ms -</p>
<figure class="align-center" id="id101">
<img alt="LinSM general configuration" src="../_images/LinSMGeneralConfiguration.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.101 </span><span class="caption-text">LinSM general configuration</span><a class="headerlink" href="#id101" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="ecum-configuration-in-lin-module">
<h5><span class="section-number">7.2.7.3.7. </span>EcuM Configuration in LIN Module<a class="headerlink" href="#ecum-configuration-in-lin-module" title="Link to this heading"></a></h5>
<p>The EcuM is used to wake up the LIN channel by configuring the EcuM wakeup source ID and setting the parameters that reference the LinWakeupChannel parameter.</p>
<p>Follow the configuration of EcuM with EcuM wakeup source ID as 4 and EcuM wakeup source enabled in Polling mode as shown below -</p>
<figure class="align-center" id="id102">
<img alt="Lin wakeup configuration in EcuM" src="../_images/LinWakeupEcuM.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.102 </span><span class="caption-text">Lin wakeup configuration in EcuM</span><a class="headerlink" href="#id102" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="pdur-configuration-in-lin-module">
<h5><span class="section-number">7.2.7.3.8. </span>PduR Configuration in LIN Module<a class="headerlink" href="#pdur-configuration-in-lin-module" title="Link to this heading"></a></h5>
<p>The primary function of the Pdu Router module is to abstract the bus access type (Interface layer) and the bus type itself. The Pdu Router routing tables are configured with source and destination parameters. Pdu Router configuration to send and receive LIN message to and from LIN driver and Com module, is shown below -</p>
<figure class="align-center" id="id103">
<img alt="PduR configuration" src="../_images/PduRConfiguration.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.103 </span><span class="caption-text">PduR Configuration</span><a class="headerlink" href="#id103" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="com-configuration-in-lin-module">
<h5><span class="section-number">7.2.7.3.9. </span>Com Configuration in LIN Module<a class="headerlink" href="#com-configuration-in-lin-module" title="Link to this heading"></a></h5>
<p>Com module provides the configuration for ComIpdus and ComIpdugroups. It also provides Tx and Rx main function. Below figure illustrates the com configuration</p>
<p>To configure Lin in DaVinci Configurator the following containers need to be set up.</p>
<p><strong>ComSignal:</strong></p>
<p>The ComSignal container is used to define individual signals within a communication protocol (e.g., CAN, LIN) in the system.</p>
<p>The configuration of the Com Signal for the LIN master response is done with the transfer property set to TRIGGERED and the signal access set to ACCESS_NEEDED_BY_OTHER, as shown in the figure below -</p>
<figure class="align-center" id="id104">
<img alt="Configuration for Lin Tx signal" src="../_images/ConfigurationLinTx.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.104 </span><span class="caption-text">Configuration for Lin Tx signal</span><a class="headerlink" href="#id104" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>Configuration of Lin Slave signal is done with signal access set to ACCESS_NEEDED_BY_OTHER as shown below -</p>
<figure class="align-center" id="id105">
<img alt="Configuration of Lin Rx signal" src="../_images/ConfigurationLinRx.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.105 </span><span class="caption-text">Configuration of Lin Rx signal</span><a class="headerlink" href="#id105" title="Link to this image"></a></p>
</figcaption>
</figure>
<p><strong>ComIPuds:</strong></p>
<p>The ComIPuds container simplifies the definition of data transfer mechanisms between ECUs, especially when communication involves multiple protocols or complex mappings of signals and messages.</p>
<p>Configuration of a Lin Master comIpdu is configured with Ipdu signal processing as IMMEDIATE as shown below -</p>
<figure class="align-center" id="id106">
<img alt="configuration for Lin Tx Ipdu" src="../_images/ConfigurationLinTxIpdu.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.106 </span><span class="caption-text">configuration for Lin Tx Ipdu</span><a class="headerlink" href="#id106" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>Configuration of a Lin Slave comIpdu is done with Ipdu signal processing as DEFERRED, as shown below -</p>
<figure class="align-center" id="id107">
<img alt="Configuration for Lin Rx Ipdu" src="../_images/ConfigurationLinRxIpdu.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.107 </span><span class="caption-text">Configuration for Lin Rx Ipdu</span><a class="headerlink" href="#id107" title="Link to this image"></a></p>
</figcaption>
</figure>
<p><strong>ComIPduGroup:</strong></p>
<p>The ComIPduGroup container is used to group related IPdus together, which can represent different sets of data that need to be communicated within the same context or for the same functional block.</p>
<p>The configuration of ComIPduGroup associated with the LIN Master is shown below -</p>
<figure class="align-center" id="id108">
<img alt="Configuration for Lin Tx IpduGroup" src="../_images/ConfigurationLinTxIpduGroup.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.108 </span><span class="caption-text">Configuration for Lin Tx IpduGroup</span><a class="headerlink" href="#id108" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>The configuration of ComIPduGroup associated with the LIN Slave is shown below -</p>
<figure class="align-center" id="id109">
<img alt="Configuration for Lin Rx IpduGroup" src="../_images/ConfigurationLinRxIpduGroup.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.109 </span><span class="caption-text">Configuration for Lin Rx IpduGroup</span><a class="headerlink" href="#id109" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="comm-configuration-in-lin-module">
<h5><span class="section-number">7.2.7.3.10. </span>ComM Configuration in LIN Module<a class="headerlink" href="#comm-configuration-in-lin-module" title="Link to this heading"></a></h5>
<p>The ComM module allows the system to operate in different communication modes. Lin Controller channel reference shall be given in the ComM module.</p>
<p><strong>ComMUser:</strong></p>
<p>The ComMUser configuration is used to specify user-defined settings related to Communication Management (ComM).</p>
<p>The configuration of ComMUser for LIN is shown below -</p>
<figure class="align-center" id="id110">
<img alt="Configuration for Lin RteSwComponentInstances" src="../_images/ConfigurationLinRteSwComponentInstances.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.110 </span><span class="caption-text">Configuration for Lin RteSwComponentInstances</span><a class="headerlink" href="#id110" title="Link to this image"></a></p>
</figcaption>
</figure>
<p><strong>ComMChannel:</strong></p>
<p>The ComMChannel container is responsible for configuring communication channels within the ComM (Communication Management) module.</p>
<p>The Configuration of ComMChannels for LIN is as shown below -</p>
<figure class="align-center" id="id111">
<img alt="Configuration for Lin ComM channel" src="../_images/ConfigurationLinComMChannel.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.111 </span><span class="caption-text">Configuration for Lin ComM channel</span><a class="headerlink" href="#id111" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>The configuration of ComMUserPerChannels for Lin is as shown below -</p>
<figure class="align-center" id="id112">
<img alt="Configuration for lin ComMUserPerChannels" src="../_images/ConfigurationLinComMUserPerChannels.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.112 </span><span class="caption-text">Configuration for lin ComMUserPerChannels</span><a class="headerlink" href="#id112" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="os-configuration-in-lin-module">
<h5><span class="section-number">7.2.7.3.11. </span>OS Configuration in LIN Module<a class="headerlink" href="#os-configuration-in-lin-module" title="Link to this heading"></a></h5>
<p>The OS module is responsible for task scheduling. Tasks such as 10ms and 1s are created to schedule different schedulable functions for LIN and respective BSW modules. The figure below illustrates the OS configuration -</p>
<figure class="align-center" id="id113">
<img alt="OS Configuration" src="../_images/OSConfiguration.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.113 </span><span class="caption-text">OS Configuration</span><a class="headerlink" href="#id113" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="rte-configuration-in-lin-module">
<h5><span class="section-number">7.2.7.3.12. </span>Rte Configuration in LIN Module<a class="headerlink" href="#rte-configuration-in-lin-module" title="Link to this heading"></a></h5>
<p>Runtime Environment (RTE) manages communication between the software components (SWC), assures consistency of the overall information flow between basic software (BSW). It also maps a BswSchedulableEntity onto a OsTask.</p>
<p>The scheduling of the LinIf_MainFunction is shown below -</p>
<figure class="align-center" id="id114">
<img alt="Scheduling of LinIf main function" src="../_images/SchedulingLinIfMainFunction.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.114 </span><span class="caption-text">Scheduling of LinIf main function</span><a class="headerlink" href="#id114" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>All runnable in the 10ms task are shown below -</p>
<figure class="align-center" id="id115">
<img alt="Rte all task mapped" src="../_images/LinRteAllTaskMapped.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.115 </span><span class="caption-text">Rte all task mapped</span><a class="headerlink" href="#id115" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>In the RTE (Runtime Environment), the corresponding port is created based on the configuration, and it can be used to communication between software components.</p>
<p>The port connection to software component is shown below -</p>
<figure class="align-center" id="id116">
<img alt="Port connection to software component" src="../_images/Lin_PortConnection.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.116 </span><span class="caption-text">Port connection to software component</span><a class="headerlink" href="#id116" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
</section>
</section>
<section id="cdd-ipc-integration">
<h3><span class="section-number">7.2.8. </span>CDD_IPC Integration<a class="headerlink" href="#cdd-ipc-integration" title="Link to this heading"></a></h3>
<section id="objective-for-cdd-ipc-integration">
<h4><span class="section-number">7.2.8.1. </span>Objective for CDD_IPC Integration<a class="headerlink" href="#objective-for-cdd-ipc-integration" title="Link to this heading"></a></h4>
<p>The intention of CDD_IPC Integration is to enable reliable and efficient inter-core communication by configuring the TI MCAL IPC driver in conjunction with the Vector Basic Software (BSW) modules.Further details are explained in the subsequent chapter.</p>
</section>
<section id="list-of-modules-for-cdd-ipc-integration">
<h4><span class="section-number">7.2.8.2. </span>List of Modules for CDD_IPC Integration<a class="headerlink" href="#list-of-modules-for-cdd-ipc-integration" title="Link to this heading"></a></h4>
<section id="mcal-modules-for-cdd-ipc-integration">
<h5><span class="section-number">7.2.8.2.1. </span>MCAL Modules for CDD_IPC Integration<a class="headerlink" href="#mcal-modules-for-cdd-ipc-integration" title="Link to this heading"></a></h5>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Sl.No.</p></th>
<th class="head"><p>MCAL Modules</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>Significance in use case</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>IPC</p></td>
<td><p>The IPC module initializes and manages the inter-core communication hardware of the microcontroller. It provides services to configure communication channels, send and receive messages, and handle inter-core synchronization.</p></td>
<td><p>In this use case,the module is used to enable and manage communication between master core and slave cores, ensuring reliable data exchange and synchronization.</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For detailed information, please refer to the section <a class="reference internal" href="Module_User_Guide_Cdd_Ipc.html#cdd-ipc-module"><span class="std std-ref">CDD_IPC Module</span></a>.</p>
</div>
</section>
<section id="vector-modules-for-cdd-ipc-integration">
<h5><span class="section-number">7.2.8.2.2. </span>Vector Modules for CDD_IPC Integration<a class="headerlink" href="#vector-modules-for-cdd-ipc-integration" title="Link to this heading"></a></h5>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Sl.No.</p></th>
<th class="head"><p>Vector Modules</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>Significance in use case</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>IoHwAb</p></td>
<td><p>This module provides an abstraction layer for handling hardware-related input/output operations. It facilitates interaction with  IPC hardware resources for data exchange between processor cores.</p></td>
<td><p>In this use case,it abstracts the IPC driver and facilitates interaction between the application layer and the underlying inter-core communication mechanism.</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>OS</p></td>
<td><p>The Operating System is mainly responsible for handling tasks.</p></td>
<td><p>In this use case, it is used to initialize,manage tasks and interrupts related to inter-core communication,</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>RTE</p></td>
<td><p>The Runtime Environment module manages the information flow</p></td>
<td><p>In this use case, it is used to schedule the periodic task defined in OS.</p></td>
</tr>
<tr class="row-odd"><td><p>4</p></td>
<td><p>DET</p></td>
<td><p>The DET is used in order to report development errors. The DET can be replaced optionally by an equivalent component which is responsible for recognizing development errors, if no DET component is available.</p></td>
<td><p>In this use Case, Development error is enabled to detect all development errors.</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For detailed information on each module and its features, please refer to the Technical Reference Manual provided by Vector.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For importing MCAL configuration files to DaVinci refer <a class="reference internal" href="#importing-ti-mcal-modules-from-eb-tresos-to-vector-davinci-configurator"><span class="std std-ref">Importing TI MCAL modules from EB Tresos to Vector DaVinci Configurator</span></a>.</p>
</div>
</section>
</section>
<section id="configuration-of-modules-in-cdd-ipc-integration">
<h4><span class="section-number">7.2.8.3. </span>Configuration of modules in CDD_IPC Integration<a class="headerlink" href="#configuration-of-modules-in-cdd-ipc-integration" title="Link to this heading"></a></h4>
<p>This chapter explains the basic configurations that are needed to realize CDD IPC functionalities.</p>
<section id="cdd-ipc-configuration">
<h5><span class="section-number">7.2.8.3.1. </span>CDD_IPC Configuration<a class="headerlink" href="#cdd-ipc-configuration" title="Link to this heading"></a></h5>
<p>The TI IPC driver is configured using the EB Tresos tool. It is then imported into the Vector DaVinci Configurator for integration with the application software. Following containers and parameters shall be configured.</p>
<p><strong>CDD_IPC General:</strong></p>
<p>The IpcGeneral container provides general configuration settings for the IPC module.</p>
<p>In IPC general settings,IpcWriteApi and IpcReadApi is enabled as shown below -</p>
<figure class="align-center" id="id117">
<img alt="Configuration of IPC general settings" src="../_images/Configuration_of_IPC_general_settings.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.117 </span><span class="caption-text">Configuration of IPC general settings</span><a class="headerlink" href="#id117" title="Link to this image"></a></p>
</figcaption>
</figure>
<p><strong>CddIpcDriver:</strong></p>
<p>This CddIpcDriver container contains the configuration parameters and sub containers of the AUTOSAR Complex device driver(CDD) module</p>
<p>In the Cdd_Ipc Driver configuration,Specifies the local core ID on which the IPC instance is running, as shown below -</p>
<figure class="align-center" id="id118">
<img alt="Configuration of IPC driver settings" src="../_images/Configuration_of_IPC_driver_settings.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.118 </span><span class="caption-text">Configuration of IPC driver settings</span><a class="headerlink" href="#id118" title="Link to this image"></a></p>
</figcaption>
</figure>
<p><strong>CddIpcRemoteCoreList:</strong></p>
<p>This CddIpcRemoteCoreList container refers to the list of core IDs that are valid for the particular platform and can participate in inter-process communication,as shown below -</p>
<figure class="align-center" id="id119">
<img alt="Configuration of Cdd IPC Remote Core List" src="../_images/Configuration_of_Cdd_Ipc_Remote_Core_List.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.119 </span><span class="caption-text">Configuration of Cdd IPC Remote Core List</span><a class="headerlink" href="#id119" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="iohwab-configuration">
<h5><span class="section-number">7.2.8.3.2. </span>IoHwAb Configuration<a class="headerlink" href="#iohwab-configuration" title="Link to this heading"></a></h5>
<p>IoHwAb is a layer in the AUTOSAR architecture that abstracts hardware-level interfaces and provides a standardized API to the upper layers.</p>
<p>To configure a Client/Server Port Interface,the container Cdd_Ipc_Notify_RegisterClient holds the configuration elements for a Client/Server template interface. This interface is instantiated by a Client/Server Port Prototype.</p>
<p>The container IoHwAbOperationArguments contains the configuration of Operation Elements, such as Cdd_Ipc_localClientId,Cdd_Ipc_notify_msgHandler and IoHwAbOperationArgument,for a Client/Server Operation. These Operation Elements will be generated as function parameters in the I/O Hardware Abstraction(IoHwAb) implementation.</p>
<p>Similarly, it is possible to enable communication between the I/O Client/Server interface and the MCAL APIs.</p>
<p>Configuration of Cdd_Ipc IoHwAbCS port interface as shown below -</p>
<figure class="align-center" id="id120">
<img alt="Configuration for Cdd_Ipc IoHwAbCSPortInterface" src="../_images/Configuration_of_Cdd_Ipc_IoHwAb_CS_Port_Interface.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.120 </span><span class="caption-text">Configuration for Cdd_Ipc IoHwAbCSPortInterface</span><a class="headerlink" href="#id120" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>The container RegisterClient is used for configuring a Client/Server Port Prototype. This container represents an instantiation of a Client/Server Port Interface.</p>
<p>Configuration of Cdd_Ipc IoHwAbCS port prototype as shown below -</p>
<figure class="align-center" id="id121">
<img alt="Configuration for Cdd_Ipc IoHwAbCSPortPrototypes" src="../_images/Configuration_of_Cdd_Ipc_IoHwAb_CS_Port_Prototype.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.121 </span><span class="caption-text">Configuration for Cdd_Ipc IoHwAbCSPortPrototypes</span><a class="headerlink" href="#id121" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>The function IoHwAb_RegisterClient_Wrapper is generated, and then the MCAL API function Cdd_Ipc_Notify_RegisterClient is called.</p>
<p>In the RTE (Runtime Environment), the corresponding port is created based on the configuration, and it can be used as a Sender-Receiver Port for communication between software components -</p>
<figure class="align-center" id="id122">
<img alt="Invoking MCAL API Cdd_Ipc RegisterClient" src="../_images/IOHWAB_Cdd_Ipc_RegisterClient.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.122 </span><span class="caption-text">Invoking MCAL API Cdd_Ipc RegisterClient</span><a class="headerlink" href="#id122" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>The port connection to software component for Ipc notify is shown below -</p>
<figure class="align-center" id="id123">
<img alt="Port connection to software component for Ipc notify" src="../_images/IpcNotify_PortConnection.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.123 </span><span class="caption-text">Port connection to software component for Ipc notify</span><a class="headerlink" href="#id123" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>The port connection to software component for Ipc rp is shown below -</p>
<figure class="align-center" id="id124">
<img alt="Port connection to software component for Ipc rp" src="../_images/IpcRp_PortConnection.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.124 </span><span class="caption-text">Port connection to software component for Ipc rp</span><a class="headerlink" href="#id124" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
</section>
</section>
<section id="wdg-integration">
<h3><span class="section-number">7.2.9. </span>WDG Integration<a class="headerlink" href="#wdg-integration" title="Link to this heading"></a></h3>
<section id="objective-for-wdg-integration">
<h4><span class="section-number">7.2.9.1. </span>Objective for WDG Integration<a class="headerlink" href="#objective-for-wdg-integration" title="Link to this heading"></a></h4>
<p>The WDG driver provides services for handling the watch dog timer on the microcontroller.</p>
</section>
<section id="list-of-modules-for-wdg-integration">
<h4><span class="section-number">7.2.9.2. </span>List of Modules for WDG Integration<a class="headerlink" href="#list-of-modules-for-wdg-integration" title="Link to this heading"></a></h4>
<section id="mcal-modules-for-wdg-integration">
<h5><span class="section-number">7.2.9.2.1. </span>MCAL Modules for WDG Integration<a class="headerlink" href="#mcal-modules-for-wdg-integration" title="Link to this heading"></a></h5>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Sl.No.</p></th>
<th class="head"><p>MCAL Modules</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>Significance in use case</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>Mcu</p></td>
<td><p>Manages microcontroller features such as power modes, clock settings, and interrupts.</p></td>
<td><p>In this use case this module is used to provide clock for WDG operation.</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>WDG</p></td>
<td><p>The WDG provides services for handling the watch dog timer on the microcontroller</p></td>
<td><p>In this use case, WDG is configured to handle the watch dog timer</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For detailed information, please refer to the section <a class="reference internal" href="Module_User_Guide_Wdg.html#wdg-module"><span class="std std-ref">WDG Module</span></a>.</p>
</div>
</section>
<section id="vector-modules-for-wdg-integration">
<h5><span class="section-number">7.2.9.2.2. </span>Vector Modules for WDG Integration<a class="headerlink" href="#vector-modules-for-wdg-integration" title="Link to this heading"></a></h5>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Sl.No.</p></th>
<th class="head"><p>Vector Modules</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>Significance in use case</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>WDGIf</p></td>
<td><p>The main WdgIf functionality consists of linking the overlying Watchdog Manager module (WdgM) <br> to one or more underlying WDG drivers</p></td>
<td><p>In this use case, WdgIf ensures operation between application <br> software and the WDG driver.</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>WDGM</p></td>
<td><p>The Watchdog Manager (WdgM) is responsible for supervising the software components and ensuring <br> system health by monitoring the execution flow of supervised entities.</p></td>
<td><p>In this use case, WDGM supervises the software components and ensures system health.</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>OS (MICROSAR Operating System)</p></td>
<td><p>The Operating System is mainly responsible for handling of tasks and interrupts.</p></td>
<td><p>In this use case, it used to define a periodic task.</p></td>
</tr>
<tr class="row-odd"><td><p>4</p></td>
<td><p>RTE (MICROSAR Runtime Environment)</p></td>
<td><p>The Runtime Environment module manages the information flow between <br> Software Components (SWCs), BSW and CDDs.</p></td>
<td><p>In this use case, it is used to schedule the periodic task defined in OS.</p></td>
</tr>
<tr class="row-even"><td><p>5</p></td>
<td><p>DET</p></td>
<td><p>The DET is used in order to report development errors. The DET can be replaced optionally by an equivalent component which is responsible for recognizing development errors, if no DET component is available.</p></td>
<td><p>In this use Case, Development error is enabled to detect all development errors.</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For detailed information on each module and its features, please refer to the Technical Reference Manual provided by Vector.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For importing MCAL configuration files to DaVinci refer <a class="reference internal" href="#importing-ti-mcal-modules-from-eb-tresos-to-vector-davinci-configurator"><span class="std std-ref">Importing TI MCAL modules from EB Tresos to Vector DaVinci Configurator</span></a>.</p>
</div>
</section>
</section>
<section id="configuration-modules-in-wdg-integration">
<h4><span class="section-number">7.2.9.3. </span>Configuration modules in WDG Integration<a class="headerlink" href="#configuration-modules-in-wdg-integration" title="Link to this heading"></a></h4>
<p>This chapter explains the basic configurations that are needed to realize WDG functionalities.</p>
<section id="wdg-configuration">
<h5><span class="section-number">7.2.9.3.1. </span>Wdg Configuration<a class="headerlink" href="#wdg-configuration" title="Link to this heading"></a></h5>
<p>As part of WDG module integration, WDG module from TI MCAL stack shall be interconnected with vector modules. For that WDG along with its dependent WDG modules shall be configured and provide the reference to WdgIf module. As a first step following Containers and parameters shall be configured in WDG module.</p>
<p><strong>WdgGeneral:</strong>
The WDGGeneral container is responsible for configuring the global settings of the WDG in the system. It ensures that the WDG operation module is properly set up for tasks such as WDG window size, WDG default mode.</p>
<p>WDG is configured with 100 percent window size as shown below -</p>
<figure class="align-center" id="id125">
<img alt="WDG General setting" src="../_images/WdgGeneral.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.125 </span><span class="caption-text">WDG General setting</span><a class="headerlink" href="#id125" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>The default mode of WDG is selected as WDGIF_SLOW_MODE and WDG reaction is set to WDG_GENERATE_RESET as shown below -</p>
<figure class="align-center" id="id126">
<img alt="Wdg General configuration" src="../_images/WdgGeneralconfiguration.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.126 </span><span class="caption-text">Wdg General configuration</span><a class="headerlink" href="#id126" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="mcu-configuration-for-wdg-integration">
<h5><span class="section-number">7.2.9.3.2. </span>MCU Configuration for WDG Integration<a class="headerlink" href="#mcu-configuration-for-wdg-integration" title="Link to this heading"></a></h5>
<p>The Wdg module has dependence on MCU module. Hence, we need to provide clock setting reference in MCU module. Please refer to TechnicalReference_Mcu was used to configure this module.</p>
<p>The MCU clock configuration for WDG driver is shown below -</p>
<figure class="align-center" id="id127">
<img alt="Wdg Mcu Clock reference configuration" src="../_images/MCUClockWdg.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.127 </span><span class="caption-text">Wdg Mcu Clock reference configuration</span><a class="headerlink" href="#id127" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="wdgif-configuration-for-wdg-integration">
<h5><span class="section-number">7.2.9.3.3. </span>WdgIf Configuration for WDG Integration<a class="headerlink" href="#wdgif-configuration-for-wdg-integration" title="Link to this heading"></a></h5>
<p>WdgIF is responsible for managing the interaction between the application layer and the underlying WDG driver. To configure WdgIF, the following containers and parameters need to be set up.</p>
<p><strong>WdgIfDevices:</strong></p>
<p>WDGIF is configured for WDG usecase realisation. We need to provide WDG driver reference as shown below -</p>
<figure class="align-center" id="id128">
<img alt="WdgIf Devices configuration" src="../_images/WdgIfDevicesconfiguration.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.128 </span><span class="caption-text">WdgIf Devices configuration</span><a class="headerlink" href="#id128" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="wdgm-configuration-for-wdg-integration">
<h5><span class="section-number">7.2.9.3.4. </span>WdgM Configuration for WDG Integration<a class="headerlink" href="#wdgm-configuration-for-wdg-integration" title="Link to this heading"></a></h5>
<p>The WdgM monitors safety-relevant applications on the ECU. When the WdgM detects a violation of the preconfigured temporal or logical constraints in the program flow, it takes several configurable actions to log the fault and to go to a safe state after a configurable time delay.</p>
<p>Two WDG check points are created for entry and exit as shown below -</p>
<figure class="align-center" id="id129">
<img alt="WDG checkpoint creation" src="../_images/Watchdogcheckpointcreation.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.129 </span><span class="caption-text">WDG checkpoint creation</span><a class="headerlink" href="#id129" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>WDG deadline supervision is configured with maximum deadline of 5000 ms and minimum deadline of 10 ms, and the entry and exit references are given as shown below -</p>
<figure class="align-center" id="id130">
<img alt="WDG Deadline supervision configuration" src="../_images/WatchdogDeadlinesupervisionconfiguration.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.130 </span><span class="caption-text">WDG Deadline supervision configuration</span><a class="headerlink" href="#id130" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>Two different triggers are configured with different WDG modes. One trigger is configured with slow mode, while another with fast mode as shown below -</p>
<figure class="align-center" id="id131">
<img alt="WDG triggers" src="../_images/WatchDogTriggers.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.131 </span><span class="caption-text">WDG triggers</span><a class="headerlink" href="#id131" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="os-configuration-for-wdg-integration">
<h5><span class="section-number">7.2.9.3.5. </span>OS Configuration for WDG Integration<a class="headerlink" href="#os-configuration-for-wdg-integration" title="Link to this heading"></a></h5>
<p>The OS module is responsible for task scheduling. Tasks such as 10ms and 1s are created to schedule different schedulable functions for WDG  and respective BSW modules.</p>
<p>The OS configuration is shown below -</p>
<figure class="align-center" id="id132">
<img alt="OS Configuration" src="../_images/WatchDogOSConfiguration.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.132 </span><span class="caption-text">OS Configuration</span><a class="headerlink" href="#id132" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="rte-configuration-for-wdg-integration">
<h5><span class="section-number">7.2.9.3.6. </span>Rte Configuration for WDG Integration<a class="headerlink" href="#rte-configuration-for-wdg-integration" title="Link to this heading"></a></h5>
<p>Runtime Environment (RTE) manages communication between the software components (SWC), assures consistency of the overall information flow between basic software (BSW). It also maps a BswSchedulableEntity onto one OsTask.</p>
<p>The scheduling of the WdgM_MainFunction is shown below -</p>
<figure class="align-center" id="id133">
<img alt="Scheduling of periodic function - WdgM_MainFunction" src="../_images/SchedulingWdgM_MainFunction.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.133 </span><span class="caption-text">Scheduling of periodic function - WdgM_MainFunction</span><a class="headerlink" href="#id133" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
</section>
</section>
<section id="dio-integration">
<h3><span class="section-number">7.2.10. </span>DIO Integration<a class="headerlink" href="#dio-integration" title="Link to this heading"></a></h3>
<section id="objective-for-dio-integration">
<h4><span class="section-number">7.2.10.1. </span>Objective for DIO Integration<a class="headerlink" href="#objective-for-dio-integration" title="Link to this heading"></a></h4>
<p>The intention of DIO integration is to verify DIO functionality by configuring the DIO MCAL and dependent Vector modules. It will facilitate switching of digital signals, representing ON/OFF or HIGH/LOW states, which will be explained in the subsequent chapter.</p>
</section>
<section id="list-of-modules-for-dio-integration">
<h4><span class="section-number">7.2.10.2. </span>List of Modules for DIO Integration<a class="headerlink" href="#list-of-modules-for-dio-integration" title="Link to this heading"></a></h4>
<section id="mcal-modules-for-dio">
<h5><span class="section-number">7.2.10.2.1. </span>MCAL Modules for DIO<a class="headerlink" href="#mcal-modules-for-dio" title="Link to this heading"></a></h5>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Sl.No.</p></th>
<th class="head"><p>MCAL Modules</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>Significance in use case</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>Mcu</p></td>
<td><p>The MCU module manages microcontroller features such as power modes, clock settings, and interrupts.</p></td>
<td><p>In this use case, this module is responsible for providing the clock for ADC communication.</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>DIO</p></td>
<td><p>The DIO driver provides port and channel based read and write access to the internal general purpose I/O ports. The read and write behaviour is unbuffered. The basic behaviour of this driver is synchronous.</p></td>
<td><p>In this use case, this module is responsible for providing read input from software and send output to controller.</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>Port</p></td>
<td><p>The PORT module provides an interface to configure and control microcontroller pins (e.g., GPIO, ADC, PWM).</p></td>
<td><p>In this use case, this module is responsible for configuring the hardware pins necessary for DIO output.</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For detailed information, please refer to the section <a class="reference internal" href="Module_User_Guide_Dio.html#dio-module"><span class="std std-ref">DIO Module</span></a>.</p>
</div>
</section>
<section id="vector-modules-for-dio">
<h5><span class="section-number">7.2.10.2.2. </span>Vector Modules for DIO<a class="headerlink" href="#vector-modules-for-dio" title="Link to this heading"></a></h5>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Sl.No.</p></th>
<th class="head"><p>Vector Modules</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>Significance in use case</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>IoHwAb</p></td>
<td><p>The IoHwAb module provides a layer between the ECU software and the hardware. It allows higher-level software to access I/O hardware (like ADCs or DIOs) in a standardized way.</p></td>
<td><p>In this use case, IoHwab layer provides wrapper function for each of the underlying ADC API’s, so that the application is independent on the hardware.</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>OS (MICROSAR Operating System)</p></td>
<td><p>The Operating System is mainly responsible for handling tasks and interruptions.</p></td>
<td><p>In this use case, OS module is used to define periodic tasks needed for ADC communication such as processing transmit and receive message.</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>RTE (MICROSAR Runtime Environment)</p></td>
<td><p>The Runtime Environment module manages the information flow between Software Components (SWCs), BSW and CDDs.</p></td>
<td><p>In this use case, Rte module is used to schedule the periodic tasks defined in the operating system (OS) and sender receiver ports created for sending receiving can messages from application.</p></td>
</tr>
<tr class="row-odd"><td><p>5</p></td>
<td><p>DET</p></td>
<td><p>The DET is used in order to report development errors. The DET can be replaced optionally by an equivalent component which is responsible for recognizing development errors, if no DET component is available.</p></td>
<td><p>In this use Case, Development error is enabled to detect all development errors.</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For detailed information on each module and its features, please refer to the Technical Reference Manual provided by Vector.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For importing MCAL configuration files to DaVinci refer <a class="reference internal" href="#importing-ti-mcal-modules-from-eb-tresos-to-vector-davinci-configurator"><span class="std std-ref">Importing TI MCAL modules from EB Tresos to Vector DaVinci Configurator</span></a>.</p>
</div>
</section>
</section>
<section id="configuration-of-modules-in-dio-integration">
<h4><span class="section-number">7.2.10.3. </span>Configuration of modules in DIO integration<a class="headerlink" href="#configuration-of-modules-in-dio-integration" title="Link to this heading"></a></h4>
<p>This chapter explains the basic configurations that are needed to realize DIO functionality.</p>
<section id="dio-configuration">
<h5><span class="section-number">7.2.10.3.1. </span>DIO Configuration<a class="headerlink" href="#dio-configuration" title="Link to this heading"></a></h5>
<p>TI DIO driver is configured using EB Tresos tool. It is then imported to Vector DaVinci configurator for integration with upper layers like IoHwAb. Following containers and parameters shall be configured.</p>
<p><strong>DioGeneral:</strong></p>
<p>The DioGeneral contains the enabling and disabling of apis. The following figure shows the enabling DioFlipChannel api -</p>
<figure class="align-center" id="id134">
<img alt="configuration for DioGeneral" src="../_images/Dio_General.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.134 </span><span class="caption-text">configuration for DioGeneral</span><a class="headerlink" href="#id134" title="Link to this image"></a></p>
</figcaption>
</figure>
<p><strong>DioPort:</strong></p>
<p>The DioPort container is used to configure groups of DIO channels (GPIO pins) under a logical port. Each port (e.g., GPIOAB, GPIOCD) is assigned a unique DioPortId for identification. This setup enables efficient handling of multiple pins together using AUTOSAR DIO APIs. The example shows five ports with IDs from 0 to 4 -</p>
<figure class="align-center" id="id135">
<img alt="configuration for DioPort" src="../_images/Dio_port.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.135 </span><span class="caption-text">configuration for DioPort</span><a class="headerlink" href="#id135" title="Link to this image"></a></p>
</figcaption>
</figure>
<p><strong>DioChannel:</strong></p>
<p>The DioChannel container in the EB Tresos tool is used to configure individual DIO (Digital Input/Output) channels within a specified DIO port. In this example, the port being configured is named GPIOAB.
Under the DioChannel tab, each row represents a single DIO channel configuration. Each DIO channel is assigned a unique DioChannelId which acts as an identifier used in the application code for referencing the channel -</p>
<figure class="align-center" id="id136">
<img alt="Configuration for DioChannel" src="../_images/Dio_channel.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.136 </span><span class="caption-text">Configuration for DioChannel</span><a class="headerlink" href="#id136" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>The port pin 128 in DIO channel is configured as shown below -</p>
<figure class="align-center" id="id137">
<img alt="Configuration for Port pin 128" src="../_images/Dio_channel_port_pin.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.137 </span><span class="caption-text">Configuration for Port pin 128</span><a class="headerlink" href="#id137" title="Link to this image"></a></p>
</figcaption>
</figure>
<p><strong>DioChannelGroup:</strong></p>
<p>The DioChannelGroup contains the configuration of DIO port mask and port offset value. The DioChannelGroup configuration is shown below -</p>
<figure class="align-center" id="id138">
<img alt="configuration for DioChannelGroup" src="../_images/Dio_ChannelGroup.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.138 </span><span class="caption-text">configuration for DioChannelGroup</span><a class="headerlink" href="#id138" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="port-configuration-for-dio-integration">
<h5><span class="section-number">7.2.10.3.2. </span>Port Configuration for DIO Integration<a class="headerlink" href="#port-configuration-for-dio-integration" title="Link to this heading"></a></h5>
<p>The port pin configuration of DIO channel is shown below -</p>
<figure class="align-center" id="id139">
<img alt="Configuration for Portpin" src="../_images/Port_DIo.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.139 </span><span class="caption-text">Configuration for Portpin</span><a class="headerlink" href="#id139" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>The PortPinMode configuration of DIO channel is shown below -</p>
<figure class="align-center" id="id140">
<img alt="Configuration for PortpinMode" src="../_images/Dio_PortPinMode.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.140 </span><span class="caption-text">Configuration for PortpinMode</span><a class="headerlink" href="#id140" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="iohwab-configuration-for-dio-integration">
<h5><span class="section-number">7.2.10.3.3. </span>IoHwAb Configuration for DIO Integration<a class="headerlink" href="#iohwab-configuration-for-dio-integration" title="Link to this heading"></a></h5>
<p>The configuration process for determining the IoHwAb_DioFlipChannel API in the IoHwAbCSPortInterfaces container is shown below -</p>
<figure class="align-center" id="id141">
<img alt="Configuration for DIO IoHwAbCSPortInterface" src="../_images/Dio_FlipChannelIoHwAb.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.141 </span><span class="caption-text">Configuration for DIO IoHwAbCSPortInterface</span><a class="headerlink" href="#id141" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>The configuration process for determining IoHwAbDioFlipChannel API in the IoHwAbCSPortPrototypes container is shown below -</p>
<figure class="align-center" id="id142">
<img alt="Configuration for DIO IoHwAbCSPortPrototypes" src="../_images/Dio_FlipChannelIoHwAb1.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.142 </span><span class="caption-text">Configuration for DIO IoHwAbCSPortPrototypes</span><a class="headerlink" href="#id142" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>The function call interaction between the IoHwAb module and the Mcal module API is shown below -</p>
<figure class="align-center" id="id143">
<img alt="Function call between IoHwAb and DIO" src="../_images/Dio_FlipChannelIoHwAb2.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.143 </span><span class="caption-text">Function call between IoHwAb and DIO</span><a class="headerlink" href="#id143" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="os-configuration-for-dio-integration">
<h5><span class="section-number">7.2.10.3.4. </span>Os Configuration for DIO Integration<a class="headerlink" href="#os-configuration-for-dio-integration" title="Link to this heading"></a></h5>
<p>The OS module is responsible for task scheduling. Tasks such as 10ms are created to schedule TestApp_DioRunnable. The following figure is shown below -</p>
<figure class="align-center" id="id144">
<img alt="OsAlarms configuration for DIO" src="../_images/Dio_os.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.144 </span><span class="caption-text">OsAlarms configuration for DIO</span><a class="headerlink" href="#id144" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="rte-configuration-for-dio-integration">
<h5><span class="section-number">7.2.10.3.5. </span>Rte Configuration for DIO Integration<a class="headerlink" href="#rte-configuration-for-dio-integration" title="Link to this heading"></a></h5>
<p>TestApp_DioRunnable is mapped to a 10ms task and will be called periodically every 10ms by the OS task to execute the runnable.The following figure is shown below -</p>
<figure class="align-center" id="id145">
<img alt="creating 10ms task for DIO runnable" src="../_images/Dio_Rte.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.145 </span><span class="caption-text">creating 10ms task for DIO runnable</span><a class="headerlink" href="#id145" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
</section>
</section>
<section id="cdd-i2c-integration">
<h3><span class="section-number">7.2.11. </span>CDD_I2C Integration<a class="headerlink" href="#cdd-i2c-integration" title="Link to this heading"></a></h3>
<section id="objective-for-cdd-i2c-integration">
<h4><span class="section-number">7.2.11.1. </span>Objective for CDD_I2C Integration<a class="headerlink" href="#objective-for-cdd-i2c-integration" title="Link to this heading"></a></h4>
<p>The intention of I2C Integration is to enable successful I2C communication by configuring TI MCAL modules along with Vector BSW Modules. Further details are explained in the subsequent chapter.</p>
</section>
<section id="list-of-modules-for-cdd-i2c-integration">
<h4><span class="section-number">7.2.11.2. </span>List of Modules for CDD_I2C Integration<a class="headerlink" href="#list-of-modules-for-cdd-i2c-integration" title="Link to this heading"></a></h4>
<section id="mcal-modules-for-cdd-i2c-integration">
<h5><span class="section-number">7.2.11.2.1. </span>MCAL Modules for CDD_I2C Integration<a class="headerlink" href="#mcal-modules-for-cdd-i2c-integration" title="Link to this heading"></a></h5>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Sl.No.</p></th>
<th class="head"><p>MCAL Modules</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>Significance in use case</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>I2C</p></td>
<td><p>I2C (Inter-Integrated Circuit) is a two-wire serial communication protocol using SDA (data) and SCL (clock) lines. It allows a master to communicate with one or more slave devices using unique addresses. I2C is commonly used for connecting low-speed peripherals like sensors, EEPROMs, and displays in embedded systems.</p></td>
<td><p>In this use case, this module is responsible for configure I2C channel list and Sequence.</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>Mcu</p></td>
<td><p>Manages microcontroller features such as power modes, clock settings, and interrupts.</p></td>
<td><p>In this use case this module is used to provide clock for I2C operation.</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>Port</p></td>
<td><p>Provides an interface to configure and control microcontroller pins (e.g., GPIO, ADC, PWM).</p></td>
<td><p>In this use case, this module is responsible for configuring the hardware pins necessary for I2C communication.</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For detailed information, please refer to the section <a class="reference internal" href="Module_User_Guide_Cdd_I2c.html#cdd-i2c-module"><span class="std std-ref">CDD_I2C Module</span></a>.</p>
</div>
</section>
<section id="vector-modules-for-cdd-i2c-integration">
<h5><span class="section-number">7.2.11.2.2. </span>Vector Modules for CDD_I2C Integration<a class="headerlink" href="#vector-modules-for-cdd-i2c-integration" title="Link to this heading"></a></h5>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Sl.No.</p></th>
<th class="head"><p>Vector Modules</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>Significance in use case</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>IoHwAb</p></td>
<td><p>This module provides an abstraction layer for handling hardware-related input/output operations.<br> It facilitates interaction with  IPC hardware resources for data exchange between processor cores.</p></td>
<td><p>In this use case,it abstracts the IPC driver and facilitates interaction ,<br> between the application layer and the underlying inter-core communication mechanism.</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>DET</p></td>
<td><p>The DET is used in order to report development errors. The DET can be replaced optionally by an equivalent component which is responsible for recognizing development errors, if no DET component is available.</p></td>
<td><p>In this use Case, Development error is enabled to detect all development errors.</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>RTE (MICROSAR Runtime Environment)</p></td>
<td><p>The Runtime Environment module manages the information flow between Software Components (SWCs), BSW and CDDs.</p></td>
<td><p>In this use case, Rte module is used to schedule the periodic tasks defined in the operating system (OS) and sender receiver ports created for sending receiving can messages from application.</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For detailed information on each module and its features, please refer to the Technical Reference Manual provided by Vector.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For importing MCAL configuration files to DaVinci refer <a class="reference internal" href="#importing-ti-mcal-modules-from-eb-tresos-to-vector-davinci-configurator"><span class="std std-ref">Importing TI MCAL modules from EB Tresos to Vector DaVinci Configurator</span></a>.</p>
</div>
</section>
</section>
<section id="configuration-modules-in-cdd-i2c-integration">
<h4><span class="section-number">7.2.11.3. </span>Configuration modules in CDD_I2C Integration<a class="headerlink" href="#configuration-modules-in-cdd-i2c-integration" title="Link to this heading"></a></h4>
<p>This chapter explains the basic configurations that are needed to realize CDD I2C communication.</p>
<section id="cdd-i2c-configuration">
<h5><span class="section-number">7.2.11.3.1. </span>CDD_I2C Configuration<a class="headerlink" href="#cdd-i2c-configuration" title="Link to this heading"></a></h5>
<p>As part of I2C module integration, I2C module from TI MCAL stack shall be interconnected with vector modules. For that I2C along with its dependent I2C modules shall be configured and provide the reference to other module. As a first step following Containers and parameters shall be configured in I2C module.</p>
<p><strong>I2cGeneral:</strong></p>
<p>General configuration settings for Complex Device Drivers are defined in the container, which includes options to enable or disable API and IRQ types, as shown below -</p>
<figure class="align-center" id="id146">
<img alt="Configuration for CddI2cGeneral" src="../_images/I2c_General.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.146 </span><span class="caption-text">Configuration for CddI2cGeneral</span><a class="headerlink" href="#id146" title="Link to this image"></a></p>
</figcaption>
</figure>
<p><strong>CddI2cHwConfig:</strong></p>
<p>This container contains the HW unit initialization parameters. The HwUnitType and ChannelBitRate, HwUnitFrequency and ClkInputSrc are shown below -</p>
<figure class="align-center" id="id147">
<img alt="Configuration for CddI2cHwConfig" src="../_images/I2cHwConfig.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.147 </span><span class="caption-text">Configuration for CddI2cHwConfig</span><a class="headerlink" href="#id147" title="Link to this image"></a></p>
</figcaption>
</figure>
<p><strong>CddI2cChannelConfig:</strong></p>
<p>This container includes the channel configurations. The I2C channel direction, ChannelSlaveAddress, and SlaveAddressScheme are shown below -</p>
<figure class="align-center" id="id148">
<img alt="Configuration for CddI2cChannelConfig" src="../_images/I2cChannelConfig.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.148 </span><span class="caption-text">Configuration for CddI2cChannelConfig</span><a class="headerlink" href="#id148" title="Link to this image"></a></p>
</figcaption>
</figure>
<p><strong>CddI2cSequenceConfig:</strong></p>
<p>This container contains the Sequence configurations. The I2C Channel SequenceHwUnitType, NumberOfChannelsInSequence and SequenceCompleteNotify and SequenceErrorNotify are shown below -</p>
<figure class="align-center" id="id149">
<img alt="Configuration for CddI2cSequenceConfig" src="../_images/I2cSequenceConfig.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.149 </span><span class="caption-text">Configuration for CddI2cSequenceConfig</span><a class="headerlink" href="#id149" title="Link to this image"></a></p>
</figcaption>
</figure>
<p><strong>I2cChannelList:</strong></p>
<p>References to I2C channels and their order within the Sequence shown below -</p>
<figure class="align-center" id="id150">
<img alt="Configuration for I2cChannelList" src="../_images/I2cChannelList.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.150 </span><span class="caption-text">Configuration for I2cChannelList</span><a class="headerlink" href="#id150" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="mcu-configuration-for-cdd-i2c-integration">
<h5><span class="section-number">7.2.11.3.2. </span>MCU Configuration for CDD_I2C Integration<a class="headerlink" href="#mcu-configuration-for-cdd-i2c-integration" title="Link to this heading"></a></h5>
<p>The I2C module has dependence on MCU module. Hence, we need to provide clock setting reference in MCU module. Please refer to TechnicalReference_Mcu was used to configure this module.
The following figure illustrates the configuration process for determining I2C clock reference point configuration -</p>
<figure class="align-center" id="id151">
<img alt="Configuration for McuClockSettingConfig_I2C" src="../_images/I2cMcuClockReference.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.151 </span><span class="caption-text">Configuration for McuClockSettingConfig_I2C</span><a class="headerlink" href="#id151" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="port-configuration-for-cdd-i2c-integration">
<h5><span class="section-number">7.2.11.3.3. </span>Port Configuration for CDD_I2C Integration<a class="headerlink" href="#port-configuration-for-cdd-i2c-integration" title="Link to this heading"></a></h5>
<p>In the configuration of the port for the I2C module, the port pins are used to facilitate the I2C data line as shown below -</p>
<figure class="align-center" id="id152">
<img alt="Configuration for I2C Port pin" src="../_images/I2c_PortPin.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.152 </span><span class="caption-text">Configuration for I2C Port pin</span><a class="headerlink" href="#id152" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>Similarly, port pin for I2C clock line can be configured.</p>
</section>
<section id="iohwab-configuration-for-cdd-i2c-integration">
<h5><span class="section-number">7.2.11.3.4. </span>IoHwAb Configuration for CDD_I2C Integration<a class="headerlink" href="#iohwab-configuration-for-cdd-i2c-integration" title="Link to this heading"></a></h5>
<p>IoHwAb is a layer in the AUTOSAR architecture that abstracts hardware-level interfaces and provides a standardized API to the upper layers.
To configure a Client/Server Port Interface, the container Cdd_I2c_AsyncTransmit holds the configuration elements for a Client/Server template interface. This interface is instantiated by a Client/Server Port Prototype.
The container IoHwAbOperationArguments contains the configuration of Operation Elements, such as Cdd_I2c_SetupEB, and IoHwAbOperationArgument, for a Client/Server Operation. These Operation Elements will be generated as function parameters in the I/O Hardware Abstraction (IoHwAb) implementation.
Similarly, it is possible to enable communication between the I/O Client/Server interface and the MCAL APIs.
Configuration of Cdd_I2c IoHwAbCS port interface as shown below -</p>
<figure class="align-center" id="id153">
<img alt="Configuration for Cdd_I2C IoHwAbCSPortInterface" src="../_images/IoHwAb_I2c.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.153 </span><span class="caption-text">Configuration for Cdd_I2C IoHwAbCSPortInterface</span><a class="headerlink" href="#id153" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>The container AsyncTransmit is used for configuring a Client/Server Port Prototype. This container represents an instantiation of a Client/Server Port Interface.
Configuration of Cdd_I2c IoHwAbCS port prototype as shown below -</p>
<figure class="align-center" id="id154">
<img alt="Configuration for Cdd_I2C IoHwAbCSPortPrototypes" src="../_images/IoHwAb_I2c1.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.154 </span><span class="caption-text">Configuration for Cdd_I2C IoHwAbCSPortPrototypes</span><a class="headerlink" href="#id154" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>The function IoHwAb_Construct_Wrapper is generated, and then the MCAL API function Cdd_I2c_AsyncTransmit is called. In the RTE (Runtime Environment), the corresponding port is created based on the configuration, and it can be used as a Sender-Receiver Port for communication between software components -</p>
<figure class="align-center" id="id155">
<img alt="Invoking MCAL API Cdd_I2c_AsyncTransmit" src="../_images/IoHwab_to_I2c_Connection.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.155 </span><span class="caption-text">Invoking MCAL API Cdd_I2c_AsyncTransmit</span><a class="headerlink" href="#id155" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>The port connection to software component for I2C is shown below -</p>
<figure class="align-center" id="id156">
<img alt="Port connection to software component for CDD_I2C" src="../_images/I2c_portconnection.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.156 </span><span class="caption-text">Port connection to software component for CDD_I2C</span><a class="headerlink" href="#id156" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
</section>
</section>
<section id="icu-integration">
<h3><span class="section-number">7.2.12. </span>ICU Integration<a class="headerlink" href="#icu-integration" title="Link to this heading"></a></h3>
<section id="objective-for-icu-integration">
<h4><span class="section-number">7.2.12.1. </span>Objective for ICU Integration<a class="headerlink" href="#objective-for-icu-integration" title="Link to this heading"></a></h4>
<p>The objective of ICU integration is to achieve accurate duty cycle measurement of the PWM signal by configuring TI MCAL modules in coordination with Vector BSW modules. Further implementation details are provided in the subsequent chapter.</p>
</section>
<section id="list-of-modules-for-icu">
<h4><span class="section-number">7.2.12.2. </span>List Of Modules for ICU<a class="headerlink" href="#list-of-modules-for-icu" title="Link to this heading"></a></h4>
<section id="mcal-modules-for-icu-integration">
<h5><span class="section-number">7.2.12.2.1. </span>MCAL Modules for ICU Integration<a class="headerlink" href="#mcal-modules-for-icu-integration" title="Link to this heading"></a></h5>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Sl. No.</p></th>
<th class="head"><p>MCAL Modules</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>Significance in use case</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>Mcu</p></td>
<td><p>The MCU module manages microcontroller features for PWM, such as power modes and clock settings.</p></td>
<td><p>In this use case, this module is responsible for providing the clock for PWM signal generation.</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>Port</p></td>
<td><p>The PORT module provides an interface to configure and control microcontroller pins (e.g., GPIO, ADC, PWM).</p></td>
<td><p>In this use case, this module is responsible for configuring the hardware pins necessary for ICU signal capturing.</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>ICU</p></td>
<td><p>The Input Capture Unit (ICU) is a peripheral used to detect and timestamp signal edges (rising/falling) on an input pin. It enables measurement of signal characteristics such as frequency, period, and duty cycle, commonly used for PWM analysis.</p></td>
<td><p>In this use case, the ICU is used to measure the duty cycle and period of a signal.</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For detailed information, please refer to the section <a class="reference internal" href="Module_User_Guide_Icu.html#icu-module"><span class="std std-ref">ICU Module</span></a>.</p>
</div>
</section>
<section id="vector-modules-for-icu-integration">
<h5><span class="section-number">7.2.12.2.2. </span>Vector Modules for ICU Integration<a class="headerlink" href="#vector-modules-for-icu-integration" title="Link to this heading"></a></h5>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Sl. No.</p></th>
<th class="head"><p>Vector Modules</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>Significance in use case</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>IoHwAb</p></td>
<td><p>The aim of the IoHwAb is to provide ECU hardware-independent data transition from driver modules up to the Software Components.</p></td>
<td><p>It provides an abstraction for the ICU driver and enables communication with the application layer.</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>DET</p></td>
<td><p>The DET is used in order to report development errors. The DET can be replaced optionally by an equivalent component which is responsible for recognizing development errors, if no DET component is available.</p></td>
<td><p>In this use Case, Development error is enabled to detect all development errors.</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>RTE (MICROSAR Runtime Environment)</p></td>
<td><p>The Runtime Environment module manages the information flow between Software Components (SWCs), BSW and CDDs.</p></td>
<td><p>In this use case, Rte module is used to schedule the periodic tasks defined in the operating system (OS) and sender receiver ports created for sending receiving can messages from application.</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For detailed information on each module and its features, please refer to the Technical Reference Manual provided by Vector.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For importing MCAL configuration files to DaVinci refer <a class="reference internal" href="#importing-ti-mcal-modules-from-eb-tresos-to-vector-davinci-configurator"><span class="std std-ref">Importing TI MCAL modules from EB Tresos to Vector DaVinci Configurator</span></a>.</p>
</div>
</section>
</section>
<section id="configuration-of-modules-in-icu-integration">
<h4><span class="section-number">7.2.12.3. </span>Configuration of modules in ICU Integration<a class="headerlink" href="#configuration-of-modules-in-icu-integration" title="Link to this heading"></a></h4>
<p>This chapter explains the basic configurations that are needed to realize ICU functionalities.</p>
<section id="icu-configuration">
<h5><span class="section-number">7.2.12.3.1. </span>ICU Configuration<a class="headerlink" href="#icu-configuration" title="Link to this heading"></a></h5>
<p>The TI ICU driver is configured using the EB Tresos tool. It is then imported into the Vector DaVinci Configurator for integration with the application software. The following containers and parameters shall be configured.</p>
<p><strong>IcuGeneral:</strong></p>
<p>Configuration of general ICU parameters involves enabling or disabling the required macros, as shown below -</p>
<figure class="align-center" id="id157">
<img alt="Configuration for IcuGeneral" src="../_images/Icu_General.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.157 </span><span class="caption-text">Configuration for IcuGeneral</span><a class="headerlink" href="#id157" title="Link to this image"></a></p>
</figcaption>
</figure>
<p><strong>IcuChannel:</strong></p>
<p>The configuration of an individual ICU channel involves assigning the IcuChannelId, selecting the appropriate mode (e.g., timestamp or edge detection), setting the XBAR (crossbar) references, and configuring the ICU functional clock. These settings define how the channel will operate and interface with hardware resources, as illustrated in the configuration below -</p>
<figure class="align-center" id="id158">
<img alt="Configuration for IcuChannel" src="../_images/Icu_Channel.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.158 </span><span class="caption-text">Configuration for IcuChannel</span><a class="headerlink" href="#id158" title="Link to this image"></a></p>
</figcaption>
</figure>
<p><strong>IcuSignalMeasurement:</strong></p>
<p>This container holds the configuration parameters for the measurement mode set to IcuSignalMeasurement. In this configuration, the signal measurement property is set to ICU_PERIOD_TIME to enable period time measurement of the input signal -</p>
<figure class="align-center" id="id159">
<img alt="Configuration for IcuSignalMeasurementPropety" src="../_images/Icu_SignalMeasurementProperty.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.159 </span><span class="caption-text">Configuration for IcuSignalMeasurementPropety</span><a class="headerlink" href="#id159" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="mcu-configuration-in-icu-module">
<h5><span class="section-number">7.2.12.3.2. </span>MCU Configuration in ICU Module<a class="headerlink" href="#mcu-configuration-in-icu-module" title="Link to this heading"></a></h5>
<p>The following figure demonstrates the configuration of the ECAP0 interrupt within the MCU module for AM263Px. In this setup, the ECAP0 interrupt is routed through the XBAR (Crossbar) configuration. Specifically, MCU_INTRXBAR0_OUT_2 is selected as the output line, which is then mapped to MCU_INT_XBAR_EPWM3_INT. This routing enables the ECAP0 event to be captured correctly by the desired interrupt source -</p>
<figure class="align-center" id="id160">
<img alt="Configuration for McuXbarChannelTrigger Configuration" src="../_images/Mcu_XbarChannelTriggerIcu.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.160 </span><span class="caption-text">Configuration for McuXbarChannelTrigger Configuration</span><a class="headerlink" href="#id160" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>The following configuration illustrates the setup of an input XBAR trigger channel within the MCU module. In this example, MCU_INPUT_XBAR0_OUT_2 is selected as the output XBAR line, and it is mapped to the input source MCU_INPUT_XBAR_GPIO49. This mapping allows an external signal on GPIO49 to be routed through XBAR0 output channel 2, enabling it to trigger peripherals such as ECAP, EPWM, or other interrupt-driven modules -</p>
<figure class="align-center" id="id161">
<img alt="Configuration for McuInputXbarChannelTrigger Configuration" src="../_images/Mcu_InputXbarChannelTriggerIcu.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.161 </span><span class="caption-text">Configuration for McuInputXbarChannelTrigger Configuration</span><a class="headerlink" href="#id161" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="port-configuration-in-icu-module">
<h5><span class="section-number">7.2.12.3.3. </span>Port Configuration in ICU Module<a class="headerlink" href="#port-configuration-in-icu-module" title="Link to this heading"></a></h5>
<p>The PWM module has a dependency on the Port module to configure the output pins used for generating PWM signals. Each PWM channel is mapped to a specific physical pin on the microcontroller, which must be configured as an output using the Port module.</p>
<p>In the port pin configuration, EPWM3 is configured as a PWM output, as shown below -</p>
<figure class="align-center" id="id162">
<img alt="Port pin configuration for Pwm" src="../_images/Icu_Port.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.162 </span><span class="caption-text">Port Pin configuration for Pwm</span><a class="headerlink" href="#id162" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="iohwab-configuration-in-icu-module">
<h5><span class="section-number">7.2.12.3.4. </span>IoHwAb Configuration in ICU Module<a class="headerlink" href="#iohwab-configuration-in-icu-module" title="Link to this heading"></a></h5>
<p>IoHwAb is a layer in the AUTOSAR architecture that abstracts hardware-level interfaces and provides a standardized API to the upper layers.
To configure a Client/Server Port Interface, the container IoHwAb_IcuStartSignalMeasurement holds the configuration elements for a Client/Server template interface. This interface is instantiated by a Client/Server Port Prototype.
The container IoHwAbOperationArguments contains the configuration of Operation Elements, such as Channel for a Client/Server Operation. These Operation Elements will be generated as function parameters in the I/O Hardware Abstraction (IoHwAb) implementation.
Similarly, it is possible to enable communication between the I/O Client/Server interface and the MCAL APIs.
Configuration of ICU IoHwAbCS port interface as shown below -</p>
<figure class="align-center" id="id163">
<img alt="Configuration of ICU CSPortinterface" src="../_images/IoHwAb_Icu.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.163 </span><span class="caption-text">Configuration of ICU CSPortinterface</span><a class="headerlink" href="#id163" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>The container IoHwAbIcuStartSignalMeasurement is used for configuring a Client/Server Port Prototype. This container represents an instantiation of a Client/Server Port Interface.
Configuration of cddIcu IoHwAbCS port prototype as shown below -</p>
<figure class="align-center" id="id164">
<img alt="Configuration of ICU PortPrototype" src="../_images/IoHwAb_Icu1.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.164 </span><span class="caption-text">Configuration of ICU PortPrototype</span><a class="headerlink" href="#id164" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>The function IoHwAb_IcuStartSignalMeasurement Operation is generated, and then the MCAL API function Icu_StartSignalMeasurement is called. In the RTE (Runtime Environment), the corresponding port is created based on the configuration, and it can be used as a Sender-Receiver Port for communication between software components -</p>
<figure class="align-center" id="id165">
<img alt="Invoking MCAL API for Icu_StartSignalMeasurement" src="../_images/IoHwAb_IcuFun.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.165 </span><span class="caption-text">Invoking MCAL API for Icu_StartSignalMeasurement</span><a class="headerlink" href="#id165" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
</section>
</section>
<section id="gpt-integration">
<h3><span class="section-number">7.2.13. </span>GPT Integration<a class="headerlink" href="#gpt-integration" title="Link to this heading"></a></h3>
<section id="objective-for-gpt-integration">
<h4><span class="section-number">7.2.13.1. </span>Objective for GPT Integration<a class="headerlink" href="#objective-for-gpt-integration" title="Link to this heading"></a></h4>
<p>The intention of GPT Integration is to verify successful GPT functionalities by configuring TI MCAL modules along with Vector BSW Modules. Further details are explained in the subsequent chapter.</p>
</section>
<section id="list-of-modules-for-gpt-integration">
<h4><span class="section-number">7.2.13.2. </span>List of Modules for GPT Integration<a class="headerlink" href="#list-of-modules-for-gpt-integration" title="Link to this heading"></a></h4>
<section id="mcal-modules-for-gpt-integration">
<h5><span class="section-number">7.2.13.2.1. </span>MCAL Modules for GPT Integration<a class="headerlink" href="#mcal-modules-for-gpt-integration" title="Link to this heading"></a></h5>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Sl. No.</p></th>
<th class="head"><p>MCAL Modules</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>Significance in use case</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>Mcu</p></td>
<td><p>The MCU module manages microcontroller features for PWM, such as power modes and clock settings.</p></td>
<td><p>In this use case, this module is responsible for providing the clock for GPT module.</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>GPT</p></td>
<td><p>The GPT module initializes and manages hardware timers, enabling start/stop control, time value reading, and interrupt notifications. It operates in timer ticks, and conversion to real-time units must be handled by the application using clock and prescaler settings.</p></td>
<td><p>In this use case, this module responsible for providing 1ms toggling of DIO port pin in continuous mode.</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For detailed information, please refer to the section <a class="reference internal" href="Module_User_Guide_Gpt.html#gpt-module"><span class="std std-ref">GPT Module</span></a>.</p>
</div>
</section>
<section id="vector-modules-for-gpt-integration">
<h5><span class="section-number">7.2.13.2.2. </span>Vector Modules for GPT Integration<a class="headerlink" href="#vector-modules-for-gpt-integration" title="Link to this heading"></a></h5>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Sl. No.</p></th>
<th class="head"><p>Vector Modules</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>Significance in use case</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>IoHwAb</p></td>
<td><p>The aim of the IoHwAb is to provide ECU hardware-independent data transition from driver modules up to the Software Components.</p></td>
<td><p>It provides an abstraction for the ICU driver and enables communication with the application layer.</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>DET</p></td>
<td><p>The DET is used in order to report development errors. The DET can be replaced optionally by an equivalent component which is responsible for recognizing development errors, if no DET component is available.</p></td>
<td><p>In this use Case, Development error is enabled to detect all development errors.</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>RTE (MICROSAR Runtime Environment)</p></td>
<td><p>The Runtime Environment module manages the information flow between Software Components (SWCs), BSW and CDDs.</p></td>
<td><p>In this use case, Rte module is used to schedule the periodic tasks defined in the operating system (OS) and sender receiver ports created for sending receiving can messages from application.</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For detailed information on each module and its features, please refer to the Technical Reference Manual provided by Vector.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For importing MCAL configuration files to DaVinci refer <a class="reference internal" href="#importing-ti-mcal-modules-from-eb-tresos-to-vector-davinci-configurator"><span class="std std-ref">Importing TI MCAL modules from EB Tresos to Vector DaVinci Configurator</span></a>.</p>
</div>
</section>
</section>
<section id="configuration-of-modules-in-gpt-integration">
<h4><span class="section-number">7.2.13.3. </span>Configuration of modules in GPT Integration<a class="headerlink" href="#configuration-of-modules-in-gpt-integration" title="Link to this heading"></a></h4>
<p>This chapter explains the basic configurations that are needed to realize GPT functionalities.</p>
<section id="gpt-configuration">
<h5><span class="section-number">7.2.13.3.1. </span>GPT Configuration<a class="headerlink" href="#gpt-configuration" title="Link to this heading"></a></h5>
<p><strong>GptConfigurationOfOptApiServices:</strong></p>
<p>This container contains all configuration switches for configuring the optional API services of the GPT driver. The following figure shows the enabling of Api’s -</p>
<figure class="align-center" id="id166">
<img alt="Configuration for GptConfigurationOfOptApiServices" src="../_images/Gpt_OptApiServices.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.166 </span><span class="caption-text">Configuration for GptConfigurationOfOptApiServices</span><a class="headerlink" href="#id166" title="Link to this image"></a></p>
</figcaption>
</figure>
<p><strong>GptDriverConfiguration:</strong></p>
<p>This container contains the module-wide configuration (parameters) of the GPT Driver. The following figure shows the configuration of interrupt function and prescaler value and Gpt timeout duration -</p>
<figure class="align-center" id="id167">
<img alt="Configuration for GptDriverConfiguration" src="../_images/Gpt_DriverConfiguration.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.167 </span><span class="caption-text">Configuration for GptDriverConfiguration</span><a class="headerlink" href="#id167" title="Link to this image"></a></p>
</figcaption>
</figure>
<p><strong>GptChannelConfiguration:</strong></p>
<p>This container serves as the base of a Configuration Set, holding the configured GPT channels. It allows definition of multiple configuration sets for post-build usage, where each GPT channel is assigned a channel ID, mode, and optional notification function -</p>
<figure class="align-center" id="id168">
<img alt="Configuration for GptChannelConfiguration" src="../_images/Gpt_ChannelConfiguration.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.168 </span><span class="caption-text">Configuration for GptChannelConfiguration</span><a class="headerlink" href="#id168" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="mcu-configuration-in-gpt-integration">
<h5><span class="section-number">7.2.13.3.2. </span>Mcu Configuration in GPT Integration<a class="headerlink" href="#mcu-configuration-in-gpt-integration" title="Link to this heading"></a></h5>
<p>The GPT module relies on the MCU module to supply the necessary clock configurations.
The MCU clock configuration for GPT driver is shown below -</p>
<figure class="align-center" id="id169">
<img alt="Configuration for McuClockSettingConfig" src="../_images/McuClockSetting_Gpt.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.169 </span><span class="caption-text">Configuration for McuClockSettingConfig</span><a class="headerlink" href="#id169" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>GPT clock should be derived from MCU clock reference point.
The MCU clock reference point is shown below -</p>
<figure class="align-center" id="id170">
<img alt="Configuration for McuClockReferencePoint" src="../_images/McuClockRef_Gpt.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.170 </span><span class="caption-text">Configuration for McuClockReferencePoint</span><a class="headerlink" href="#id170" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="iohwab-configuration-in-gpt-integration">
<h5><span class="section-number">7.2.13.3.3. </span>IoHwAb Configuration in GPT Integration<a class="headerlink" href="#iohwab-configuration-in-gpt-integration" title="Link to this heading"></a></h5>
<p>IoHwAb is a layer in the AUTOSAR architecture that abstracts hardware-level interfaces and provides a standardized API to the upper layers.
To configure a Client/Server Port Interface, the container IoHwAb_GptStartTimer holds the configuration elements for a Client/Server template interface. This interface is instantiated by a Client/Server Port Prototype.
The container IoHwAbOperationArguments contains the configuration of Operation Elements, such as Channel for a Client/Server Operation. These Operation Elements will be generated as function parameters in the I/O Hardware Abstraction (IoHwAb) implementation.
Similarly, it is possible to enable communication between the I/O Client/Server interface and the MCAL APIs.
Configuration of ICU IoHwAbCS port interface as shown below -</p>
<figure class="align-center" id="id171">
<img alt="Configuration of GPT CSPortinterface" src="../_images/Gpt_IoHwAb_GptStartTimer.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.171 </span><span class="caption-text">Configuration of GPT CSPortinterface</span><a class="headerlink" href="#id171" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>The container IoHwAbGptStartTimer is used for configuring a Client/Server Port Prototype. This container represents an instantiation of a Client/Server Port Interface.
Configuration of Gpt IoHwAbCS port prototype as shown below -</p>
<figure class="align-center" id="id172">
<img alt="Configuration of GPT PortPrototype" src="../_images/Gpt_IoHwAbGptStartTimer.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.172 </span><span class="caption-text">Configuration of GPT PortPrototype</span><a class="headerlink" href="#id172" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>The function IoHwAb_GptStartTimer Operation is generated, and then the MCAL API function Icu_StartSignalMeasurement is called. In the RTE (Runtime Environment), the corresponding port is created based on the configuration, and it can be used as a Sender-Receiver Port for communication between software components -</p>
<figure class="align-center" id="id173">
<img alt="Invoking MCAL API for Gpt_StartTimer" src="../_images/IoHwAb_Gpt.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.173 </span><span class="caption-text">Invoking MCAL API for Gpt_StartTimer</span><a class="headerlink" href="#id173" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
</section>
</section>
<section id="cdd-fsi-integration">
<h3><span class="section-number">7.2.14. </span>CDD FSI Integration<a class="headerlink" href="#cdd-fsi-integration" title="Link to this heading"></a></h3>
<section id="objective-for-cdd-fsi-integration">
<h4><span class="section-number">7.2.14.1. </span>Objective for CDD FSI Integration<a class="headerlink" href="#objective-for-cdd-fsi-integration" title="Link to this heading"></a></h4>
<p>The intention of CDD FSI Integration is to enable successful CDD FSI communication by configuring TI MCAL modules along with Vector BSW Modules. Further details are explained in the subsequent chapter.</p>
</section>
<section id="list-of-modules-for-cdd-fsi-integration">
<h4><span class="section-number">7.2.14.2. </span>List of Modules for CDD FSI Integration<a class="headerlink" href="#list-of-modules-for-cdd-fsi-integration" title="Link to this heading"></a></h4>
<section id="mcal-modules-for-cdd-fsi-integration">
<h5><span class="section-number">7.2.14.2.1. </span>MCAL Modules for CDD FSI Integration<a class="headerlink" href="#mcal-modules-for-cdd-fsi-integration" title="Link to this heading"></a></h5>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Sl. No.</p></th>
<th class="head"><p>MCAL Modules</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>Significance in use case</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>FsiRx</p></td>
<td><p>The Fast Serial Interface (FSI) is a high-speed serial communication module designed for reliable data transfer, especially across isolation barriers without needing extra components. It includes two separate parts: the CDD FSI Transmitter (CDD FSI TX) and the CDD FSI Receiver (CDD FSI RX). These are implemented as Complex Device Drivers (CDD) in AUTOSAR and work independently from each other.</p></td>
<td><p>In this use case, this module is responsible for reception of transmitted data.</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>FsiTx</p></td>
<td><p>The Fast Serial Interface (FSI) is a high-speed serial communication module designed for reliable data transfer, especially across isolation barriers without needing extra components. It includes two separate parts: the CDD FSI Transmitter (CDD FSI TX) and the CDD FSI Receiver (CDD FSI RX). These are implemented as Complex Device Drivers (CDD) in AUTOSAR and work independently from each other.</p></td>
<td><p>In this use case, this module is responsible for transmitting data frames.</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>Mcu</p></td>
<td><p>The MCU module manages microcontroller features for PWM, such as power modes and clock settings.</p></td>
<td><p>In this use case, this module is responsible for providing the clock for FSI clock generation.</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For detailed information, please refer to the section <a class="reference internal" href="Module_User_Guide_Cdd_FsiRx.html#cdd-fsirx-module"><span class="std std-ref">FSIRX Module</span></a>.
For detailed information, please refer to the section <a class="reference internal" href="Module_User_Guide_Cdd_FsiTx.html#cdd-fsitx-module"><span class="std std-ref">FSITX Module</span></a>.</p>
</div>
</section>
<section id="vector-modules-for-cdd-fsi-integration">
<h5><span class="section-number">7.2.14.2.2. </span>Vector Modules for CDD FSI Integration<a class="headerlink" href="#vector-modules-for-cdd-fsi-integration" title="Link to this heading"></a></h5>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Sl. No.</p></th>
<th class="head"><p>Vector Modules</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>Significance in use case</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>IoHwAb</p></td>
<td><p>The aim of the IoHwAb is to provide ECU hardware-independent data transition from driver modules up to the Software Components.</p></td>
<td><p>It provides an abstraction for the CDD FSI driver and enables communication with the application layer.</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>DET</p></td>
<td><p>The DET is used in order to report development errors. The DET can be replaced optionally by an equivalent component which is responsible for recognizing development errors, if no DET component is available.</p></td>
<td><p>In this use Case, Development error is enabled to detect all development errors.</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>RTE (MICROSAR Runtime Environment)</p></td>
<td><p>The Runtime Environment module manages the information flow between Software Components (SWCs), BSW and CDDs.</p></td>
<td><p>In this use case, Rte module is used to schedule the periodic tasks defined in the operating system (OS) and sender receiver ports created for sending receiving can messages from application.</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For detailed information on each module and its features, please refer to the Technical Reference Manual provided by Vector.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For importing MCAL configuration files to DaVinci refer <a class="reference internal" href="#importing-ti-mcal-modules-from-eb-tresos-to-vector-davinci-configurator"><span class="std std-ref">Importing TI MCAL modules from EB Tresos to Vector DaVinci Configurator</span></a>.</p>
</div>
</section>
</section>
<section id="configuration-of-modules-in-cdd-fsi-integration">
<h4><span class="section-number">7.2.14.3. </span>Configuration of modules in CDD FSI Integration<a class="headerlink" href="#configuration-of-modules-in-cdd-fsi-integration" title="Link to this heading"></a></h4>
<p>This chapter explains the basic configurations that are needed to realize CDD FSI communication.</p>
<section id="fsirx-configuration">
<h5><span class="section-number">7.2.14.3.1. </span>FsiRx Configuration<a class="headerlink" href="#fsirx-configuration" title="Link to this heading"></a></h5>
<p><strong>CddFsiRxConfigSet:</strong></p>
<p>This container contains the configuration parameters and sub containers of the AUTOSAR CDD FSI Rx module. The configuration below shows the configuration of callback functions configuration -</p>
<figure class="align-center" id="id174">
<img alt="Configuration for CddFsiRxConfigSet" src="../_images/CddFsiRxConfigSet.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.174 </span><span class="caption-text">Configuration for CddFsiRxConfigSet</span><a class="headerlink" href="#id174" title="Link to this image"></a></p>
</figcaption>
</figure>
<p><strong>CddFsiRxGeneral:</strong></p>
<p>The CDDFsiRxGeneral contains the enabling and disabling required apis and gives interrupt function type, interrupt vector, number of DMA channelIds and MaxHwUnitCount as shown below -</p>
<figure class="align-center" id="id175">
<img alt="Configuration for CddFsiRxGeneral" src="../_images/CddFsiRxGeneral.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.175 </span><span class="caption-text">Configuration for CddFsiRxGeneral</span><a class="headerlink" href="#id175" title="Link to this image"></a></p>
</figcaption>
</figure>
<p><strong>CddFsiRxHwUnit:</strong></p>
<p>This container holds the driver configuration parameters used to set up the CDD FSI Rx hardware unit. The configuration includes the HwUnitId, RxPingWdgTimerTimeout, RxFrameWdgTimerTimeout, and the CDD FSI Rx reception method, which can be set to Interrupt mode, Polling mode, or DMA mode. The figure below illustrates a configuration where the reception method is set to Interrupt mode -</p>
<figure class="align-center" id="id176">
<img alt="Configuration for CddFsiRxHwUnit" src="../_images/CddFsiRxHwUnit.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.176 </span><span class="caption-text">Configuration for CddFsiRxHwUnit</span><a class="headerlink" href="#id176" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="fsitx-configuration">
<h5><span class="section-number">7.2.14.3.2. </span>FsiTx Configuration<a class="headerlink" href="#fsitx-configuration" title="Link to this heading"></a></h5>
<p><strong>CddFsiTxConfigSet:</strong></p>
<p>This container contains the configuration parameters and sub containers of the AUTOSAR CDD FSI Tx module. The configuration below shows the configuration of callback functions configuration -</p>
<figure class="align-center" id="id177">
<img alt="Configuration for CddFsiTxConfigSet" src="../_images/CddFsiTxConfigSet.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.177 </span><span class="caption-text">Configuration for CddFsiTxConfigSet</span><a class="headerlink" href="#id177" title="Link to this image"></a></p>
</figcaption>
</figure>
<p><strong>CddFsiTxGeneral:</strong></p>
<p>The CDDFsiTxGeneral contains the enabling and disabling required apis and gives interrupt function type, interrupt vector, number of DMA channelIds and MaxHwUnitCount as shown below -</p>
<figure class="align-center" id="id178">
<img alt="Configuration for CddFsiTxGeneral" src="../_images/CddFsiTxGeneral.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.178 </span><span class="caption-text">Configuration for CddFsiTxGeneral</span><a class="headerlink" href="#id178" title="Link to this image"></a></p>
</figcaption>
</figure>
<p><strong>CddFsiTxHwUnit:</strong></p>
<p>This container holds the driver configuration parameters used to set up the CDD FSI Tx hardware unit. The configuration includes the HwUnitId, TxPingTimerTimeout, TxPrescale, and the CDD FSI Tx transmission method, which can be set to Interrupt mode, Polling mode, or DMA mode. The figure below illustrates a configuration where the reception method is set to Interrupt mode.</p>
<figure class="align-center" id="id179">
<img alt="Configuration for CddFsiTxHwUnit" src="../_images/CddFsiTxHwUnit.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.179 </span><span class="caption-text">Configuration for CddFsiTxHwUnit</span><a class="headerlink" href="#id179" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="port-configuration-for-cdd-fsi-integration">
<h5><span class="section-number">7.2.14.3.3. </span>port configuration for CDD FSI Integration<a class="headerlink" href="#port-configuration-for-cdd-fsi-integration" title="Link to this heading"></a></h5>
<p>The CDD FSI Rx module has a dependency on the Port module to configure the output pins used. Each CDD FSI Rx channel is mapped to a specific physical pin on the microcontroller, which must be configured as an output using the Port module. Configuration of a CDD FSI Rx CLK pin is as shown below.
The following figure shows port pin configuration of CDD FSI Rx where PIN_E1 is configured as FSIRX1_CLK -</p>
<figure class="align-center" id="id180">
<img alt="configuration for FsiRx1_CLK" src="../_images/CddFsiRx_PortCfg.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.180 </span><span class="caption-text">configuration for FsiRx1_CLK</span><a class="headerlink" href="#id180" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>The CDD FSI Tx module has a dependency on the Port module to configure the output pins used. Each CDD FSI Tx channel is mapped to a specific physical pin on the microcontroller, which must be configured as an output using the Port module. Configuration of a CDD FSI Tx CLK pin is as shown below.
The following figure shows port pin configuration of CDD FSI Tx where PIN_E4 is configured as FSITX1_CLK -</p>
<figure class="align-center" id="id181">
<img alt="configuration for FsiTx1_CLK" src="../_images/CddFsiTx_PortCfg.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.181 </span><span class="caption-text">configuration for FsiTx1_CLK</span><a class="headerlink" href="#id181" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="iohwab-configuration-for-cdd-fsi-integration">
<h5><span class="section-number">7.2.14.3.4. </span>IoHwAb configuration for CDD FSI Integration<a class="headerlink" href="#iohwab-configuration-for-cdd-fsi-integration" title="Link to this heading"></a></h5>
<p>IoHwAb is a layer in the AUTOSAR architecture that abstracts hardware-level interfaces and provides a standardized API to the upper layers.
To configure a Client/Server Port Interface, the container IoHwAb_Cdd_FsiRx_GetStatus holds the configuration elements for a Client/Server template interface. This interface is instantiated by a Client/Server Port Prototype.
The container IoHwAbOperationArguments contains the configuration of Operation Elements, such as Channel for a Client/Server Operation. These Operation Elements will be generated as function parameters in the I/O Hardware Abstraction (IoHwAb) implementation.
Similarly, it is possible to enable communication between the I/O Client/Server interface and the MCAL APIs.
Configuration of ICU IoHwAbCS port interface as shown below -</p>
<figure class="align-center" id="id182">
<img alt="Configuration of CDD FSI CSPortinterface" src="../_images/IoHwAb_FsiRx_getstatus.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.182 </span><span class="caption-text">Configuration of CDD FSI CSPortinterface</span><a class="headerlink" href="#id182" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>The container IoHwAbCddFsiRxGetStatus is used for configuring a Client/Server Port Prototype. This container represents an instantiation of a Client/Server Port Interface.
Configuration of cddFsi IoHwAbCS port prototype as shown below -</p>
<figure class="align-center" id="id183">
<img alt="Configuration of CDD FSI PortPrototype" src="../_images/IoHwAb_FsiRx_getstatus1.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.183 </span><span class="caption-text">Configuration of CDD FSI PortPrototype</span><a class="headerlink" href="#id183" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>The function IoHwAb_CddFsiRxGetStatus Operation is generated, and then the MCAL API function CddFsiRx_GetStatus is called. In the RTE (Runtime Environment), the corresponding port is created based on the configuration, and it can be used as a Sender-Receiver Port for communication between software components -</p>
<figure class="align-center" id="id184">
<img alt="Invoking MCAL API for CddFsiRx_GetStatus" src="../_images/CddFsiRx_GetStatus.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.184 </span><span class="caption-text">Invoking MCAL API for CddFsiRx_GetStatus</span><a class="headerlink" href="#id184" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
</section>
</section>
<section id="cdd-uart-integration">
<h3><span class="section-number">7.2.15. </span>CDD_UART Integration<a class="headerlink" href="#cdd-uart-integration" title="Link to this heading"></a></h3>
<section id="objective-for-cdd-uart-integration">
<h4><span class="section-number">7.2.15.1. </span>Objective for CDD_UART Integration<a class="headerlink" href="#objective-for-cdd-uart-integration" title="Link to this heading"></a></h4>
<p>The intention of UART Integration is to enable successful UART communication by configuring TI MCAL modules along with Vector BSW Modules. Further details are explained in the subsequent chapter.</p>
</section>
<section id="list-of-modules-for-cdd-uart-integration">
<h4><span class="section-number">7.2.15.2. </span>List of Modules for CDD_UART Integration<a class="headerlink" href="#list-of-modules-for-cdd-uart-integration" title="Link to this heading"></a></h4>
<section id="mcal-modules-for-cdd-uart-integration">
<h5><span class="section-number">7.2.15.2.1. </span>MCAL Modules for CDD_UART Integration<a class="headerlink" href="#mcal-modules-for-cdd-uart-integration" title="Link to this heading"></a></h5>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Sl.No.</p></th>
<th class="head"><p>MCAL Modules</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>Significance in use case</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>UART</p></td>
<td><p>The UART module initializes and controls the internal UART peripherals of the microcontroller. It provides services to configure baud rate, frame format, and to transmit and receive data over serial communication channels.</p></td>
<td><p>In this use case UART module is responsible for enabling serial communication between the microcontroller and external devices. Moreover it facilitates reliable data transmission and reception through asynchronous communication.</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>Mcu</p></td>
<td><p>The MCU module manages microcontroller features for UART, such as clock configuration, power modes, and interrupt settings required for UART communication.</p></td>
<td><p>In this use case, this module is responsible for providing the clock and initialization required for UART-based serial communication between the microcontroller and external devices.</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>Port</p></td>
<td><p>The PORT module provides an interface to configure and control the microcontroller pins used for UART communication, such as setting the TX and RX pins to the appropriate functions.</p></td>
<td><p>In this use case, this module is responsible for configuring the hardware pins necessary for UART communication, such as setting the TX and RX pins to their correct functions.</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For detailed information, please refer to the section <a class="reference internal" href="Module_User_Guide_Cdd_uart.html#cdd-uart-module"><span class="std std-ref">CDD_UART Module</span></a>.</p>
</div>
</section>
<section id="vector-modules-for-cdd-uart-integration">
<h5><span class="section-number">7.2.15.2.2. </span>Vector Modules for CDD_UART Integration<a class="headerlink" href="#vector-modules-for-cdd-uart-integration" title="Link to this heading"></a></h5>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Sl.No.</p></th>
<th class="head"><p>Vector Modules</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>Significance in use case</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>IoHwAb</p></td>
<td><p>This module provides an abstraction layer for handling UART operations, enabling seamless interaction with UART hardware channels.</p></td>
<td><p>It provides an abstraction for the UART driver and enables communication with the application layer.</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>OS</p></td>
<td><p>The Operating System is mainly responsible for handling tasks.</p></td>
<td><p>In this use case, it is used to initialize UART and manage UART-related task scheduling.</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>Rte</p></td>
<td><p>The Runtime Environment module manages the information flow between software components and the ECU abstraction layers.</p></td>
<td><p>In this use case, it is used to schedule and route UART communication tasks between the application and lower layers.</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For detailed information on each module and its features, please refer to the Technical Reference Manual provided by Vector.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For importing MCAL configuration files to DaVinci refer <a class="reference internal" href="#importing-ti-mcal-modules-from-eb-tresos-to-vector-davinci-configurator"><span class="std std-ref">Importing TI MCAL modules from EB Tresos to Vector DaVinci Configurator</span></a>.</p>
</div>
</section>
</section>
<section id="configuration-of-modules-in-cdd-uart-integration">
<h4><span class="section-number">7.2.15.3. </span>Configuration of modules in CDD_UART Integration<a class="headerlink" href="#configuration-of-modules-in-cdd-uart-integration" title="Link to this heading"></a></h4>
<p>This chapter explains the basic configurations that are needed to realize CDD UART functionalities.</p>
<section id="cdd-uart-configuration">
<h5><span class="section-number">7.2.15.3.1. </span>CDD_UART Configuration<a class="headerlink" href="#cdd-uart-configuration" title="Link to this heading"></a></h5>
<p>The UART driver is configured using the EB Tresos tool and then imported into the Vector DaVinci Configurator for integration with the application software. The following containers and parameters should be configured.</p>
<p><strong>CDD_UART General:</strong></p>
<p>The UART General container provides general configuration settings for the UART module.</p>
<p>In UART general settings, CddUartReadApi, CddUartWriteApi and CddUartirq Type is enabled as shown below -</p>
<figure class="align-center" id="id185">
<img alt="Configuration for CDD_UART General settings" src="../_images/Configuration_for_CDD_UART_General_settings.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.185 </span><span class="caption-text">Configuration for CDD_UART General settings</span><a class="headerlink" href="#id185" title="Link to this image"></a></p>
</figcaption>
</figure>
<p><strong>CDD_UART Channel:</strong></p>
<p>The CddUartChannel configuration container defines the configuration parameters for an individual UART channel.</p>
<p>In CddUartChannel configuration, The user needs to specify the CddUartHwID and CddUartIOMode as shown below -</p>
<figure class="align-center" id="id186">
<img alt="Configuration of CddUarChannel settings" src="../_images/Configuration_of_cdduart_channel.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.186 </span><span class="caption-text">Configuration of CddUarChannel settings</span><a class="headerlink" href="#id186" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="mcu-configuration-for-cdd-uart-integration">
<h5><span class="section-number">7.2.15.3.2. </span>Mcu Configuration for CDD_UART Integration<a class="headerlink" href="#mcu-configuration-for-cdd-uart-integration" title="Link to this heading"></a></h5>
<p>The UART module relies on the MCU module to supply the necessary clock configurations.</p>
<p>The MCU clock configuration for UART driver is shown below -</p>
<figure class="align-center" id="id187">
<img alt="General Configuration of MCU Clock" src="../_images/General_Configuration_of_MCU_Clock.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.187 </span><span class="caption-text">General Configuration of MCU Clock</span><a class="headerlink" href="#id187" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>UART clock should be derived from MCU clock reference point.</p>
<p>The MCU clock reference point is shown below -</p>
<figure class="align-center" id="id188">
<img alt="Configuration of McuClockReferencePoint" src="../_images/Configuration_of_Uartmcu_clock_reference_pt.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.188 </span><span class="caption-text">Configuration of McuClockReferencePoint</span><a class="headerlink" href="#id188" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="port-configuration-for-cdd-uart-integration">
<h5><span class="section-number">7.2.15.3.3. </span>Port Configuration for CDD_UART Integration<a class="headerlink" href="#port-configuration-for-cdd-uart-integration" title="Link to this heading"></a></h5>
<p>The UART module has a dependency on the Port module to configure the pins used for UART communication. Each UART channel is mapped to specific physical pins on the microcontroller, which must be configured as the appropriate alternate functions (TX/RX) using the Port module.</p>
<p>In the port pin configuration, select PortPinPeripheral, PortPinPeripheralSignal, and PortPinDirection as shown below -</p>
<figure class="align-center" id="id189">
<img alt="Configuration of Port Pin" src="../_images/Port_Pin_Configuration.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.189 </span><span class="caption-text">Configuration of Port Pin</span><a class="headerlink" href="#id189" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>Similarly, port pin for UART RX can be configured.</p>
</section>
<section id="iohwab-configuration-for-cdd-uart-integration">
<h5><span class="section-number">7.2.15.3.4. </span>IoHwAb Configuration for CDD_UART Integration<a class="headerlink" href="#iohwab-configuration-for-cdd-uart-integration" title="Link to this heading"></a></h5>
<p>IoHwAb is a layer in the AUTOSAR architecture that abstracts hardware-level interfaces and provides a standardized API to the upper layers.</p>
<p>To configure a Client/Server Port Interface, the container IoHwAbCS_Uart_read holds the configuration elements for a Client/Server template interface. This interface is instantiated by a Client/Server Port Prototype.</p>
<p>The container IoHwAbOperationArguments contains the configuration of Operation Elements, such as ChannelID, Length, Timeout, UartDestBufferptr for a Client/Server Operation. These Operation Elements will be generated as function parameters in the I/O Hardware Abstraction (IoHwAb) implementation.</p>
<p>Similarly, it is possible to enable communication between the I/O Client/Server interface and the MCAL APIs.</p>
<p>Configuration of UART IoHwAbCS port interface as shown below -</p>
<figure class="align-center" id="id190">
<img alt="Configuration of cdduart CSPortinterface" src="../_images/Configuration_of_CDDUART_CS_Portinterface.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.190 </span><span class="caption-text">Configuration of cdduart CSPortinterface</span><a class="headerlink" href="#id190" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>The container IoHwAbCSUar_read is used for configuring a Client/Server Port Prototype. This container represents an instantiation of a Client/Server Port Interface.</p>
<p>Configuration of cdduart IoHwAbCS port prototype as shown below -</p>
<figure class="align-center" id="id191">
<img alt="Configuration of cdduart PortPrototype" src="../_images/Configuration_of_CDDUART_PortPrototype.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.191 </span><span class="caption-text">Configuration of cdduart PortPrototypes</span><a class="headerlink" href="#id191" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>The function IoHwAb_IoHwAbCSUart_read_IoHwAbOperation is generated, and then the MCAL API function Cdd_Uart_Read is called.</p>
<p>In the RTE (Runtime Environment), the corresponding port is created based on the configuration, and it can be used as a Sender-Receiver Port for communication between software components -</p>
<figure class="align-center" id="id192">
<img alt="Invocking MCAL API for Cdd Uart Read" src="../_images/Invocking_MCAL_API_for_Cdd_Uart_Read.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.192 </span><span class="caption-text">Invocking MCAL API for Cdd Uart Read</span><a class="headerlink" href="#id192" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
</section>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Key_Performance_and_Memory_Consumption_Data.html" class="btn btn-neutral float-left" title="6. Key Performance and Memory Consumption Data" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; <a href="https://www.ti.com/corp/docs/legal/copyright.shtml">Copyright</a>  2025, Texas Instruments Incorporated.
          <span class="lastupdated" >Last updated on Dec 05, 2025.
      </span><br>
        <a href="https://www.ti.com/corp/docs/legal/trademark/trademrk.htm">Trademarks</a> | <a href="https://www.ti.com/corp/docs/legal/privacy.shtml">Privacy policy</a> | <a href="https://www.ti.com/corp/docs/legal/termsofuse.shtml">Terms of use</a> | <a href="https://www.ti.com/lsds/ti/legal/termsofsale.page">Terms of sale</a> <br>

    </p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="Versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      <span class="fa fa-book"></span>
       Current Version: 11.01.00
      <span class="fa fa-caret-down"></span>
    </span>
    <div class="rst-other-versions">
      <dl id="version-list">
        <dt>Versions</dt>
        <!-- Dynamic content will be inserted here -->
      </dl>
    </div>
  </div>
  
  <style>
    #version-list dd {
        display: block; 
    }
  </style>
  
  <script>
    // Function to fetch the JSON file from GitHub and populate the version links
    async function loadVersions() {
      try {
    const versionsUrl = '';
        const response = await fetch(versionsUrl); // Replace with your raw URL
        const versions = await response.json();
        const versionList = document.getElementById('version-list');
  
        // Iterate over the versions and create list items
        for (const [version, url] of Object.entries(versions)) {
          const listItem = document.createElement('dd');
          const link = document.createElement('a');
          link.href = url;
          link.textContent = version;
          listItem.appendChild(link);
          versionList.appendChild(listItem);
        }
      } catch (error) {
        console.error('Error loading versions:', error);
      }
    }
    loadVersions();
  </script><script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>